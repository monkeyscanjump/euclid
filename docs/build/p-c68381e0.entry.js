import{r as t}from"./p-KvMX95QM.js";import{l as e,a as s,D as n}from"./p-CDg7SVxJ.js";import{m as a}from"./p-BAyCcMK2.js";import{w as o}from"./p-B5JcU1Ey.js";import{d as i,E as r}from"./p-CKexLjV3.js";import{s as c}from"./p-Jv3i9Hia.js";import"./p-CHLqsENg.js";const l=class{constructor(e){t(this,e);this.isInitialized=false}async componentDidLoad(){await this.initialize()}async initialize(){console.log("💧 Initializing Liquidity Controller...");e.onChange("selectedPool",(()=>this.handlePoolChange()));this.isInitialized=true;console.log("✅ Liquidity Controller initialized")}handlePoolChange(){const{selectedPool:t}=e.state;if(t){console.log("🏊 Pool selected for liquidity operations:",t.id)}}async executeAddLiquidity(){try{const{selectedPool:t,token1:n,token2:a,token1Amount:c,token2Amount:l}=e.state;if(!t||!n||!a||!c||!l){return{success:false,error:"Missing required liquidity parameters"}}const u=o.getWallet(n.chainUID);const h=o.getWallet(a.chainUID);if(!u?.isConnected){return{success:false,error:`Wallet not connected for ${n.symbol}`}}if(!h?.isConnected){return{success:false,error:`Wallet not connected for ${a.symbol}`}}if(!o.hasSufficientBalance(n.chainUID,n.id,c)){return{success:false,error:`Insufficient ${n.symbol} balance`}}if(!o.hasSufficientBalance(a.chainUID,a.id,l)){return{success:false,error:`Insufficient ${a.symbol} balance`}}e.setAddingLiquidity(true);console.log("💧 Executing add liquidity...",{pool:t.id,token1:n.symbol,token2:a.symbol,amount1:c,amount2:l});const d=await s.createAddLiquidityTransactionWrapped({slippage_tolerance_bps:50,timeout:(Math.floor(Date.now()/1e3)+1200).toString(),pair_info:{token_1:{token:n.id,amount:c,token_type:n.token_type||{native:{denom:n.id}}},token_2:{token:a.id,amount:l,token_type:a.token_type||{native:{denom:a.id}}}},sender:{address:u.address,chain_uid:n.chainUID}});if(d.success&&d.data){const t=d.data;const{txHash:e}=t;const s=o.getAllConnectedWallets();const n=s[0];const a=n.chainUID;o.addTransaction(a,{txHash:e||d.data?.transactionHash||"pending",timestamp:Date.now(),type:"add_liquidity"});i(r.TRANSACTION.SUBMITTED,{txHash:e,chainUID:a,type:"add_liquidity"});console.log("✅ Add liquidity transaction submitted:",e);return{success:true,txHash:e}}else{return{success:false,error:d.error||"Add liquidity execution failed"}}}catch(t){const e=t instanceof Error?t.message:"Unknown error occurred";console.error("❌ Add liquidity execution error:",e);return{success:false,error:e}}finally{e.setAddingLiquidity(false)}}async executeRemoveLiquidity(t,n){try{const c=e.getPosition(t);if(!c){return{success:false,error:"Liquidity position not found"}}const l=a.state.pools;const u=l.find((e=>e.id===t));if(!u){return{success:false,error:"Pool not found"}}const h=a.state.tokens;const d=h.find((t=>t.address===u.token_1));if(!d){return{success:false,error:"Token metadata not found"}}const f=o.getWallet(d.chain_uid);if(!f?.isConnected){return{success:false,error:`Wallet not connected for ${d.chain_uid}`}}const m=o.getWalletBalance(d.chain_uid,`lp-${t}`);if(!m||BigInt(m.amount)<BigInt(n)){return{success:false,error:"Insufficient LP token balance"}}e.setRemovingLiquidity(true);console.log("💧 Executing remove liquidity...",{poolId:t,lpAmount:n});const p=await s.createRemoveLiquidityTransactionWrapped({slippage_tolerance_bps:50,timeout:(Math.floor(Date.now()/1e3)+1200).toString(),lp_token_amount:n,sender:{address:f.address,chain_uid:d.chain_uid}});if(p.success&&p.data){const t=p.data;const{txHash:e}=t;o.addTransaction(d.chain_uid,{txHash:e,timestamp:Date.now(),type:"remove_liquidity"});i(r.TRANSACTION.SUBMITTED,{txHash:e,chainUID:d.chain_uid,type:"remove_liquidity"});console.log("✅ Remove liquidity transaction submitted:",e);return{success:true,txHash:e}}else{return{success:false,error:p.error||"Remove liquidity execution failed"}}}catch(t){const e=t instanceof Error?t.message:"Unknown error occurred";console.error("❌ Remove liquidity execution error:",e);return{success:false,error:e}}finally{e.setRemovingLiquidity(false)}}async handleAddLiquidityExecution(){console.log("💧 Add liquidity execution requested via event");const t=await this.executeAddLiquidity();if(t.success){i(r.LIQUIDITY.ADD_SUCCESS,{txHash:t.txHash})}else{i(r.LIQUIDITY.ADD_FAILED,{error:t.error})}}async handleRemoveLiquidityExecution(t){console.log("💧 Remove liquidity execution requested via event");const{poolId:e,lpTokenAmount:s}=t.detail;const n=await this.executeRemoveLiquidity(e,s);if(n.success){i(r.LIQUIDITY.REMOVE_SUCCESS,{txHash:n.txHash})}else{i(r.LIQUIDITY.REMOVE_FAILED,{error:n.error})}}onInitializedChange(t){if(t){console.log("💧 Liquidity Controller ready for operations")}}render(){return null}static get watchers(){return{isInitialized:["onInitializedChange"]}}};var u;class h{get keplr(){return window.keplr}isInstalled(){return!!window.keplr}async connect(t){try{if(!this.isInstalled()){return{success:false,error:"Keplr wallet not installed"}}if(t.type==="Cosmwasm"){try{await this.keplr.experimentalSuggestChain({chainId:t.chain_id,chainName:t.display_name,rpc:"https://rpc.cosmos.network",rest:"https://api.cosmos.network",bip44:{coinType:118},bech32Config:{bech32PrefixAccAddr:this.getAddressPrefix(t.chain_id),bech32PrefixAccPub:this.getAddressPrefix(t.chain_id)+"pub",bech32PrefixValAddr:this.getAddressPrefix(t.chain_id)+"valoper",bech32PrefixValPub:this.getAddressPrefix(t.chain_id)+"valoperpub",bech32PrefixConsAddr:this.getAddressPrefix(t.chain_id)+"valcons",bech32PrefixConsPub:this.getAddressPrefix(t.chain_id)+"valconspub"},currencies:[{coinDenom:"ATOM",coinMinimalDenom:"uatom",coinDecimals:6}],feeCurrencies:[{coinDenom:"ATOM",coinMinimalDenom:"uatom",coinDecimals:6}],stakeCurrency:{coinDenom:"ATOM",coinMinimalDenom:"uatom",coinDecimals:6}})}catch(t){console.warn("Failed to suggest chain to Keplr:",t)}}await this.keplr.enable(t.chain_id);const e=this.keplr.getOfflineSigner(t.chain_id);const s=await e.getAccounts();if(s.length===0){return{success:false,error:"No accounts found"}}return{success:true,address:s[0].address,chainId:t.chain_id}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to connect to Keplr"}}}async disconnect(t){console.log("Keplr disconnect requested for:",t)}async getAddress(t){try{if(!this.isInstalled())return null;const e=await this.keplr.getKey(t);return e.bech32Address}catch{return null}}async switchChain(t){try{await this.keplr.enable(t.chain_id);return true}catch{return false}}getAddressPrefix(t){const e={"cosmoshub-4":"cosmos","osmosis-1":"osmo","juno-1":"juno","stargaze-1":"stars"};return e[t]||"cosmos"}}class d{get ethereum(){return window.ethereum}isInstalled(){return!!window.ethereum&&window.ethereum.isMetaMask}async connect(t){try{if(!this.isInstalled()){return{success:false,error:"MetaMask not installed"}}if(t.type!=="EVM"){return{success:false,error:"MetaMask only supports EVM chains"}}const e=await this.ethereum.request({method:"eth_requestAccounts"});if(!Array.isArray(e)||e.length===0){return{success:false,error:"No accounts found"}}const s=await this.switchChain(t);if(!s){return{success:false,error:"Failed to switch network"}}return{success:true,address:e[0],chainId:t.chain_id}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to connect to MetaMask"}}}async disconnect(t){}async getAddress(t){try{if(!this.isInstalled())return null;const t=await this.ethereum.request({method:"eth_accounts"});return Array.isArray(t)&&t.length>0?t[0]:null}catch{return null}}async switchChain(t){try{const e=`0x${parseInt(t.chain_id).toString(16)}`;try{await this.ethereum.request({method:"wallet_switchEthereumChain",params:[{chainId:e}]});return true}catch(s){if(s.code===4902){await this.ethereum.request({method:"wallet_addEthereumChain",params:[{chainId:e,chainName:t.display_name,rpcUrls:["https://rpc.example.com"],nativeCurrency:{name:"ETH",symbol:"ETH",decimals:18},blockExplorerUrls:t.explorer_url?[t.explorer_url]:[]}]});return true}throw s}}catch{return false}}}class f{get cosmostation(){return window.cosmostation}isInstalled(){return!!window.cosmostation}async connect(t){try{if(!this.isInstalled()){return{success:false,error:"Cosmostation wallet not installed"}}if(t.type!=="Cosmwasm"){return{success:false,error:"Cosmostation only supports Cosmos chains"}}const e=await this.cosmostation.cosmos.request({method:"cos_requestAccount",params:{chainName:t.chain_id}});return{success:true,address:e.address,chainId:t.chain_id}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to connect to Cosmostation"}}}async disconnect(t){console.log("Cosmostation disconnect requested for:",t)}async getAddress(t){try{if(!this.isInstalled())return null;const e=await this.cosmostation.cosmos.request({method:"cos_account",params:{chainName:t}});return e?.address||null}catch{return null}}async switchChain(t){return true}}class m{get phantom(){return window.phantom?.ethereum}isInstalled(){return!!this.phantom}async connect(t){try{if(!this.isInstalled()){return{success:false,error:"Phantom wallet not installed"}}if(t.type!=="EVM"){return{success:false,error:"Phantom only supports EVM chains"}}const e=await this.phantom.request({method:"eth_requestAccounts"});if(!Array.isArray(e)||e.length===0){return{success:false,error:"No accounts found"}}return{success:true,address:e[0],chainId:t.chain_id}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to connect to Phantom"}}}async disconnect(t){}async getAddress(t){try{if(!this.isInstalled())return null;const t=await this.phantom.request({method:"eth_accounts"});return Array.isArray(t)&&t.length>0?t[0]:null}catch{return null}}async switchChain(t){try{const e=`0x${parseInt(t.chain_id).toString(16)}`;await this.phantom.request({method:"wallet_switchEthereumChain",params:[{chainId:e}]});return true}catch{return false}}}class p{static getAdapter(t){return this.adapters.get(t)||null}static getAvailableWallets(){return Array.from(this.adapters.entries()).map((([t,e])=>({type:t,installed:e.isInstalled()})))}static async connectWallet(t,e){const s=this.getAdapter(t);if(!s){return{success:false,error:`Adapter not found for ${t}`}}return s.connect(e)}static async disconnectWallet(t,e){const s=this.getAdapter(t);if(s){await s.disconnect(e)}}}u=p;p.adapters=new Map;(()=>{u.adapters.set("keplr",new h);u.adapters.set("metamask",new d);u.adapters.set("phantom",new m);u.adapters.set("cosmostation",new f)})();const y=class{constructor(e){t(this,e);this.isInitialized=false;this.routePollingActive=false}async componentDidLoad(){await this.initialize()}disconnectedCallback(){this.stopRoutePolling()}async initialize(){console.log("🔄 Initializing Swap Controller...");c.onChange("fromToken",(()=>this.handleTokenChange()));c.onChange("toToken",(()=>this.handleTokenChange()));c.onChange("fromAmount",(()=>this.handleAmountChange()));this.isInitialized=true;console.log("✅ Swap Controller initialized")}handleTokenChange(){c.setRoutes([]);c.setSelectedRoute(undefined);this.stopRoutePolling();if(c.state.fromToken&&c.state.toToken&&c.state.fromAmount){this.startRoutePolling()}}handleAmountChange(){const{fromToken:t,toToken:e,fromAmount:s}=c.state;if(t&&e&&s&&parseFloat(s)>0){this.debounceRouteFetch()}else{this.stopRoutePolling();c.setRoutes([])}}debounceRouteFetch(){if(this.debounceTimeout){clearTimeout(this.debounceTimeout)}this.debounceTimeout=window.setTimeout((()=>{this.startRoutePolling()}),500)}startRoutePolling(){if(this.routePollingActive)return;console.log("🔄 Starting route polling...");this.routePollingActive=true;this.fetchRoutes();this.routePollingInterval=window.setInterval((()=>{this.fetchRoutes()}),n.ROUTE_REFRESH_INTERVAL)}stopRoutePolling(){if(!this.routePollingActive)return;console.log("⏹️ Stopping route polling...");this.routePollingActive=false;if(this.routePollingInterval){clearInterval(this.routePollingInterval)}}async fetchRoutes(){const{fromToken:t,toToken:e,fromAmount:n}=c.state;if(!t||!e||!n||parseFloat(n)<=0){return}try{c.setLoadingRoutes(true);console.log("🛣️ Fetching swap routes:",{from:t.symbol,to:e.symbol,amount:n});const a=await s.getRoutesWrapped({amount_in:n,token_in:t.id,token_out:e.id,external:true});if(a.success&&a.data){const t=a.data.paths||[];c.setRoutes(t);if(t.length>0&&!c.state.selectedRoute){c.setSelectedRoute(t[0])}console.log(`✅ Found ${t.length} swap routes`)}else{console.warn("⚠️ Failed to fetch routes:",a.error);c.setRoutes([])}}catch(t){console.error("❌ Error fetching routes:",t);c.setRoutes([])}finally{c.setLoadingRoutes(false)}}getUserAddressForChain(t){const e=o.getWallet(t);return e?.address}async executeSwap(){try{const{fromToken:t,toToken:e,fromAmount:n,selectedRoute:a,slippage:l}=c.state;if(!t||!e||!n||!a){return{success:false,error:"Missing required swap parameters"}}const u=o.getWallet(t.chainUID);if(!u?.isConnected){return{success:false,error:`Wallet not connected for ${t.chainUID}`}}if(!o.hasSufficientBalance(t.chainUID,t.id,n)){return{success:false,error:"Insufficient balance"}}c.setSwapping(true);console.log("🔄 Executing swap...",{from:t.symbol,to:e.symbol,amount:n,route:a.id});const h=p.getAdapter(u.type);if(!h){return{success:false,error:`Wallet adapter not found for ${u.type}`}}const d=await s.createSwapTransactionWrapped({amount_in:n,asset_in:{token:t.id,token_type:{native:{denom:t.id}}},slippage:l.toString(),minimum_receive:this.calculateMinimumReceived(a.outputAmount,l),sender:{address:u.address,chain_uid:t.chain_uid||t.chainUID},swap_path:{path:a.path||[]},timeout:(Math.floor(Date.now()/1e3)+1200).toString()});if(d.success&&d.data){const e=`swap_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;o.addTransaction(t.chainUID,{txHash:e,timestamp:Date.now(),type:"swap"});i(r.TRANSACTION.SUBMITTED,{txHash:e,chainUID:t.chainUID,type:"swap"});console.log("✅ Swap transaction submitted:",e);return{success:true,txHash:e}}else{return{success:false,error:d.error||"Swap execution failed"}}}catch(t){const e=t instanceof Error?t.message:"Unknown error occurred";console.error("❌ Swap execution error:",e);return{success:false,error:e}}finally{c.setSwapping(false)}}calculateMinimumReceived(t,e){try{const s=BigInt(t);const n=BigInt(Math.floor((100-e)*100));const a=s*n/BigInt(1e4);return a.toString()}catch{return t}}async handleSwapExecution(){console.log("🔄 Swap execution requested via event");const t=await this.executeSwap();if(t.success){i(r.SWAP.EXECUTE_SUCCESS,{txHash:t.txHash})}else{i(r.SWAP.EXECUTE_FAILED,{error:t.error})}}handleRouteRefresh(){console.log("🔄 Manual route refresh requested");this.fetchRoutes()}handleStopPolling(){this.stopRoutePolling()}handleStartPolling(){this.startRoutePolling()}onInitializedChange(t){if(t){console.log("📊 Swap Controller ready for route polling")}}render(){return null}static get watchers(){return{isInitialized:["onInitializedChange"]}}};const w=class{constructor(e){t(this,e);this.isInitialized=false;this.trackingTransactions=new Map}async componentDidLoad(){await this.initialize()}disconnectedCallback(){this.stopTracking()}async initialize(){console.log("🔍 Initializing Transaction Tracker Controller...");this.startTracking();this.isInitialized=true;console.log("✅ Transaction Tracker Controller initialized")}startTracking(){this.trackingInterval=window.setInterval((()=>{this.checkPendingTransactions()}),1e4)}stopTracking(){if(this.trackingInterval){clearInterval(this.trackingInterval)}}async trackTransaction(t,e,s){console.log("🔍 Starting to track transaction:",{txHash:t,chainUID:e,type:s});this.trackingTransactions.set(t,{chainUID:e,type:s,pollCount:0});await this.checkTransactionStatus(t,e,s)}async checkPendingTransactions(){const t=Array.from(this.trackingTransactions.entries()).map((([t,{chainUID:e,type:s,pollCount:n}])=>this.checkTransactionStatus(t,e,s,n)));await Promise.allSettled(t)}async checkTransactionStatus(t,e,n,a=0){try{console.log(`🔍 Checking transaction status: ${t}`);const c=await s.trackTransactionWrapped(t,e);if(c.success&&c.data){const{status:s}=c.data;o.updateTransactionStatus(e,t,s);if(s==="confirmed"||s==="failed"){this.trackingTransactions.delete(t);i(r.TRANSACTION.FINALIZED,{txHash:t,chainUID:e,type:n,status:s});console.log(`✅ Transaction finalized: ${t} - Status: ${s}`);if(s==="confirmed"){this.refreshUserDataAfterSuccess(e,n)}}else{const s=a+1;if(s>=120){console.warn(`⚠️ Transaction tracking timeout: ${t}`);this.trackingTransactions.delete(t);o.updateTransactionStatus(e,t,"failed");i(r.TRANSACTION.TIMEOUT,{txHash:t,chainUID:e,type:n})}else{this.trackingTransactions.set(t,{chainUID:e,type:n,pollCount:s})}}}else{console.warn(`⚠️ Failed to check transaction status: ${t}`,c.error)}}catch(e){console.error(`❌ Error checking transaction status: ${t}`,e)}}refreshUserDataAfterSuccess(t,e){i(r.USER.REFRESH_DATA);if(e==="add_liquidity"||e==="remove_liquidity"){i(r.LIQUIDITY.POSITIONS_REFRESH)}i(r.USER.BALANCES_REFRESH,{chainUID:t})}getTrackingStats(){const t={totalTracking:this.trackingTransactions.size,byType:{},byChain:{}};this.trackingTransactions.forEach((({chainUID:e,type:s})=>{t.byType[s]=(t.byType[s]||0)+1;t.byChain[e]=(t.byChain[e]||0)+1}));return t}async checkTransactionManually(t,e){try{const n=await s.trackTransactionWrapped(t,e);if(n.success&&n.data){return{success:true,status:n.data.status}}else{return{success:false,error:n.error||"Failed to check transaction status"}}}catch(t){return{success:false,error:t instanceof Error?t.message:"Unknown error"}}}async handleTransactionSubmitted(t){const{txHash:e,chainUID:s,type:n}=t.detail;console.log("🔍 Transaction submitted, starting tracking:",t.detail);await this.trackTransaction(e,s,n)}async handleTrackTransactionRequest(t){const{txHash:e,chainUID:s,type:n}=t.detail;console.log("🔍 Manual transaction tracking requested:",t.detail);await this.trackTransaction(e,s,n)}handleStopTrackingTransaction(t){const{txHash:e}=t.detail;console.log("⏹️ Stopping transaction tracking:",e);this.trackingTransactions.delete(e)}handleGetTrackingStats(){const t=this.getTrackingStats();i(r.TRANSACTION.STATS_RESPONSE,t)}onInitializedChange(t){if(t){console.log("🔍 Transaction Tracker Controller ready")}}render(){return null}static get watchers(){return{isInitialized:["onInitializedChange"]}}};const g=class{constructor(e){t(this,e);this.isInitialized=false;this.isLoading=false;this.error=null;this.retryCount=0;this.maxRetries=3}async componentDidLoad(){await this.initialize()}disconnectedCallback(){this.clearPeriodicRefresh();o.dispose?.()}async initialize(){console.log("👤 Initializing User Data Controller...");o.onChange("wallets",(async t=>{const e=Array.from(t.values()).filter((t=>t.isConnected));if(e.length>0){await this.handleWalletConnection(e)}else{this.handleWalletDisconnection()}}));const t=o.getAllConnectedWallets();if(t.length>0){await this.handleWalletConnection(t)}this.isInitialized=true;console.log("✅ User Data Controller initialized")}async handleWalletConnection(t){try{this.isLoading=true;this.error=null;console.log("🔗 Wallets connected, loading user data...");await Promise.all([this.loadUserBalances(),this.loadLiquidityPositions(),this.loadUserTransactions()]);this.setupPeriodicRefresh();this.retryCount=0}catch(t){console.error("❌ Failed to load user data:",t);await this.handleLoadError(t)}finally{this.isLoading=false}}handleWalletDisconnection(){console.log("🔌 Wallets disconnected, clearing user data...");this.clearPeriodicRefresh();this.retryCount=0;o.clear()}async loadUserBalances(){const t=o.getAllConnectedWallets();for(const e of t){try{console.log(`💰 Loading balances for ${e.chainUID}:${e.address.slice(0,8)}...`);const t=await s.getBalance(e.address,e.chainUID);if(t.success&&t.data){const s=t.data;if(s.balance?.all){const t=s.balance.all.map((t=>({amount:t.amount,token_id:t.denom,token:t.denom,balance:t.amount,chain_uid:e.chainUID,token_type:{native:{denom:t.denom}}})));o.updateWalletBalances(e.chainUID,t)}}}catch(t){console.warn(`⚠️ Failed to load balance for ${e.chainUID}:`,t.message)}}console.log(`✅ Updated balances for connected wallets`)}async loadLiquidityPositions(){const t=o.getAllConnectedWallets();for(const e of t){try{console.log(`🏊 Loading liquidity positions for ${e.chainUID}:${e.address.slice(0,8)}...`);console.log("Liquidity positions loading - implementation pending")}catch(t){console.warn(`⚠️ Failed to load liquidity positions for ${e.chainUID}:`,t.message)}}}async loadUserTransactions(){const t=o.getAllConnectedWallets();for(const e of t){try{console.log(`📊 Loading transactions for ${e.chainUID}:${e.address.slice(0,8)}...`);console.log("Transactions loading - implementation pending")}catch(t){console.warn(`⚠️ Failed to load transactions for ${e.chainUID}:`,t.message)}}}calculatePoolShare(t,e){try{const s=parseFloat(t);const n=parseFloat(String(e.totalSupply||e.liquidity||"0"));if(n===0)return 0;return s/n*100}catch{return 0}}calculateTokenAmount(t,e){try{const s=parseFloat(String(e.reserve||e.balance||"0"));const n=s*t/100;return n.toString()}catch{return"0"}}calculatePositionValue(t,e){try{const s=parseFloat(String(e.tvl||e.liquidity||"0"));const n=s*t/100;return n.toString()}catch{return"0"}}setupPeriodicRefresh(){this.clearPeriodicRefresh();this.refreshTimer=window.setInterval((async()=>{const t=o.getAllConnectedWallets();if(t.length>0){console.log("🔄 Refreshing wallet data...");await this.refreshUserData()}}),n.BALANCE_REFRESH_INTERVAL)}clearPeriodicRefresh(){if(this.refreshTimer){clearInterval(this.refreshTimer);this.refreshTimer=null}}async refreshUserData(){const t=o.getAllConnectedWallets();if(t.length===0)return;try{this.isLoading=true;await Promise.all([this.loadUserBalances(),this.loadLiquidityPositions()]);console.log("Portfolio value calculation - implementation pending");this.retryCount=0}catch(t){console.warn("⚠️ Failed to refresh user data:",t);await this.handleLoadError(t)}finally{this.isLoading=false}}async handleLoadError(t){this.retryCount++;if(this.retryCount<this.maxRetries){console.log(`🔄 Retrying user data load (${this.retryCount}/${this.maxRetries})...`);const t=Math.pow(2,this.retryCount)*1e3;setTimeout((()=>{this.refreshUserData()}),t)}else{console.error("❌ Max retries reached for user data loading");this.error=t.message||"Failed to load user data"}}async handleRefreshRequest(){console.log("🔄 Manual user data refresh requested");await this.refreshUserData()}handleClearRequest(){console.log("🗑️ User data clear requested");o.clear();this.clearPeriodicRefresh()}onInitializedChange(t){if(t){i(r.USER.CONTROLLER_READY,{timestamp:Date.now()})}}render(){return null}static get watchers(){return{isInitialized:["onInitializedChange"]}}};const k=class{constructor(e){t(this,e);this.isInitialized=false}async componentDidLoad(){await this.initialize()}async initialize(){console.log("🔗 Initializing Wallet Controller...");await this.detectAvailableWallets();this.setupWalletEventListeners();this.isInitialized=true;console.log("✅ Wallet Controller initialized")}async detectAvailableWallets(){const t=[];if(window.keplr){t.push("keplr")}if(window.ethereum?.isMetaMask){t.push("metamask")}if(window.cosmostation){t.push("cosmostation")}console.log("🔍 Available wallets detected:",t);return t}setupWalletEventListeners(){if(window.ethereum){const t=window.ethereum;if(t.on){t.on("accountsChanged",(t=>{console.log("MetaMask accounts changed:",t);this.handleEvmAccountChange(t)}));t.on("chainChanged",(t=>{console.log("MetaMask chain changed:",t);this.handleEvmChainChange(t)}))}}window.addEventListener("keplr_keystorechange",(()=>{console.log("Keplr keystore changed");this.handleKeplrKeystoreChange()}))}async handleEvmAccountChange(t){if(t.length===0){this.disconnectEvmWallets()}}handleEvmChainChange(t){console.log("Chain changed to:",t)}handleKeplrKeystoreChange(){}disconnectEvmWallets(){const t=["ethereum","bsc","polygon","arbitrum","base","manta","sepolia"];t.forEach((t=>{o.removeWallet(t)}))}async handleWalletConnectionRequest(t){const{chainUID:e,walletType:s}=t.detail;console.log("🔗 Wallet connection requested:",{chainUID:e,walletType:s});try{await this.connectWallet(e,s)}catch(t){console.error("Failed to connect wallet:",t);i(r.WALLET.CONNECT_FAILED,{chainUID:e,walletType:s,error:t.message})}}handleWalletDisconnectionRequest(t){const{chainUID:e}=t.detail;console.log("🔌 Wallet disconnection requested:",e);o.disconnectWallet(e);i(r.WALLET.DISCONNECT_SUCCESS,{chainUID:e})}async connectWallet(t,e){const s=a.getChain(t);if(!s){throw new Error(`Chain configuration not found for ${t}`)}const n=["keplr","metamask","cosmostation","walletconnect"];if(!n.includes(e)){throw new Error(`Unsupported wallet type: ${e}`)}const c=await p.connectWallet(e,s);if(c.success&&c.address){o.addWallet(t,{address:c.address,name:e,walletType:e,type:e,isConnected:true,balances:[]});i(r.WALLET.CONNECT_SUCCESS,{chainUID:t,walletType:e,address:c.address})}else{throw new Error(c.error||"Failed to connect wallet")}}render(){return null}};export{l as euclid_liquidity_controller,y as euclid_swap_controller,w as euclid_tx_tracker_controller,g as euclid_user_data_controller,k as euclid_wallet_controller};
//# sourceMappingURL=p-c68381e0.entry.js.map