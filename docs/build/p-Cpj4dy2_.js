import{a as t,f as n}from"./p-DQPEQJEF.js";const e=(t,n,e)=>{const a=t.get(n);if(!a){t.set(n,[e])}else if(!a.includes(e)){a.push(e)}};const a=(t,n)=>{let e;return(...a)=>{if(e){clearTimeout(e)}e=setTimeout((()=>{e=0;t(...a)}),n)}};const o=t=>!("isConnected"in t)||t.isConnected;const r=a((t=>{for(let n of t.keys()){t.set(n,t.get(n).filter(o))}}),2e3);const s=()=>{if(typeof t!=="function"){return{}}const a=new Map;return{dispose:()=>a.clear(),get:n=>{const o=t();if(o){e(a,n,o)}},set:t=>{const e=a.get(t);if(e){a.set(t,e.filter(n))}r(a)},reset:()=>{a.forEach((t=>t.forEach(n)));r(a)}}};const c=t=>typeof t==="function"?t():t;const i=(t,n=(t,n)=>t!==n)=>{const e=c(t);let a=new Map(Object.entries(e??{}));const o={dispose:[],get:[],set:[],reset:[]};const r=new Map;const s=()=>{a=new Map(Object.entries(c(t)??{}));o.reset.forEach((t=>t()))};const i=()=>{o.dispose.forEach((t=>t()));s()};const w=t=>{o.get.forEach((n=>n(t)));return a.get(t)};const d=(t,e)=>{const r=a.get(t);if(n(e,r,t)){a.set(t,e);o.set.forEach((n=>n(t,e,r)))}};const h=typeof Proxy==="undefined"?{}:new Proxy(e,{get(t,n){return w(n)},ownKeys(t){return Array.from(a.keys())},getOwnPropertyDescriptor(){return{enumerable:true,configurable:true}},has(t,n){return a.has(n)},set(t,n,e){d(n,e);return true}});const u=(t,n)=>{o[t].push(n);return()=>{l(o[t],n)}};const f=(n,e)=>{const a=(t,a)=>{if(t===n){e(a)}};const o=()=>e(c(t)[n]);const s=u("set",a);const i=u("reset",o);r.set(e,{setHandler:a,resetHandler:o,propName:n});return()=>{s();i();r.delete(e)}};const m=(...t)=>{const n=t.reduce(((t,n)=>{if(n.set){t.push(u("set",n.set))}if(n.get){t.push(u("get",n.get))}if(n.reset){t.push(u("reset",n.reset))}if(n.dispose){t.push(u("dispose",n.dispose))}return t}),[]);return()=>n.forEach((t=>t()))};const p=t=>{const n=a.get(t);o.set.forEach((e=>e(t,n,n)))};const y=(t,n)=>{const e=r.get(n);if(e&&e.propName===t){l(o.set,e.setHandler);l(o.reset,e.resetHandler);r.delete(n)}};return{state:h,get:w,set:d,on:u,onChange:f,use:m,dispose:i,reset:s,forceUpdate:p,removeListener:y}};const l=(t,n)=>{const e=t.indexOf(n);if(e>=0){t[e]=t[t.length-1];t.length--}};const w=(t,n)=>{const e=i(t,n);e.use(s());return e};class d{constructor(){this.type="metamask"}isAvailable(){return typeof window!=="undefined"&&Boolean(window.ethereum?.isMetaMask)}async connect(t){if(!this.isAvailable()){throw new Error("MetaMask is not installed")}try{const n=await window.ethereum.request({method:"eth_requestAccounts"});if(!n||n.length===0){throw new Error("No accounts found")}const e=await window.ethereum.request({method:"eth_chainId"});if(t&&t!==e){await this.switchChain(t)}return{address:n[0],chainId:t||e}}catch(t){throw new Error(`Failed to connect MetaMask: ${t.message}`)}}async disconnect(){console.log("MetaMask disconnect requested")}async getBalance(t){if(!this.isAvailable()){throw new Error("MetaMask is not available")}try{const n=await window.ethereum.request({method:"eth_getBalance",params:[t,"latest"]});return n}catch(t){throw new Error(`Failed to get balance: ${t.message}`)}}async signAndBroadcast(t){if(!this.isAvailable()){throw new Error("MetaMask is not available")}if(t.type!=="evm"){throw new Error("MetaMask can only handle EVM transactions")}try{const n=await window.ethereum.request({method:"eth_sendTransaction",params:t.msgs.map((n=>({from:t.sender.address,to:n.to,data:n.data,value:n.value,gasLimit:n.gasLimit})))});return n}catch(t){throw new Error(`Failed to send transaction: ${t.message}`)}}async switchChain(t){if(!this.isAvailable()){throw new Error("MetaMask is not available")}try{await window.ethereum.request({method:"wallet_switchEthereumChain",params:[{chainId:t}]})}catch(t){if(t.code===4902){throw new Error("Chain not added to MetaMask. Please add the chain first.")}throw new Error(`Failed to switch chain: ${t.message}`)}}async addChain(t){if(!this.isAvailable()){throw new Error("MetaMask is not available")}if(t.type!=="EVM"){throw new Error("MetaMask only supports EVM chains")}try{await window.ethereum.request({method:"wallet_addEthereumChain",params:[{chainId:t.chain_id,chainName:t.display_name,nativeCurrency:{name:"ETH",symbol:"ETH",decimals:18},rpcUrls:[t.explorer_url],blockExplorerUrls:[t.explorer_url]}]})}catch(t){throw new Error(`Failed to add chain: ${t.message}`)}}}class h{constructor(){this.type="keplr"}isAvailable(){return typeof window!=="undefined"&&Boolean(window.keplr)}async connect(t){if(!this.isAvailable()){throw new Error("Keplr is not installed")}try{const n=t||"cosmoshub-4";await window.keplr.enable(n);const e=window.keplr.getOfflineSigner(n);const a=await e.getAccounts();if(!a||a.length===0){throw new Error("No accounts found")}return{address:a[0].address,chainId:n}}catch(t){throw new Error(`Failed to connect Keplr: ${t.message}`)}}async disconnect(){console.log("Keplr disconnect requested")}async getBalance(t){throw new Error("Balance checking not implemented for Keplr")}async signAndBroadcast(t){if(!this.isAvailable()){throw new Error("Keplr is not available")}if(t.type!=="cosmwasm"){throw new Error("Keplr can only handle CosmWasm transactions")}try{throw new Error("CosmWasm transaction signing not fully implemented")}catch(t){throw new Error(`Failed to send transaction: ${t.message}`)}}async switchChain(t){if(!this.isAvailable()){throw new Error("Keplr is not available")}try{await window.keplr.enable(t)}catch(n){throw new Error(`Failed to switch to chain ${t}: ${n.message}`)}}async addChain(t){if(!this.isAvailable()){throw new Error("Keplr is not available")}if(t.type!=="Cosmwasm"){throw new Error("Keplr only supports Cosmos chains")}try{await window.keplr.experimentalSuggestChain({chainId:t.chain_id,chainName:t.display_name,rpc:t.explorer_url,rest:t.explorer_url,bip44:{coinType:118},bech32Config:{bech32PrefixAccAddr:"cosmos",bech32PrefixAccPub:"cosmospub",bech32PrefixValAddr:"cosmosvaloper",bech32PrefixValPub:"cosmosvaloperpub",bech32PrefixConsAddr:"cosmosvalcons",bech32PrefixConsPub:"cosmosvalconspub"},currencies:[{coinDenom:"ATOM",coinMinimalDenom:"uatom",coinDecimals:6}],feeCurrencies:[{coinDenom:"ATOM",coinMinimalDenom:"uatom",coinDecimals:6}],stakeCurrency:{coinDenom:"ATOM",coinMinimalDenom:"uatom",coinDecimals:6}})}catch(t){throw new Error(`Failed to add chain: ${t.message}`)}}}class u{constructor(){this.type="phantom"}isAvailable(){return typeof window!=="undefined"&&Boolean(window.solana?.isPhantom)}async connect(t){if(!this.isAvailable()){throw new Error("Phantom is not installed")}try{const n=await window.solana.connect();return{address:n.publicKey.toString(),chainId:t||"mainnet-beta"}}catch(t){throw new Error(`Failed to connect Phantom: ${t.message}`)}}async disconnect(){if(this.isAvailable()){await window.solana.disconnect()}}async getBalance(t){throw new Error("Balance checking not implemented for Phantom")}async signAndBroadcast(t){throw new Error("Solana transaction signing not implemented")}async switchChain(t){console.log(`Chain switching not supported by Phantom: ${t}`)}async addChain(t){throw new Error("Adding chains not supported by Phantom")}}class f{constructor(){this.adapters=new Map;this.adapters.set("metamask",new d);this.adapters.set("keplr",new h);this.adapters.set("phantom",new u)}getAdapter(t){const n=this.adapters.get(t);if(!n){throw new Error(`Unsupported wallet type: ${t}`)}return n}getAvailableAdapters(){return Array.from(this.adapters.values()).filter((t=>t.isAvailable()))}getAvailableWalletTypes(){return this.getAvailableAdapters().map((t=>t.type))}}const m=new f;const p={isConnected:false,address:null,chainId:null,chainUID:null,walletType:null,balances:[],loading:false,error:null,connectedWallets:new Map,wallets:new Map};const{state:y,onChange:E,reset:g,dispose:b}=w(p);const M={setLoading(t){y.loading=t},setError(t){y.error=t},async connectWallet(t,n){y.loading=true;y.error=null;try{const e=m.getAdapter(t);if(!e.isAvailable()){throw new Error(`${t} wallet is not installed`)}const a=await e.connect(n);y.isConnected=true;y.address=a.address;y.chainId=a.chainId;y.chainUID=a.chainId;y.walletType=t;y.error=null}catch(t){y.error=t instanceof Error?t.message:"Failed to connect wallet"}finally{y.loading=false}},async disconnectWallet(t){if(t){M.removeWallet(t)}else{if(y.walletType){try{const t=m.getAdapter(y.walletType);await t.disconnect()}catch(t){console.warn("Error disconnecting wallet:",t)}}y.isConnected=false;y.address=null;y.chainId=null;y.chainUID=null;y.walletType=null;y.balances=[];y.connectedWallets.clear();y.error=null}},setBalances(t){y.balances=[...t]},updateBalance(t,n){const e=y.balances.findIndex((n=>n.token===t));const a={amount:n,token_id:t,token:t,balance:n,chain_uid:y.chainUID||"",token_type:{native:{denom:t}}};if(e>=0){y.balances[e]=a}else{y.balances.push(a)}},async switchChain(t){if(!y.walletType){throw new Error("No wallet connected")}y.loading=true;y.error=null;try{const n=m.getAdapter(y.walletType);await n.switchChain(t);y.chainId=t;y.chainUID=t;y.error=null}catch(t){y.error=t instanceof Error?t.message:"Failed to switch chain"}finally{y.loading=false}},clear(){g()},initialize(){console.log("Wallet store initialized")},addWallet(t,n){const e={...n,chainUID:t,type:n.walletType,name:n.walletType};y.connectedWallets.set(t,e);y.wallets.set(t,e);if(!y.isConnected){y.isConnected=true;y.address=n.address;y.chainUID=t;y.walletType=n.walletType;y.balances=[...n.balances]}},removeWallet(t){y.connectedWallets.delete(t);y.wallets.delete(t);if(y.chainUID===t){const t=Array.from(y.connectedWallets.values());if(t.length>0){const n=t[0];y.address=n.address;y.chainUID=n.chainUID;y.walletType=n.walletType;y.balances=[...n.balances]}else{y.isConnected=false;y.address=null;y.chainUID=null;y.walletType=null;y.balances=[]}}},updateWalletBalances(t,n){const e=y.connectedWallets.get(t);if(e){const a={...e,balances:[...n]};y.connectedWallets.set(t,a);if(y.chainUID===t){y.balances=[...n]}}}};const C={getBalance:t=>y.balances.find((n=>n.token===t)),getFormattedBalance:(t,n=18)=>{const e=C.getBalance(t);if(!e)return"0";try{const t=BigInt(e.balance);const a=BigInt(10**n);const o=t/a;const r=t%a;return`${o.toString()}.${r.toString().padStart(n,"0")}`}catch{return"0"}},hasSufficientBalance:(t,n,e)=>{if(typeof e==="string"&&n&&e){const a=t;const o=n;const r=e;const s=y.connectedWallets.get(a);if(!s)return false;const c=s.balances.find((t=>t.token===o));if(!c)return false;try{return BigInt(c.balance)>=BigInt(r)}catch{return false}}else{const e=t;const a=n||"";const o=C.getBalance(e);if(!o)return false;try{return BigInt(o.balance)>=BigInt(a)}catch{return false}}},isWalletAvailable:t=>{try{const n=m.getAdapter(t);return n.isAvailable()}catch{return false}},getAvailableWallets:()=>m.getAvailableWalletTypes(),isWalletConnected:t=>{const n=y.connectedWallets.get(t);return n?n.isConnected:false},getAllConnectedWallets:()=>Array.from(y.connectedWallets.values()).filter((t=>t.isConnected)),getWalletBalance:(t,n)=>{const e=y.connectedWallets.get(t);if(!e)return null;return e.balances.find((t=>t.token===n||t.token.toLowerCase()===n.toLowerCase()))},getWallet:t=>y.connectedWallets.get(t)||null,addTransaction:(t,n)=>{console.log(`Transaction added for ${t}:`,n)},updateTransactionStatus:(t,n,e)=>{console.log(`Transaction ${n} on ${t} updated to status: ${e}`)}};const A={state:y,onChange:E,reset:g,dispose:b,...M,...C};export{w as c,A as w};
//# sourceMappingURL=p-Cpj4dy2_.js.map