import{a as e,f as t}from"./p-uEsOKkhe.js";const s=(e,t,s)=>{const n=e.get(t);if(!n){e.set(t,[s])}else if(!n.includes(s)){n.push(s)}};const n=(e,t)=>{let s;return(...n)=>{if(s){clearTimeout(s)}s=setTimeout((()=>{s=0;e(...n)}),t)}};const o=e=>!("isConnected"in e)||e.isConnected;const r=n((e=>{for(let t of e.keys()){e.set(t,e.get(t).filter(o))}}),2e3);const a=()=>{if(typeof e!=="function"){return{}}const n=new Map;return{dispose:()=>n.clear(),get:t=>{const o=e();if(o){s(n,t,o)}},set:e=>{const s=n.get(e);if(s){n.set(e,s.filter(t))}r(n)},reset:()=>{n.forEach((e=>e.forEach(t)));r(n)}}};const i=e=>typeof e==="function"?e():e;const c=(e,t=(e,t)=>e!==t)=>{const s=i(e);let n=new Map(Object.entries(s??{}));const o={dispose:[],get:[],set:[],reset:[]};const r=new Map;const a=()=>{n=new Map(Object.entries(i(e)??{}));o.reset.forEach((e=>e()))};const c=()=>{o.dispose.forEach((e=>e()));a()};const d=e=>{o.get.forEach((t=>t(e)));return n.get(e)};const l=(e,s)=>{const r=n.get(e);if(t(s,r,e)){n.set(e,s);o.set.forEach((t=>t(e,s,r)))}};const f=typeof Proxy==="undefined"?{}:new Proxy(s,{get(e,t){return d(t)},ownKeys(e){return Array.from(n.keys())},getOwnPropertyDescriptor(){return{enumerable:true,configurable:true}},has(e,t){return n.has(t)},set(e,t,s){l(t,s);return true}});const p=(e,t)=>{o[e].push(t);return()=>{u(o[e],t)}};const h=(t,s)=>{const n=(e,n)=>{if(e===t){s(n)}};const o=()=>s(i(e)[t]);const a=p("set",n);const c=p("reset",o);r.set(s,{setHandler:n,resetHandler:o,propName:t});return()=>{a();c();r.delete(s)}};const g=(...e)=>{const t=e.reduce(((e,t)=>{if(t.set){e.push(p("set",t.set))}if(t.get){e.push(p("get",t.get))}if(t.reset){e.push(p("reset",t.reset))}if(t.dispose){e.push(p("dispose",t.dispose))}return e}),[]);return()=>t.forEach((e=>e()))};const y=e=>{const t=n.get(e);o.set.forEach((s=>s(e,t,t)))};const m=(e,t)=>{const s=r.get(t);if(s&&s.propName===e){u(o.set,s.setHandler);u(o.reset,s.resetHandler);r.delete(t)}};return{state:f,get:d,set:l,on:p,onChange:h,use:g,dispose:c,reset:a,forceUpdate:y,removeListener:m}};const u=(e,t)=>{const s=e.indexOf(t);if(s>=0){e[s]=e[e.length-1];e.length--}};const d=(e,t)=>{const s=c(e,t);s.use(a());return s};class l{constructor(){this.pendingUpdates=new Map;this.stateSnapshots=new Map}deepEquals(e,t){if(e===t)return true;if(e===null||t===null||e===undefined||t===undefined){return e===t}if(typeof e!==typeof t)return false;if(typeof e==="object"){if(Array.isArray(e)!==Array.isArray(t))return false;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return false;return e.every(((e,s)=>this.deepEquals(e,t[s])))}const s=Object.keys(e);const n=Object.keys(t);if(s.length!==n.length)return false;return s.every((s=>n.includes(s)&&this.deepEquals(e[s],t[s])))}return false}createChecksum(e){try{const t=JSON.stringify(e,Object.keys(e).sort());let s=0;for(let e=0;e<t.length;e++){const n=t.charCodeAt(e);s=(s<<5)-s+n;s=s&s}return s.toString(36)}catch{return Math.random().toString(36)}}detectChanges(e,t,s){const n=this.stateSnapshots.get(e)||{};const o={};const r=new Set(s.skipFields||[]);for(const[e,a]of Object.entries(t)){if(r.has(e))continue;const t=n[e];const i=s.deepCompare?!this.deepEquals(t,a):t!==a;o[e]={oldValue:t,newValue:a,hasChanged:i}}return o}shouldUpdate(e,t){if(t.forceUpdate)return true;return Object.values(e).some((e=>e.hasChanged))}scheduleUpdate(e,t,s,n={}){const o=this.pendingUpdates.get(e);if(o){clearTimeout(o.timer)}const r={debounceMs:100,deepCompare:true,skipFields:["loading","error","lastUpdated"],...n};if(r.debounceMs===0){this.executeUpdate(e,t,s,r);return}const a=window.setTimeout((()=>{this.executeUpdate(e,t,s,r);this.pendingUpdates.delete(e)}),r.debounceMs);this.pendingUpdates.set(e,{timer:a,updateFn:s,options:r})}executeUpdate(e,t,s,n){const o=t();const r=this.detectChanges(e,o,n);if(this.shouldUpdate(r,n)){console.log(`🔄 Store update [${e}]:`,{changedFields:Object.keys(r).filter((e=>r[e].hasChanged)),totalFields:Object.keys(r).length});s();this.stateSnapshots.set(e,{...o})}else{console.log(`⏭️ Store update skipped [${e}]: No significant changes detected`)}}forceUpdate(e,t,s){this.executeUpdate(e,t,s,{forceUpdate:true})}clearPendingUpdates(e){const t=this.pendingUpdates.get(e);if(t){clearTimeout(t.timer);this.pendingUpdates.delete(e)}}clearAllPendingUpdates(){for(const[e]of this.pendingUpdates){this.clearPendingUpdates(e)}}getPendingUpdates(){return Array.from(this.pendingUpdates.keys())}destroy(){this.clearAllPendingUpdates();this.stateSnapshots.clear()}}const f=new l;function p(e,t,s={}){return{...e,smartUpdate:(n,o)=>{const r={...s,...o};f.scheduleUpdate(t,(()=>e.state),(()=>{Object.assign(e.state,n)}),r)},smartSetField:(n,o,r)=>{const a={...s,...r};f.scheduleUpdate(t,(()=>e.state),(()=>{e.state[n]=o}),a)}}}const h={chains:[],tokens:[],pools:[],prices:{},loading:false,error:null,lastUpdated:0,lastChainsUpdate:0,lastTokensUpdate:0};const{state:g,onChange:y,reset:m,dispose:k}=d(h);const w=p({state:g,onChange:y},"market-store",{debounceMs:150,deepCompare:true,skipFields:["loading","error"]});const b={setLoading(e){g.loading=e},setError(e){g.error=e},setChains(e){g.chains=[...e];g.lastChainsUpdate=Date.now();g.lastUpdated=Date.now()},setTokens(e){g.tokens=[...e];g.lastTokensUpdate=Date.now();g.lastUpdated=Date.now()},setPools(e){g.pools=[...e];g.lastUpdated=Date.now()},setPrices(e){g.prices={...e};g.lastUpdated=Date.now()},updateChainsSmartly(e){w.smartUpdate({chains:[...e],lastUpdated:Date.now()})},updateTokensSmartly(e){w.smartUpdate({tokens:[...e],lastUpdated:Date.now()})},updatePoolsSmartly(e){w.smartUpdate({pools:[...e],lastUpdated:Date.now()})},addToken(e){w.smartUpdate({tokens:[...g.tokens,e]},{debounceMs:0})},updateToken(e,t){w.smartUpdate({tokens:g.tokens.map((s=>s.id===e?{...s,...t}:s))},{debounceMs:0})},clear(){m()}};const U={getChain:e=>g.chains.find((t=>t.chain_uid===e)),getToken:e=>g.tokens.find((t=>t.id===e)),getTokensByChain:e=>g.tokens.filter((t=>t.chain_uid===e)),getPool:e=>g.pools.find((t=>t.pool_id===e)),getPoolsForTokenPair:(e,t)=>g.pools.filter((s=>s.token_1===e&&s.token_2===t||s.token_1===t&&s.token_2===e)),getPrice:e=>g.prices[e]||0,isDataStale:(e=5*60*1e3)=>{if(!g.lastUpdated)return true;return Date.now()-g.lastUpdated>e},isChainsStale:(e=5*60*1e3)=>{if(!g.lastChainsUpdate)return true;return Date.now()-g.lastChainsUpdate>e},isTokensStale:(e=5*60*1e3)=>{if(!g.lastTokensUpdate)return true;return Date.now()-g.lastTokensUpdate>e}};const C={state:g,onChange:y,reset:m,dispose:k,...b,...U};if(typeof window!=="undefined"){window.marketStore=C}export{d as c,C as m,p as w};
//# sourceMappingURL=p-DWrf3bWA.js.map