import{c as n}from"./p-CHLqsENg.js";class t{constructor(){this.type="metamask"}isAvailable(){return typeof window!=="undefined"&&Boolean(window.ethereum?.isMetaMask)}async connect(n){if(!this.isAvailable()){throw new Error("MetaMask is not installed")}try{const t=await window.ethereum.request({method:"eth_requestAccounts"});if(!t||t.length===0){throw new Error("No accounts found")}const a=await window.ethereum.request({method:"eth_chainId"});if(n&&n!==a){await this.switchChain(n)}return{address:t[0],chainId:n||a}}catch(n){throw new Error(`Failed to connect MetaMask: ${n.message}`)}}async disconnect(){console.log("MetaMask disconnect requested")}async getBalance(n){if(!this.isAvailable()){throw new Error("MetaMask is not available")}try{const t=await window.ethereum.request({method:"eth_getBalance",params:[n,"latest"]});return t}catch(n){throw new Error(`Failed to get balance: ${n.message}`)}}async signAndBroadcast(n){if(!this.isAvailable()){throw new Error("MetaMask is not available")}if(n.type!=="evm"){throw new Error("MetaMask can only handle EVM transactions")}try{const t=await window.ethereum.request({method:"eth_sendTransaction",params:n.msgs.map((t=>({from:n.sender.address,to:t.to,data:t.data,value:t.value,gasLimit:t.gasLimit})))});return t}catch(n){throw new Error(`Failed to send transaction: ${n.message}`)}}async switchChain(n){if(!this.isAvailable()){throw new Error("MetaMask is not available")}try{await window.ethereum.request({method:"wallet_switchEthereumChain",params:[{chainId:n}]})}catch(n){if(n.code===4902){throw new Error("Chain not added to MetaMask. Please add the chain first.")}throw new Error(`Failed to switch chain: ${n.message}`)}}async addChain(n){if(!this.isAvailable()){throw new Error("MetaMask is not available")}if(n.type!=="EVM"){throw new Error("MetaMask only supports EVM chains")}try{await window.ethereum.request({method:"wallet_addEthereumChain",params:[{chainId:n.chain_id,chainName:n.display_name,nativeCurrency:{name:"ETH",symbol:"ETH",decimals:18},rpcUrls:[n.explorer_url],blockExplorerUrls:[n.explorer_url]}]})}catch(n){throw new Error(`Failed to add chain: ${n.message}`)}}}class a{constructor(){this.type="keplr"}isAvailable(){return typeof window!=="undefined"&&Boolean(window.keplr)}async connect(n){if(!this.isAvailable()){throw new Error("Keplr is not installed")}try{const t=n||"cosmoshub-4";await window.keplr.enable(t);const a=window.keplr.getOfflineSigner(t);const e=await a.getAccounts();if(!e||e.length===0){throw new Error("No accounts found")}return{address:e[0].address,chainId:t}}catch(n){throw new Error(`Failed to connect Keplr: ${n.message}`)}}async disconnect(){console.log("Keplr disconnect requested")}async getBalance(n){throw new Error("Balance checking not implemented for Keplr")}async signAndBroadcast(n){if(!this.isAvailable()){throw new Error("Keplr is not available")}if(n.type!=="cosmwasm"){throw new Error("Keplr can only handle CosmWasm transactions")}try{throw new Error("CosmWasm transaction signing not fully implemented")}catch(n){throw new Error(`Failed to send transaction: ${n.message}`)}}async switchChain(n){if(!this.isAvailable()){throw new Error("Keplr is not available")}try{await window.keplr.enable(n)}catch(t){throw new Error(`Failed to switch to chain ${n}: ${t.message}`)}}async addChain(n){if(!this.isAvailable()){throw new Error("Keplr is not available")}if(n.type!=="Cosmwasm"){throw new Error("Keplr only supports Cosmos chains")}try{await window.keplr.experimentalSuggestChain({chainId:n.chain_id,chainName:n.display_name,rpc:n.explorer_url,rest:n.explorer_url,bip44:{coinType:118},bech32Config:{bech32PrefixAccAddr:"cosmos",bech32PrefixAccPub:"cosmospub",bech32PrefixValAddr:"cosmosvaloper",bech32PrefixValPub:"cosmosvaloperpub",bech32PrefixConsAddr:"cosmosvalcons",bech32PrefixConsPub:"cosmosvalconspub"},currencies:[{coinDenom:"ATOM",coinMinimalDenom:"uatom",coinDecimals:6}],feeCurrencies:[{coinDenom:"ATOM",coinMinimalDenom:"uatom",coinDecimals:6}],stakeCurrency:{coinDenom:"ATOM",coinMinimalDenom:"uatom",coinDecimals:6}})}catch(n){throw new Error(`Failed to add chain: ${n.message}`)}}}class e{constructor(){this.type="phantom"}isAvailable(){return typeof window!=="undefined"&&Boolean(window.solana?.isPhantom)}async connect(n){if(!this.isAvailable()){throw new Error("Phantom is not installed")}try{const t=await window.solana.connect();return{address:t.publicKey.toString(),chainId:n||"mainnet-beta"}}catch(n){throw new Error(`Failed to connect Phantom: ${n.message}`)}}async disconnect(){if(this.isAvailable()){await window.solana.disconnect()}}async getBalance(n){throw new Error("Balance checking not implemented for Phantom")}async signAndBroadcast(n){throw new Error("Solana transaction signing not implemented")}async switchChain(n){console.log(`Chain switching not supported by Phantom: ${n}`)}async addChain(n){throw new Error("Adding chains not supported by Phantom")}}class o{constructor(){this.adapters=new Map;this.adapters.set("metamask",new t);this.adapters.set("keplr",new a);this.adapters.set("phantom",new e)}getAdapter(n){const t=this.adapters.get(n);if(!t){throw new Error(`Unsupported wallet type: ${n}`)}return t}getAvailableAdapters(){return Array.from(this.adapters.values()).filter((n=>n.isAvailable()))}getAvailableWalletTypes(){return this.getAvailableAdapters().map((n=>n.type))}}const r=new o;const s={isConnected:false,address:null,chainId:null,chainUID:null,walletType:null,balances:[],loading:false,error:null,connectedWallets:new Map,wallets:new Map};const{state:i,onChange:c,reset:l,dispose:h}=n(s);const w={setLoading(n){i.loading=n},setError(n){i.error=n},async connectWallet(n,t){i.loading=true;i.error=null;try{const a=r.getAdapter(n);if(!a.isAvailable()){throw new Error(`${n} wallet is not installed`)}const e=await a.connect(t);i.isConnected=true;i.address=e.address;i.chainId=e.chainId;i.chainUID=e.chainId;i.walletType=n;i.error=null}catch(n){i.error=n instanceof Error?n.message:"Failed to connect wallet"}finally{i.loading=false}},async disconnectWallet(n){if(n){w.removeWallet(n)}else{if(i.walletType){try{const n=r.getAdapter(i.walletType);await n.disconnect()}catch(n){console.warn("Error disconnecting wallet:",n)}}i.isConnected=false;i.address=null;i.chainId=null;i.chainUID=null;i.walletType=null;i.balances=[];i.connectedWallets.clear();i.error=null}},setBalances(n){i.balances=[...n]},updateBalance(n,t){const a=i.balances.findIndex((t=>t.token===n));const e={amount:t,token_id:n,token:n,balance:t,chain_uid:i.chainUID||"",token_type:{native:{denom:n}}};if(a>=0){i.balances[a]=e}else{i.balances.push(e)}},async switchChain(n){if(!i.walletType){throw new Error("No wallet connected")}i.loading=true;i.error=null;try{const t=r.getAdapter(i.walletType);await t.switchChain(n);i.chainId=n;i.chainUID=n;i.error=null}catch(n){i.error=n instanceof Error?n.message:"Failed to switch chain"}finally{i.loading=false}},clear(){l()},initialize(){console.log("Wallet store initialized")},addWallet(n,t){const a={...t,chainUID:n,type:t.walletType,name:t.walletType};i.connectedWallets.set(n,a);i.wallets.set(n,a);if(!i.isConnected){i.isConnected=true;i.address=t.address;i.chainUID=n;i.walletType=t.walletType;i.balances=[...t.balances]}},removeWallet(n){i.connectedWallets.delete(n);i.wallets.delete(n);if(i.chainUID===n){const n=Array.from(i.connectedWallets.values());if(n.length>0){const t=n[0];i.address=t.address;i.chainUID=t.chainUID;i.walletType=t.walletType;i.balances=[...t.balances]}else{i.isConnected=false;i.address=null;i.chainUID=null;i.walletType=null;i.balances=[]}}},updateWalletBalances(n,t){const a=i.connectedWallets.get(n);if(a){const e={...a,balances:[...t]};i.connectedWallets.set(n,e);if(i.chainUID===n){i.balances=[...t]}}}};const d={getBalance:n=>i.balances.find((t=>t.token===n)),getFormattedBalance:(n,t=18)=>{const a=d.getBalance(n);if(!a)return"0";try{const n=BigInt(a.balance);const e=BigInt(10**t);const o=n/e;const r=n%e;return`${o.toString()}.${r.toString().padStart(t,"0")}`}catch{return"0"}},hasSufficientBalance:(n,t,a)=>{if(typeof a==="string"&&t&&a){const e=n;const o=t;const r=a;const s=i.connectedWallets.get(e);if(!s)return false;const c=s.balances.find((n=>n.token===o));if(!c)return false;try{return BigInt(c.balance)>=BigInt(r)}catch{return false}}else{const a=n;const e=t||"";const o=d.getBalance(a);if(!o)return false;try{return BigInt(o.balance)>=BigInt(e)}catch{return false}}},isWalletAvailable:n=>{try{const t=r.getAdapter(n);return t.isAvailable()}catch{return false}},getAvailableWallets:()=>r.getAvailableWalletTypes(),isWalletConnected:n=>{const t=i.connectedWallets.get(n);return t?t.isConnected:false},getAllConnectedWallets:()=>Array.from(i.connectedWallets.values()).filter((n=>n.isConnected)),getWalletBalance:(n,t)=>{const a=i.connectedWallets.get(n);if(!a)return null;return a.balances.find((n=>n.token===t||n.token.toLowerCase()===t.toLowerCase()))},getWallet:n=>i.connectedWallets.get(n)||null,addTransaction:(n,t)=>{console.log(`Transaction added for ${n}:`,t)},updateTransactionStatus:(n,t,a)=>{console.log(`Transaction ${t} on ${n} updated to status: ${a}`)}};const u={state:i,onChange:c,reset:l,dispose:h,...w,...d};export{u as w};
//# sourceMappingURL=p-B5JcU1Ey.js.map