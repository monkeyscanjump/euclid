import{c as t,w as e}from"./p-BZ6fXqkj.js";class n{constructor(){this.type="metamask"}isAvailable(){return typeof window!=="undefined"&&Boolean(window.ethereum?.isMetaMask)}async connect(t){if(!this.isAvailable()){throw new Error("MetaMask is not installed")}try{const e=await window.ethereum.request({method:"eth_requestAccounts"});if(!e||e.length===0){throw new Error("No accounts found")}const n=await window.ethereum.request({method:"eth_chainId"});if(t&&t!==n){await this.switchChain(t)}return{address:e[0],chainId:t||n}}catch(t){throw new Error(`Failed to connect MetaMask: ${t.message}`)}}async disconnect(){console.log("MetaMask disconnect requested")}async getBalance(t){if(!this.isAvailable()){throw new Error("MetaMask is not available")}try{const e=await window.ethereum.request({method:"eth_getBalance",params:[t,"latest"]});return e}catch(t){throw new Error(`Failed to get balance: ${t.message}`)}}async signAndBroadcast(t){if(!this.isAvailable()){throw new Error("MetaMask is not available")}if(t.type!=="evm"){throw new Error("MetaMask can only handle EVM transactions")}try{const e=await window.ethereum.request({method:"eth_sendTransaction",params:t.msgs.map((e=>({from:t.sender.address,to:e.to,data:e.data,value:e.value,gasLimit:e.gasLimit})))});return e}catch(t){throw new Error(`Failed to send transaction: ${t.message}`)}}async switchChain(t){if(!this.isAvailable()){throw new Error("MetaMask is not available")}try{await window.ethereum.request({method:"wallet_switchEthereumChain",params:[{chainId:t}]})}catch(t){if(t.code===4902){throw new Error("Chain not added to MetaMask. Please add the chain first.")}throw new Error(`Failed to switch chain: ${t.message}`)}}async addChain(t){if(!this.isAvailable()){throw new Error("MetaMask is not available")}if(t.type!=="EVM"){throw new Error("MetaMask only supports EVM chains")}try{await window.ethereum.request({method:"wallet_addEthereumChain",params:[{chainId:t.chain_id,chainName:t.display_name,nativeCurrency:{name:"ETH",symbol:"ETH",decimals:18},rpcUrls:[t.explorer_url],blockExplorerUrls:[t.explorer_url]}]})}catch(t){throw new Error(`Failed to add chain: ${t.message}`)}}}class a{constructor(){this.type="keplr"}isAvailable(){return typeof window!=="undefined"&&Boolean(window.keplr)}async connect(t){if(!this.isAvailable()){throw new Error("Keplr is not installed")}try{const e=t||"cosmoshub-4";await window.keplr.enable(e);const n=window.keplr.getOfflineSigner(e);const a=await n.getAccounts();if(!a||a.length===0){throw new Error("No accounts found")}return{address:a[0].address,chainId:e}}catch(t){throw new Error(`Failed to connect Keplr: ${t.message}`)}}async disconnect(){console.log("Keplr disconnect requested")}async getBalance(t){throw new Error("Balance checking not implemented for Keplr")}async signAndBroadcast(t){if(!this.isAvailable()){throw new Error("Keplr is not available")}if(t.type!=="cosmwasm"){throw new Error("Keplr can only handle CosmWasm transactions")}try{throw new Error("CosmWasm transaction signing not fully implemented")}catch(t){throw new Error(`Failed to send transaction: ${t.message}`)}}async switchChain(t){if(!this.isAvailable()){throw new Error("Keplr is not available")}try{await window.keplr.enable(t)}catch(e){throw new Error(`Failed to switch to chain ${t}: ${e.message}`)}}async addChain(t){if(!this.isAvailable()){throw new Error("Keplr is not available")}if(t.type!=="Cosmwasm"){throw new Error("Keplr only supports Cosmos chains")}try{await window.keplr.experimentalSuggestChain({chainId:t.chain_id,chainName:t.display_name,rpc:t.explorer_url,rest:t.explorer_url,bip44:{coinType:118},bech32Config:{bech32PrefixAccAddr:"cosmos",bech32PrefixAccPub:"cosmospub",bech32PrefixValAddr:"cosmosvaloper",bech32PrefixValPub:"cosmosvaloperpub",bech32PrefixConsAddr:"cosmosvalcons",bech32PrefixConsPub:"cosmosvalconspub"},currencies:[{coinDenom:"ATOM",coinMinimalDenom:"uatom",coinDecimals:6}],feeCurrencies:[{coinDenom:"ATOM",coinMinimalDenom:"uatom",coinDecimals:6}],stakeCurrency:{coinDenom:"ATOM",coinMinimalDenom:"uatom",coinDecimals:6}})}catch(t){throw new Error(`Failed to add chain: ${t.message}`)}}}class s{constructor(){this.type="phantom"}isAvailable(){return typeof window!=="undefined"&&Boolean(window.solana?.isPhantom)}async connect(t){if(!this.isAvailable()){throw new Error("Phantom is not installed")}try{const e=await window.solana.connect();return{address:e.publicKey.toString(),chainId:t||"mainnet-beta"}}catch(t){throw new Error(`Failed to connect Phantom: ${t.message}`)}}async disconnect(){if(this.isAvailable()){await window.solana.disconnect()}}async getBalance(t){throw new Error("Balance checking not implemented for Phantom")}async signAndBroadcast(t){throw new Error("Solana transaction signing not implemented")}async switchChain(t){console.log(`Chain switching not supported by Phantom: ${t}`)}async addChain(t){throw new Error("Adding chains not supported by Phantom")}}class o{constructor(){this.adapters=new Map;this.adapters.set("metamask",new n);this.adapters.set("keplr",new a);this.adapters.set("phantom",new s)}getAdapter(t){const e=this.adapters.get(t);if(!e){throw new Error(`Unsupported wallet type: ${t}`)}return e}getAvailableAdapters(){return Array.from(this.adapters.values()).filter((t=>t.isAvailable()))}getAvailableWalletTypes(){return this.getAvailableAdapters().map((t=>t.type))}}const r=new o;class i{constructor(t="euclid-storage",e={}){this.db=null;this.cryptoKey=null;this.initPromise=null;this.dbName=t;this.version=e.version||1}async init(){if(this.initPromise){return this.initPromise}this.initPromise=this._init();return this.initPromise}async _init(){await Promise.all([this.initDatabase(),this.initCrypto()])}async initDatabase(){return new Promise(((t,e)=>{const n=indexedDB.open(this.dbName,this.version);n.onerror=()=>{e(new Error(`Failed to open database: ${n.error?.message}`))};n.onsuccess=()=>{this.db=n.result;t()};n.onupgradeneeded=t=>{const e=t.target.result;const n=["wallet-data","user-preferences","app-state","cache"];for(const t of n){if(!e.objectStoreNames.contains(t)){const n=e.createObjectStore(t,{keyPath:"key"});n.createIndex("timestamp","timestamp",{unique:false})}}}}))}async initCrypto(){if(!window.crypto?.subtle){console.warn("Web Crypto API not available - storage will not be encrypted");return}try{const t=await this.getStoredCryptoKey();if(!t){this.cryptoKey=await window.crypto.subtle.generateKey({name:"AES-GCM",length:256},true,["encrypt","decrypt"]);await this.storeCryptoKey(this.cryptoKey)}else{this.cryptoKey=await window.crypto.subtle.importKey("jwk",t,{name:"AES-GCM"},true,["encrypt","decrypt"])}}catch(t){console.warn("Failed to initialize encryption:",t)}}async getStoredCryptoKey(){try{const t=localStorage.getItem("euclid-crypto-key");return t?JSON.parse(t):null}catch{return null}}async storeCryptoKey(t){try{const e=await window.crypto.subtle.exportKey("jwk",t);localStorage.setItem("euclid-crypto-key",JSON.stringify(e))}catch(t){console.warn("Failed to store crypto key:",t)}}async encrypt(t){if(!this.cryptoKey||!window.crypto?.subtle){throw new Error("Encryption not available")}const e=window.crypto.getRandomValues(new Uint8Array(12));const n=(new TextEncoder).encode(JSON.stringify(t));const a=await window.crypto.subtle.encrypt({name:"AES-GCM",iv:e.buffer},this.cryptoKey,n);return{encrypted:a,iv:e}}async decrypt(t,e){if(!this.cryptoKey||!window.crypto?.subtle){throw new Error("Decryption not available")}const n=await window.crypto.subtle.decrypt({name:"AES-GCM",iv:e.buffer},this.cryptoKey,t);const a=(new TextDecoder).decode(n);return JSON.parse(a)}async setItem(t,e,n,a={}){await this.init();if(!this.db){throw new Error("Database not initialized")}const s=a.encrypt!==false&&t==="wallet-data";let o=n;let r=false;if(s&&this.cryptoKey){try{const{encrypted:t,iv:e}=await this.encrypt(n);o={data:Array.from(new Uint8Array(t)),iv:Array.from(e)};r=true}catch(t){console.warn("Encryption failed, storing unencrypted:",t)}}const i={key:e,value:o,timestamp:Date.now(),encrypted:r};return new Promise(((e,n)=>{const a=this.db.transaction([t],"readwrite");const s=a.objectStore(t);const o=s.put(i);o.onsuccess=()=>e();o.onerror=()=>n(new Error(`Failed to store item: ${o.error?.message}`))}))}async getItem(t,e){await this.init();if(!this.db){throw new Error("Database not initialized")}return new Promise(((n,a)=>{const s=this.db.transaction([t],"readonly");const o=s.objectStore(t);const r=o.get(e);r.onsuccess=async()=>{const t=r.result;if(!t){n(null);return}if(t.encrypted&&this.cryptoKey){try{const e=t.value;const a=new Uint8Array(e.data);const s=new Uint8Array(e.iv);const o=await this.decrypt(a.buffer,s);n(o)}catch(t){console.error("Decryption failed:",t);n(null)}}else{n(t.value)}};r.onerror=()=>a(new Error(`Failed to retrieve item: ${r.error?.message}`))}))}async removeItem(t,e){await this.init();if(!this.db){throw new Error("Database not initialized")}return new Promise(((n,a)=>{const s=this.db.transaction([t],"readwrite");const o=s.objectStore(t);const r=o.delete(e);r.onsuccess=()=>n();r.onerror=()=>a(new Error(`Failed to remove item: ${r.error?.message}`))}))}async clear(t){await this.init();if(!this.db){throw new Error("Database not initialized")}return new Promise(((e,n)=>{const a=this.db.transaction([t],"readwrite");const s=a.objectStore(t);const o=s.clear();o.onsuccess=()=>e();o.onerror=()=>n(new Error(`Failed to clear store: ${o.error?.message}`))}))}async getAllKeys(t){await this.init();if(!this.db){throw new Error("Database not initialized")}return new Promise(((e,n)=>{const a=this.db.transaction([t],"readonly");const s=a.objectStore(t);const o=s.getAllKeys();o.onsuccess=()=>e(o.result);o.onerror=()=>n(new Error(`Failed to get keys: ${o.error?.message}`))}))}async cleanupCache(t=24*60*60*1e3){await this.init();if(!this.db){throw new Error("Database not initialized")}const e=Date.now()-t;return new Promise(((t,n)=>{const a=this.db.transaction(["cache"],"readwrite");const s=a.objectStore("cache");const o=s.index("timestamp");const r=o.openCursor(IDBKeyRange.upperBound(e));r.onsuccess=e=>{const n=e.target.result;if(n){n.delete();n.continue()}else{t()}};r.onerror=()=>n(new Error(`Failed to cleanup cache: ${r.error?.message}`))}))}close(){if(this.db){this.db.close();this.db=null}this.initPromise=null}}const c=new i;const l={async setConnectedWallets(t){const e=Object.fromEntries(t);return c.setItem("wallet-data","connected-wallets",e,{encrypt:true})},async getConnectedWallets(){const t=await c.getItem("wallet-data","connected-wallets");return t?new Map(Object.entries(t)):new Map},async setAddressBook(t){return c.setItem("wallet-data","address-book",t,{encrypt:true})},async getAddressBook(){return await c.getItem("wallet-data","address-book")||[]},async clearWalletData(){return c.clear("wallet-data")}};async function d(){const t=[{old:"euclid-address-book",new:"address-book",store:"wallet-data"}];for(const e of t){try{const t=localStorage.getItem(e.old);if(t){const n=JSON.parse(t);await c.setItem(e.store,e.new,n);localStorage.removeItem(e.old);console.log(`Migrated ${e.old} to IndexedDB`)}}catch(t){console.warn(`Failed to migrate ${e.old}:`,t)}}}const u={isConnected:false,address:null,chainId:null,chainUID:null,walletType:null,balances:[],loading:false,error:null,connectedWallets:new Map,wallets:new Map};const{state:h,onChange:w,reset:p,dispose:y}=t(u);const m=e({state:h,onChange:w},"wallet-store",{debounceMs:100,deepCompare:true,skipFields:["loading","error"]});const f={setLoading(t){h.loading=t},setError(t){h.error=t},async initialize(){await d();try{const t=await l.getConnectedWallets();if(t.size>0){m.smartUpdate({connectedWallets:t,wallets:t});const e=Array.from(t.values())[0];if(e){m.smartUpdate({isConnected:true,address:e.address,chainUID:e.chainUID,walletType:e.walletType,balances:[...e.balances]})}}}catch(t){console.warn("Failed to load persisted wallets:",t)}console.log("Wallet store initialized")},async connectWallet(t,e){h.loading=true;h.error=null;try{const n=r.getAdapter(t);if(!n.isAvailable()){throw new Error(`${t} wallet is not installed`)}const a=await n.connect(e);h.isConnected=true;h.address=a.address;h.chainId=a.chainId;h.chainUID=a.chainId;h.walletType=t;h.error=null}catch(t){h.error=t instanceof Error?t.message:"Failed to connect wallet"}finally{h.loading=false}},async disconnectWallet(t){if(t){f.removeWallet(t)}else{if(h.walletType){try{const t=r.getAdapter(h.walletType);await t.disconnect()}catch(t){console.warn("Error disconnecting wallet:",t)}}h.isConnected=false;h.address=null;h.chainId=null;h.chainUID=null;h.walletType=null;h.balances=[];h.connectedWallets.clear();h.error=null}},setBalances(t){h.balances=[...t]},updateBalance(t,e){const n=h.balances.findIndex((e=>e.token===t));const a={amount:e,token_id:t,token:t,balance:e,chain_uid:h.chainUID||"",token_type:{native:{denom:t}}};if(n>=0){h.balances[n]=a}else{h.balances.push(a)}},async switchChain(t){if(!h.walletType){throw new Error("No wallet connected")}h.loading=true;h.error=null;try{const e=r.getAdapter(h.walletType);await e.switchChain(t);h.chainId=t;h.chainUID=t;h.error=null}catch(t){h.error=t instanceof Error?t.message:"Failed to switch chain"}finally{h.loading=false}},clear(){p()},addWallet(t,e){const n={...e,chainUID:t,type:e.walletType,name:e.walletType};const a=new Map(h.connectedWallets);a.set(t,n);m.smartUpdate({connectedWallets:a,wallets:a});if(!h.isConnected){m.smartUpdate({isConnected:true,address:e.address,chainUID:t,walletType:e.walletType,balances:[...e.balances]})}l.setConnectedWallets(a).catch((t=>{console.warn("Failed to persist wallet connections:",t)}))},removeWallet(t){const e=new Map(h.connectedWallets);e.delete(t);m.smartUpdate({connectedWallets:e,wallets:e});if(h.chainUID===t){const t=Array.from(e.values());if(t.length>0){const e=t[0];m.smartUpdate({address:e.address,chainUID:e.chainUID,walletType:e.walletType,balances:[...e.balances]})}else{m.smartUpdate({isConnected:false,address:null,chainUID:null,walletType:null,balances:[]})}}l.setConnectedWallets(e).catch((t=>{console.warn("Failed to persist wallet connections:",t)}))},updateWalletBalances(t,e){const n=h.connectedWallets.get(t);if(n){const a={...n,balances:[...e]};const s=new Map(h.connectedWallets);s.set(t,a);m.smartUpdate({connectedWallets:s,wallets:s});if(h.chainUID===t){m.smartUpdate({balances:[...e]})}l.setConnectedWallets(s).catch((t=>{console.warn("Failed to persist wallet connections:",t)}))}}};const E={getBalance:t=>h.balances.find((e=>e.token===t)),getFormattedBalance:(t,e=18)=>{const n=E.getBalance(t);if(!n)return"0";try{const t=BigInt(n.balance);const a=BigInt(10**e);const s=t/a;const o=t%a;return`${s.toString()}.${o.toString().padStart(e,"0")}`}catch{return"0"}},hasSufficientBalance:(t,e,n)=>{if(typeof n==="string"&&e&&n){const a=t;const s=e;const o=n;const r=h.connectedWallets.get(a);if(!r)return false;const i=r.balances.find((t=>t.token===s));if(!i)return false;try{return BigInt(i.balance)>=BigInt(o)}catch{return false}}else{const n=t;const a=e||"";const s=E.getBalance(n);if(!s)return false;try{return BigInt(s.balance)>=BigInt(a)}catch{return false}}},isWalletAvailable:t=>{try{const e=r.getAdapter(t);return e.isAvailable()}catch{return false}},getAvailableWallets:()=>r.getAvailableWalletTypes(),isWalletConnected:t=>{const e=h.connectedWallets.get(t);return e?e.isConnected:false},getAllConnectedWallets:()=>Array.from(h.connectedWallets.values()).filter((t=>t.isConnected)),getWalletBalance:(t,e)=>{const n=h.connectedWallets.get(t);if(!n)return null;return n.balances.find((t=>t.token===e||t.token.toLowerCase()===e.toLowerCase()))},getWallet:t=>h.connectedWallets.get(t)||null,addTransaction:(t,e)=>{console.log(`Transaction added for ${t}:`,e)},updateTransactionStatus:(t,e,n)=>{console.log(`Transaction ${e} on ${t} updated to status: ${n}`)}};const g={state:h,onChange:w,reset:p,dispose:y,...f,...E};const T={walletModalOpen:false,walletModalFilter:null,tokenModalOpen:false,tokenSelectorType:null,isInitialized:false,theme:"auto"};const{state:A,onChange:_,reset:k,dispose:I}=t(T);const b={initialize(){A.isInitialized=true},openWalletModal(t){A.walletModalOpen=true;A.walletModalFilter=t||null},closeWalletModal(){A.walletModalOpen=false;A.walletModalFilter=null},openTokenModal(t="input"){A.tokenModalOpen=true;A.tokenSelectorType=t},closeTokenModal(){A.tokenModalOpen=false;A.tokenSelectorType=null},setTheme(t){A.theme=t},clear(){k()}};const S={state:A,onChange:_,reset:k,dispose:I,...b};const C={tokenIn:null,tokenOut:null,fromToken:null,toToken:null,amountIn:"",amountOut:"",fromAmount:"",toAmount:"",routes:[],selectedRoute:null,slippage:.5,loading:false,error:null};const{state:M,onChange:D,reset:v,dispose:O}=t(C);const P={setTokenIn(t){M.tokenIn=t;M.fromToken=t;M.routes=[];M.selectedRoute=null;M.amountOut="";M.toAmount=""},setTokenOut(t){M.tokenOut=t;M.toToken=t;M.routes=[];M.selectedRoute=null;M.amountOut="";M.toAmount=""},setFromToken(t){P.setTokenIn(t)},setToToken(t){P.setTokenOut(t)},setAmountIn(t){M.amountIn=t;M.fromAmount=t;if(!t){M.amountOut="";M.toAmount="";M.routes=[];M.selectedRoute=null}},setAmountOut(t){M.amountOut=t;M.toAmount=t},setFromAmount(t){P.setAmountIn(t)},setToAmount(t){P.setAmountOut(t)},setRoutes(t){M.routes=[...t];M.loading=false;M.error=null;if(t.length>0){P.setSelectedRoute(t[0])}},setSelectedRoute(t){M.selectedRoute=t;if(t&&t.path.length>0){const e=t.path[t.path.length-1];M.amountOut=e.amount_out}},setLoading(t){M.loading=t},setError(t){M.error=t},setSlippage(t){M.slippage=t},setLoadingRoutes(t){M.loading=t},setSwapping(t){M.loading=t},swapTokens(){const t=M.tokenIn;const e=M.tokenOut;const n=M.amountIn;M.tokenIn=e;M.tokenOut=t;M.fromToken=e;M.toToken=t;M.amountIn="";M.amountOut=n;M.fromAmount="";M.toAmount=n;M.routes=[];M.selectedRoute=null;M.error=null},clear(){v()}};const $={canSwap:()=>!!(M.tokenIn&&M.tokenOut&&M.amountIn&&parseFloat(M.amountIn)>0&&M.selectedRoute&&!M.loading),getPriceImpact:()=>M.selectedRoute?.total_price_impact||"0",getEstimatedGas:()=>{if(!M.selectedRoute)return"0";const t=M.selectedRoute.path.length;return(t*1e5).toString()},isValidPair:()=>!!(M.tokenIn&&M.tokenOut&&M.tokenIn.id!==M.tokenOut.id),getSlippageAmount:()=>{if(!M.amountOut||!M.slippage)return"0";try{const t=BigInt(M.amountOut);const e=BigInt(Math.floor(M.slippage*100));const n=t*e/BigInt(1e4);const a=t-n;return a.toString()}catch{return"0"}}};const F={state:M,onChange:D,reset:v,dispose:O,...P,...$};const R={token1:null,token2:null,amount1:"",amount2:"",token1Amount:"",token2Amount:"",pool:null,selectedPool:null,userLpBalance:"0",loading:false,error:null};const{state:N,onChange:L,reset:B,dispose:q}=t(R);const U={setLoading(t){N.loading=t},setError(t){N.error=t},setToken1(t){N.token1=t;if(N.pool&&t&&N.pool.token_1!==t.id&&N.pool.token_2!==t.id){N.pool=null}},setToken2(t){N.token2=t;if(N.pool&&t&&N.pool.token_1!==t.id&&N.pool.token_2!==t.id){N.pool=null}},setAmount1(t){N.amount1=t;N.token1Amount=t},setAmount2(t){N.amount2=t;N.token2Amount=t},setToken1Amount(t){U.setAmount1(t)},setToken2Amount(t){U.setAmount2(t)},setPool(t){N.pool=t;N.selectedPool=t},setSelectedPool(t){U.setPool(t)},setUserLpBalance(t){N.userLpBalance=t},swapTokens(){const t=N.token1;const e=N.token2;const n=N.amount1;const a=N.amount2;N.token1=e;N.token2=t;N.amount1=a;N.amount2=n},clear(){B()},setAddingLiquidity(t){N.loading=t},setRemovingLiquidity(t){N.loading=t},getPosition(t){console.warn(`getPosition(${t}) not implemented`);return null}};const W={canAddLiquidity:()=>!!(N.token1&&N.token2&&N.amount1&&N.amount2&&parseFloat(N.amount1)>0&&parseFloat(N.amount2)>0&&!N.loading),canRemoveLiquidity:()=>!!(N.pool&&N.userLpBalance&&parseFloat(N.userLpBalance)>0&&!N.loading),getPoolLiquidity:()=>N.pool?.total_liquidity||"0",getPoolVolume24h:()=>N.pool?.volume_24h||"0",getPoolFees24h:()=>N.pool?.fees_24h||"0",getPoolAPR:()=>N.pool?.apr||"0",isValidPair:()=>!!(N.token1&&N.token2&&N.token1.id!==N.token2.id)};const x={state:N,onChange:L,reset:B,dispose:q,...U,...W};const V={graphqlEndpoint:"https://testnet.api.euclidprotocol.com/graphql",restEndpoint:"https://testnet.api.euclidprotocol.com/api/v1",apiTimeout:1e4,environment:"testnet",refreshIntervals:{marketData:3e4,balances:6e4,routes:3e5},performance:{cache:{marketData:5e3,chains:3e5,routes:3e4,balances:6e4,tokens:5e3},polling:{active:{marketData:5e3,chains:3e5,balances:6e4,routes:1e4},background:{marketData:3e5,chains:18e5,balances:6e5,routes:6e4}},requestDeduplication:true,pauseOnHidden:true},ui:{defaultSlippage:.5,animationDuration:250,zIndex:{modal:1e3,tooltip:1070,dropdown:1e3}},features:{darkMode:true,transactionHistory:true,advancedRouting:true},defaultWallet:"keplr",supportedWallets:["keplr","metamask","walletconnect","coinbase"],defaultChain:"osmosis-1",supportedChains:["cosmoshub-4","osmosis-1","juno-1","stargaze-1","ethereum","polygon","arbitrum","optimism"]};const K={mainnet:{graphqlEndpoint:"https://api.euclidprotocol.com/graphql",restEndpoint:"https://api.euclidprotocol.com/api/v1",environment:"mainnet"},testnet:{graphqlEndpoint:"https://testnet.api.euclidprotocol.com/graphql",restEndpoint:"https://testnet.api.euclidprotocol.com/api/v1",environment:"testnet"},devnet:{graphqlEndpoint:"https://devnet.api.euclidprotocol.com/graphql",restEndpoint:"https://devnet.api.euclidprotocol.com/api/v1",environment:"devnet"}};const H=(t,e)=>({...t,...e,refreshIntervals:{...t.refreshIntervals,...e.refreshIntervals},ui:{...t.ui,...e.ui,zIndex:{...t.ui.zIndex,...e.ui?.zIndex}},features:{...t.features,...e.features}});class G{constructor(t){const e={...V,...t};this.endpoint=e.graphqlEndpoint;this.timeout=e.apiTimeout}async query(t,e){const n=new AbortController;const a=setTimeout((()=>n.abort()),this.timeout);try{const s=await fetch(this.endpoint,{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({query:t,variables:e||{}}),signal:n.signal});clearTimeout(a);if(!s.ok){throw new Error(`HTTP error! status: ${s.status}`)}const o=await s.json();if(o.errors){throw new Error(`GraphQL error: ${o.errors.map((t=>t.message)).join(", ")}`)}return{success:true,data:o.data}}catch(t){clearTimeout(a);console.error("GraphQL query failed:",t);return{success:false,error:t instanceof Error?t.message:"Unknown error"}}}async getChains(t){const e=`\n      query Chains($showAllChains: Boolean, $type: String) {\n        chains {\n          all_chains(show_all_chains: $showAllChains, type: $type) {\n            chain_id\n            chain_uid\n            display_name\n            factory_address\n            token_factory_address\n            explorer_url\n            logo\n            type\n          }\n        }\n      }\n    `;const n=await this.query(e,t);if(!n.success||!n.data){throw new Error(n.error||"Failed to fetch chains")}return n.data.chains.all_chains}async getTokenMetadata(t){const e=`\n      query Token(\n        $limit: Int,\n        $offset: Int,\n        $verified: Boolean,\n        $dex: [String!],\n        $chainUids: [String!],\n        $showVolume: Boolean,\n        $search: String\n      ) {\n        token {\n          token_metadatas(\n            limit: $limit,\n            offset: $offset,\n            verified: $verified,\n            dex: $dex,\n            chain_uids: $chainUids,\n            show_volume: $showVolume,\n            search: $search\n          ) {\n            coinDecimal\n            displayName\n            tokenId\n            description\n            image\n            price\n            price_change_24h\n            price_change_7d\n            dex\n            chain_uids\n            total_volume\n            total_volume_24h\n            tags\n            min_swap_value\n            social\n            is_verified\n          }\n        }\n      }\n    `;const n=await this.query(e,t);if(!n.success||!n.data){throw new Error(n.error||"Failed to fetch token metadata")}return n.data.token.token_metadatas}async getAllPools(t,e=true){try{const t=`\n        query Token_pair_with_liquidity($limit: Int, $onlyShowVerified: Boolean) {\n          pool {\n            token_pair_with_liquidity(limit: $limit, only_show_verified: $onlyShowVerified) {\n              results {\n                pair {\n                  token_1\n                  token_2\n                }\n                vlp\n                total_liquidity\n                apr\n                tags\n                created_at\n              }\n              pagination {\n                total_count\n                limit\n                offset\n              }\n            }\n          }\n        }\n      `;const n=await this.query(t,{limit:1e3,onlyShowVerified:e});if(!n.success||!n.data?.pool?.token_pair_with_liquidity?.results){throw new Error(n.error||"Failed to fetch pools with liquidity data")}const a=n.data.pool.token_pair_with_liquidity.results.map((t=>({pool_id:`${t.pair.token_1}-${t.pair.token_2}`,token_1:t.pair.token_1,token_2:t.pair.token_2,total_liquidity:t.total_liquidity,volume_24h:"0",fees_24h:"0",apr:t.apr})));console.log(`âœ… Loaded ${a.length} pools with real liquidity and APR data from official API`);return a}catch(t){console.error("Failed to fetch pools with liquidity data:",t);return[]}}async getUserBalances(t){const e=`\n      query Vcoin($user: CrossChainUserInput) {\n        vcoin {\n          user_balance(user: $user) {\n            balances {\n              amount\n              token_id\n            }\n          }\n        }\n      }\n    `;const n={user:{address:t.address,chain_uid:t.chain_uid}};const a=await this.query(e,n);if(!a.success||!a.data){throw new Error(a.error||"Failed to fetch user balances")}return a.data.vcoin.user_balance.balances}async getPoolInfo(t,e){const n=await this.getAllPools();return n.find((n=>n.token_1===t&&n.token_2===e||n.token_1===e&&n.token_2===t))||null}async searchTokens(t,e){const n={search:t};if(e){n.chainUids=[e]}const a=await this.getTokenMetadata(n);const s=t.toLowerCase();return a.filter((t=>t.displayName?.toLowerCase().includes(s)||t.tokenId?.toLowerCase().includes(s)||t.description?.toLowerCase().includes(s)||t.symbol?.toLowerCase().includes(s)||t.name?.toLowerCase().includes(s)))}async getTokenBySymbol(t,e){const n=await this.getTokenMetadata({chainUids:[e]});return n.find((e=>e.displayName?.toLowerCase()===t.toLowerCase()||e.symbol?.toLowerCase()===t.toLowerCase()))||null}}const z=t=>new G(t);class j{constructor(t){const e={...V,...t};this.endpoint=e.restEndpoint;this.timeout=e.apiTimeout}async request(t,e={}){const n=new AbortController;const a=setTimeout((()=>n.abort()),this.timeout);try{const{method:s="GET",body:o,headers:r={}}=e;const i=await fetch(`${this.endpoint}${t}`,{method:s,headers:{"Content-Type":"application/json",Accept:"application/json",...r},body:o?JSON.stringify(o):undefined,signal:n.signal});clearTimeout(a);if(!i.ok){const t=await i.text();throw new Error(`HTTP ${i.status}: ${t}`)}const c=await i.json();return{success:true,data:c}}catch(e){clearTimeout(a);console.error(`REST API request failed (${t}):`,e);return{success:false,error:e instanceof Error?e.message:"Unknown error"}}}async getRoutes(t){const e=new URLSearchParams({amount_in:t.amount_in,token_in:t.token_in,token_out:t.token_out});if(t.external!==undefined){e.append("external",t.external.toString())}if(t.chain_uids&&t.chain_uids.length>0){t.chain_uids.forEach((t=>{e.append("chain_uids",t)}))}const n=await this.request(`/routes?${e}`);if(!n.success||!n.data){throw new Error(n.error||"Failed to fetch routes")}return n.data.paths}async buildSwapTransaction(t){const e=await this.request("/swap",{method:"POST",body:t});if(!e.success||!e.data){throw new Error(e.error||"Failed to build swap transaction")}return e.data}async buildAddLiquidityTransaction(t){const e=await this.request("/add_liquidity",{method:"POST",body:t});if(!e.success||!e.data){throw new Error(e.error||"Failed to build add liquidity transaction")}return e.data}async buildRemoveLiquidityTransaction(t){const e=await this.request("/remove_liquidity",{method:"POST",body:t});if(!e.success||!e.data){throw new Error(e.error||"Failed to build remove liquidity transaction")}return e.data}async simulateSwap(t){const e=new URLSearchParams({amount_in:t.amount_in,token_in:t.token_in,token_out:t.token_out});if(t.chain_uid){e.append("chain_uid",t.chain_uid)}const n=await this.request(`/simulate_swap?${e}`);if(!n.success||!n.data){throw new Error(n.error||"Failed to simulate swap")}return n.data}async getBestRoute(t){const e=await this.getRoutes(t);if(e.length===0){return null}return e.sort(((t,e)=>parseFloat(t.total_price_impact)-parseFloat(e.total_price_impact)))[0]}async getTransactionStatus(t,e){const n=await this.request(`/transaction/${t}?chain_uid=${e}`);if(!n.success||!n.data){throw new Error(n.error||"Failed to get transaction status")}return n.data}async estimateGas(t){const e=await this.request("/estimate_gas",{method:"POST",body:t});if(!e.success||!e.data){throw new Error(e.error||"Failed to estimate gas")}return e.data}}const J=t=>new j(t);class Q{constructor(t){this.graphql=z(t);this.rest=J(t)}async getChains(t){return this.graphql.getChains(t)}async getTokenMetadata(t){return this.graphql.getTokenMetadata(t)}async searchTokens(t,e){return this.graphql.searchTokens(t,e)}async getTokenBySymbol(t,e){return this.graphql.getTokenBySymbol(t,e)}async getAllPools(t=true){try{const e=await this.graphql.getAllPools(undefined,t);return{success:true,data:e}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to get pools"}}}async getPoolInfo(t,e){return this.graphql.getPoolInfo(t,e)}async getAllChains(t){try{const e=await this.getChains({showAllChains:t});return{success:true,data:e}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to get chains"}}}async getAllTokens(){try{const t=await this.getTokenMetadata();return{success:true,data:t}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to get tokens"}}}async getTokenDenoms(t){console.warn(`getTokenDenoms(${t}) is not implemented in Euclid API`);return{success:true,data:{router:{token_denoms:{denoms:[]}}}}}async getEscrows(t){console.warn(`getEscrows(${t}) is not implemented in Euclid API`);return{success:true,data:{router:{escrows:[]}}}}async getBalance(t,e){try{const n=await this.getUserBalances({address:t,chain_uid:e});const a={balance:{all:n.map((t=>({denom:t.token,amount:t.balance})))}};return{success:true,data:a}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to get balance"}}}async getUserBalances(t){return this.graphql.getUserBalances(t)}async getRoutes(t){return this.rest.getRoutes(t)}async getRoutesWrapped(t){try{const e=await this.getRoutes(t);return{success:true,data:{paths:e}}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to get routes"}}}async getRoutesLegacy(t){return this.getRoutesWrapped(t)}async getBestRoute(t){return this.rest.getBestRoute(t)}async simulateSwap(t){return this.rest.simulateSwap(t)}async createSwapTransaction(t){return this.rest.buildSwapTransaction(t)}async createSwapTransactionWrapped(t){try{const e=await this.createSwapTransaction(t);return{success:true,data:e}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to create swap transaction"}}}async buildSwapTransaction(t){return this.createSwapTransaction(t)}async createAddLiquidityTransaction(t){return this.rest.buildAddLiquidityTransaction(t)}async createAddLiquidityTransactionWrapped(t){try{const e=await this.createAddLiquidityTransaction(t);return{success:true,data:e}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to create add liquidity transaction"}}}async createRemoveLiquidityTransaction(t){return this.rest.buildRemoveLiquidityTransaction(t)}async createRemoveLiquidityTransactionWrapped(t){try{const e=await this.createRemoveLiquidityTransaction(t);return{success:true,data:e}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to create remove liquidity transaction"}}}async trackTransaction(t,e){console.warn(`trackTransaction(${t}, ${e}) not implemented`);return{status:"pending"}}async trackTransactionWrapped(t,e){try{const n=await this.trackTransaction(t,e);return{success:true,data:n}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to track transaction"}}}async buildAddLiquidityTransaction(t){return this.rest.buildAddLiquidityTransaction(t)}async buildRemoveLiquidityTransaction(t){return this.rest.buildRemoveLiquidityTransaction(t)}async getTransactionStatus(t,e){return this.rest.getTransactionStatus(t,e)}async estimateGas(t){return this.rest.estimateGas(t)}async getMarketData(){const[t,e,n]=await Promise.all([this.getChains(),this.getTokenMetadata(),this.getAllPools()]);const a=n.success?n.data||[]:[];return{chains:t,tokens:e,pools:a}}async getUserPortfolio(t){const[e,n,a]=await Promise.all([this.getUserBalances(t),this.getChains(),this.getTokenMetadata()]);return{balances:e,chains:n,tokens:a}}async getSwapQuote(t,e,n,a){const s={amount_in:n,token_in:t,token_out:e,chain_uids:a};const[o,r]=await Promise.all([this.getBestRoute(s),this.simulateSwap({amount_in:n,token_in:t,token_out:e}).catch((()=>({amount_out:"0",price_impact:"0"})))]);return{route:o,expectedOutput:r.amount_out,priceImpact:r.price_impact}}}const Y=new Q;const Z=t=>new Q(t);const X={ETHEREUM:"ethereum",POLYGON:"polygon",ARBITRUM:"arbitrum",OPTIMISM:"optimism",COSMOS_HUB:"cosmoshub-4",OSMOSIS:"osmosis-1",JUNO:"juno-1",STARGAZE:"stargaze-1"};const tt={METAMASK:"metamask",KEPLR:"keplr",WALLET_CONNECT:"walletconnect",COINBASE:"coinbase",OTHER:"other"};const et={SWAP:"swap",ADD_LIQUIDITY:"add_liquidity",REMOVE_LIQUIDITY:"remove_liquidity",TRANSFER:"transfer"};const nt={PENDING:"pending",SUCCESS:"success",FAILED:"failed"};const at={CHAINS:"/api/chains",TOKENS:"/api/tokens",POOLS:"/api/pools",ROUTES:"/api/routes",BALANCES:"/api/balances",TRANSACTIONS:"/api/transactions",GRAPHQL:"/graphql"};const st={WALLET_PREFERENCES:"euclid_wallet_preferences",THEME:"euclid_theme",SLIPPAGE:"euclid_slippage",TRANSACTION_HISTORY:"euclid_transaction_history"};const ot={SLIPPAGE:V.ui.defaultSlippage,ROUTE_REFRESH_INTERVAL:V.refreshIntervals.routes,MARKET_DATA_REFRESH_INTERVAL:V.refreshIntervals.marketData,BALANCE_REFRESH_INTERVAL:V.refreshIntervals.balances,TRANSACTION_TIMEOUT:3e5};const rt={MODAL_Z_INDEX:V.ui.zIndex.modal,TOOLTIP_Z_INDEX:V.ui.zIndex.tooltip,DROPDOWN_Z_INDEX:V.ui.zIndex.dropdown,ANIMATION_DURATION:V.ui.animationDuration};const it={ETH_ADDRESS:/^0x[a-fA-F0-9]{40}$/,COSMOS_ADDRESS:/^[a-z0-9]{39,59}$/,DECIMAL_NUMBER:/^\d*\.?\d*$/,POSITIVE_NUMBER:/^[+]?([0-9]*[.])?[0-9]+$/};const ct={WALLET_NOT_CONNECTED:"Wallet not connected",INSUFFICIENT_BALANCE:"Insufficient balance",INVALID_AMOUNT:"Invalid amount",NO_ROUTE_FOUND:"No route found for this swap",TRANSACTION_FAILED:"Transaction failed",NETWORK_ERROR:"Network error occurred",TIMEOUT:"Request timeout"};const lt={WALLET_CONNECTED:"Wallet connected successfully",TRANSACTION_SUBMITTED:"Transaction submitted",TRANSACTION_CONFIRMED:"Transaction confirmed",LIQUIDITY_ADDED:"Liquidity added successfully",LIQUIDITY_REMOVED:"Liquidity removed successfully"};const dt={DARK_MODE:V.features.darkMode,ADVANCED_ROUTING:V.features.advancedRouting,TRANSACTION_HISTORY:V.features.transactionHistory};export{at as A,X as C,V as D,K as E,dt as F,it as P,st as S,et as T,rt as U,tt as W,S as a,l as b,Z as c,ot as d,Y as e,nt as f,ct as g,lt as h,x as l,H as m,F as s,g as w};
//# sourceMappingURL=p-BxhOwSSQ.js.map