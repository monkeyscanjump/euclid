{"file":"p-Wc26abo-.js","mappings":"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","names":[],"sources":["src/utils/graphql-client.ts","src/utils/rest-client.ts","src/utils/api-client.ts"],"sourcesContent":["import type {\n  EuclidChainConfig,\n  TokenMetadata,\n  PoolInfo,\n  UserBalance,\n  CrossChainUser,\n  ChainsQueryResponse,\n  TokenMetadataQueryResponse,\n  UserBalanceQueryResponse,\n  ApiResponse\n} from './types/api.types';\n\n// GraphQL endpoint for Euclid testnet\nconst EUCLID_GRAPHQL_ENDPOINT = 'https://testnet.api.euclidprotocol.com/graphql';\n\n/**\n * GraphQL client for Euclid Protocol\n * Handles all GraphQL queries to the Euclid API\n */\nexport class EuclidGraphQLClient {\n  private endpoint: string;\n\n  constructor(endpoint: string = EUCLID_GRAPHQL_ENDPOINT) {\n    this.endpoint = endpoint;\n  }\n\n  /**\n   * Execute a GraphQL query\n   */\n  private async query<T>(query: string, variables?: Record<string, unknown>): Promise<ApiResponse<T>> {\n    try {\n      const response = await fetch(this.endpoint, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Accept': 'application/json',\n        },\n        body: JSON.stringify({\n          query,\n          variables: variables || {},\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const result = await response.json();\n\n      if (result.errors) {\n        throw new Error(`GraphQL error: ${result.errors.map((e: { message: string }) => e.message).join(', ')}`);\n      }\n\n      return {\n        success: true,\n        data: result.data,\n      };\n    } catch (error) {\n      console.error('GraphQL query failed:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  /**\n   * Get all supported chains\n   */\n  async getChains(variables?: { showAllChains?: boolean; type?: string }): Promise<EuclidChainConfig[]> {\n    const query = `\n      query Chains($showAllChains: Boolean, $type: String) {\n        chains {\n          all_chains(show_all_chains: $showAllChains, type: $type) {\n            chain_id\n            chain_uid\n            display_name\n            factory_address\n            token_factory_address\n            explorer_url\n            logo\n            type\n          }\n        }\n      }\n    `;\n\n    const result = await this.query<ChainsQueryResponse>(query, variables);\n\n    if (!result.success || !result.data) {\n      throw new Error(result.error || 'Failed to fetch chains');\n    }\n\n    return result.data.chains.all_chains;\n  }\n\n  /**\n   * Get token metadata\n   */\n  async getTokenMetadata(variables?: {\n    limit?: number;\n    offset?: number;\n    verified?: boolean;\n    dex?: string[];\n    chainUids?: string[];\n    showVolume?: boolean;\n    search?: string;\n  }): Promise<TokenMetadata[]> {\n    const query = `\n      query Token(\n        $limit: Int,\n        $offset: Int,\n        $verified: Boolean,\n        $dex: [String!],\n        $chainUids: [String!],\n        $showVolume: Boolean,\n        $search: String\n      ) {\n        token {\n          token_metadatas(\n            limit: $limit,\n            offset: $offset,\n            verified: $verified,\n            dex: $dex,\n            chain_uids: $chainUids,\n            show_volume: $showVolume,\n            search: $search\n          ) {\n            coinDecimal\n            displayName\n            tokenId\n            description\n            image\n            price\n            price_change_24h\n            price_change_7d\n            dex\n            chain_uids\n            total_volume\n            total_volume_24h\n            tags\n            min_swap_value\n            social\n            is_verified\n          }\n        }\n      }\n    `;\n\n    const result = await this.query<TokenMetadataQueryResponse>(query, variables);\n\n    if (!result.success || !result.data) {\n      throw new Error(result.error || 'Failed to fetch token metadata');\n    }\n\n    return result.data.token.token_metadatas;\n  }\n\n  /**\n   * Get all liquidity pools with proper TVL and APR data\n   * @param chainUid - Optional chain filter (unused for now)\n   * @param onlyVerified - Whether to show only verified pools (default: true)\n   */\n  async getAllPools(_chainUid?: string, onlyVerified: boolean = true): Promise<PoolInfo[]> {\n    try {\n      const query = `\n        query Token_pair_with_liquidity($limit: Int, $onlyShowVerified: Boolean) {\n          pool {\n            token_pair_with_liquidity(limit: $limit, only_show_verified: $onlyShowVerified) {\n              results {\n                pair {\n                  token_1\n                  token_2\n                }\n                vlp\n                total_liquidity\n                apr\n                tags\n                created_at\n              }\n              pagination {\n                total_count\n                limit\n                offset\n              }\n            }\n          }\n        }\n      `;\n\n      const result = await this.query<{\n        pool: {\n          token_pair_with_liquidity: {\n            results: Array<{\n              pair: { token_1: string; token_2: string };\n              vlp: string;\n              total_liquidity: string;\n              apr: string;\n              tags: string[] | null;\n              created_at: string;\n            }>;\n            pagination: {\n              total_count: number;\n              limit: number;\n              offset: number;\n            };\n          };\n        };\n      }>(query, {\n        limit: 1000,\n        onlyShowVerified: onlyVerified\n      });\n\n      if (!result.success || !result.data?.pool?.token_pair_with_liquidity?.results) {\n        throw new Error(result.error || 'Failed to fetch pools with liquidity data');\n      }\n\n      // Transform the API response to our PoolInfo interface\n      const pools = result.data.pool.token_pair_with_liquidity.results.map((pool) => {\n        return {\n          pool_id: `${pool.pair.token_1}-${pool.pair.token_2}`,\n          token_1: pool.pair.token_1,\n          token_2: pool.pair.token_2,\n          total_liquidity: pool.total_liquidity,\n          volume_24h: '0', // This API doesn't provide volume data\n          fees_24h: '0', // This API doesn't provide fees data\n          apr: pool.apr,\n        } satisfies PoolInfo;\n      });\n\n      console.log(`âœ… Loaded ${pools.length} pools with real liquidity and APR data from official API`);\n      return pools;\n\n    } catch (error) {\n      console.error('Failed to fetch pools with liquidity data:', error);\n      return [];\n    }\n  }  /**\n   * Get user balances across all chains\n   */\n  async getUserBalances(user: CrossChainUser): Promise<UserBalance[]> {\n    const query = `\n      query Vcoin($user: CrossChainUserInput) {\n        vcoin {\n          user_balance(user: $user) {\n            balances {\n              amount\n              token_id\n            }\n          }\n        }\n      }\n    `;\n\n    const variables = {\n      user: {\n        address: user.address,\n        chain_uid: user.chain_uid,\n      },\n    };\n\n    const result = await this.query<UserBalanceQueryResponse>(query, variables);\n\n    if (!result.success || !result.data) {\n      throw new Error(result.error || 'Failed to fetch user balances');\n    }\n\n    return result.data.vcoin.user_balance.balances;\n  }\n\n  /**\n   * Get pool information for a specific pair\n   */\n  async getPoolInfo(token1: string, token2: string): Promise<PoolInfo | null> {\n    const pools = await this.getAllPools();\n    return pools.find(pool =>\n      (pool.token_1 === token1 && pool.token_2 === token2) ||\n      (pool.token_1 === token2 && pool.token_2 === token1)\n    ) || null;\n  }\n\n  /**\n   * Search tokens by symbol or name\n   */\n    async searchTokens(searchTerm: string, chainUID?: string): Promise<TokenMetadata[]> {\n    const options: Parameters<typeof this.getTokenMetadata>[0] = { search: searchTerm };\n    if (chainUID) {\n      options.chainUids = [chainUID];\n    }\n    const tokens = await this.getTokenMetadata(options);\n\n    const lowerSearchTerm = searchTerm.toLowerCase();\n    return tokens.filter(token =>\n      token.displayName?.toLowerCase().includes(lowerSearchTerm) ||\n      token.tokenId?.toLowerCase().includes(lowerSearchTerm) ||\n      token.description?.toLowerCase().includes(lowerSearchTerm) ||\n      // Legacy field fallbacks\n      token.symbol?.toLowerCase().includes(lowerSearchTerm) ||\n      token.name?.toLowerCase().includes(lowerSearchTerm)\n    );\n  }\n\n  /**\n   * Get token by symbol and chain\n   */\n  async getTokenBySymbol(symbol: string, chainUID: string): Promise<TokenMetadata | null> {\n    const tokens = await this.getTokenMetadata({ chainUids: [chainUID] });\n    // Use displayName (symbol equivalent) for comparison, with fallback to legacy fields\n    return tokens.find(token =>\n      token.displayName?.toLowerCase() === symbol.toLowerCase() ||\n      token.symbol?.toLowerCase() === symbol.toLowerCase()\n    ) || null;\n  }\n}\n\n// Export a default instance\nexport const euclidGraphQLClient = new EuclidGraphQLClient();\n","import type {\n  GetRoutesRequest,\n  GetRoutesResponse,\n  RoutePath,\n  SwapRequest,\n  AddLiquidityRequest,\n  RemoveLiquidityRequest,\n  TransactionResponse,\n  ApiResponse\n} from './types/api.types';\n\n// REST API endpoint for Euclid testnet\nconst EUCLID_REST_ENDPOINT = 'https://testnet.api.euclidprotocol.com/api/v1';\n\n/**\n * REST client for Euclid Protocol\n * Handles all REST API calls for transactions, routing, and operations\n */\nexport class EuclidRESTClient {\n  private endpoint: string;\n\n  constructor(endpoint: string = EUCLID_REST_ENDPOINT) {\n    this.endpoint = endpoint;\n  }\n\n  /**\n   * Execute a REST API request\n   */\n  private async request<T>(\n    path: string,\n    options: {\n      method?: 'GET' | 'POST' | 'PUT' | 'DELETE';\n      body?: unknown;\n      headers?: Record<string, string>;\n    } = {}\n  ): Promise<ApiResponse<T>> {\n    try {\n      const { method = 'GET', body, headers = {} } = options;\n\n      const response = await fetch(`${this.endpoint}${path}`, {\n        method,\n        headers: {\n          'Content-Type': 'application/json',\n          'Accept': 'application/json',\n          ...headers,\n        },\n        body: body ? JSON.stringify(body) : undefined,\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`HTTP ${response.status}: ${errorText}`);\n      }\n\n      const result = await response.json();\n\n      return {\n        success: true,\n        data: result,\n      };\n    } catch (error) {\n      console.error(`REST API request failed (${path}):`, error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  /**\n   * Get routing paths for a swap\n   */\n  async getRoutes(request: GetRoutesRequest): Promise<RoutePath[]> {\n    const queryParams = new URLSearchParams({\n      amount_in: request.amount_in,\n      token_in: request.token_in,\n      token_out: request.token_out,\n    });\n\n    if (request.external !== undefined) {\n      queryParams.append('external', request.external.toString());\n    }\n\n    if (request.chain_uids && request.chain_uids.length > 0) {\n      request.chain_uids.forEach(chainUID => {\n        queryParams.append('chain_uids', chainUID);\n      });\n    }\n\n    const result = await this.request<GetRoutesResponse>(`/routes?${queryParams}`);\n\n    if (!result.success || !result.data) {\n      throw new Error(result.error || 'Failed to fetch routes');\n    }\n\n    return result.data.paths;\n  }\n\n  /**\n   * Build a swap transaction\n   */\n  async buildSwapTransaction(request: SwapRequest): Promise<TransactionResponse> {\n    const result = await this.request<TransactionResponse>('/swap', {\n      method: 'POST',\n      body: request,\n    });\n\n    if (!result.success || !result.data) {\n      throw new Error(result.error || 'Failed to build swap transaction');\n    }\n\n    return result.data;\n  }\n\n  /**\n   * Build an add liquidity transaction\n   */\n  async buildAddLiquidityTransaction(request: AddLiquidityRequest): Promise<TransactionResponse> {\n    const result = await this.request<TransactionResponse>('/add_liquidity', {\n      method: 'POST',\n      body: request,\n    });\n\n    if (!result.success || !result.data) {\n      throw new Error(result.error || 'Failed to build add liquidity transaction');\n    }\n\n    return result.data;\n  }\n\n  /**\n   * Build a remove liquidity transaction\n   */\n  async buildRemoveLiquidityTransaction(request: RemoveLiquidityRequest): Promise<TransactionResponse> {\n    const result = await this.request<TransactionResponse>('/remove_liquidity', {\n      method: 'POST',\n      body: request,\n    });\n\n    if (!result.success || !result.data) {\n      throw new Error(result.error || 'Failed to build remove liquidity transaction');\n    }\n\n    return result.data;\n  }\n\n  /**\n   * Simulate a swap to get expected output\n   */\n  async simulateSwap(request: {\n    amount_in: string;\n    token_in: string;\n    token_out: string;\n    chain_uid?: string;\n  }): Promise<{ amount_out: string; price_impact: string }> {\n    const queryParams = new URLSearchParams({\n      amount_in: request.amount_in,\n      token_in: request.token_in,\n      token_out: request.token_out,\n    });\n\n    if (request.chain_uid) {\n      queryParams.append('chain_uid', request.chain_uid);\n    }\n\n    const result = await this.request<{ amount_out: string; price_impact: string }>(`/simulate_swap?${queryParams}`);\n\n    if (!result.success || !result.data) {\n      throw new Error(result.error || 'Failed to simulate swap');\n    }\n\n    return result.data;\n  }\n\n  /**\n   * Get optimal route for a swap with the best price\n   */\n  async getBestRoute(request: GetRoutesRequest): Promise<RoutePath | null> {\n    const routes = await this.getRoutes(request);\n\n    if (routes.length === 0) {\n      return null;\n    }\n\n    // Sort by total price impact (lower is better)\n    return routes.sort((a, b) =>\n      parseFloat(a.total_price_impact) - parseFloat(b.total_price_impact)\n    )[0];\n  }\n\n  /**\n   * Get transaction status\n   */\n  async getTransactionStatus(txHash: string, chainUID: string): Promise<{\n    status: 'pending' | 'success' | 'failed';\n    blockHeight?: number;\n    gasUsed?: string;\n    fee?: string;\n  }> {\n    const result = await this.request<{\n      status: 'pending' | 'success' | 'failed';\n      blockHeight?: number;\n      gasUsed?: string;\n      fee?: string;\n    }>(`/transaction/${txHash}?chain_uid=${chainUID}`);\n\n    if (!result.success || !result.data) {\n      throw new Error(result.error || 'Failed to get transaction status');\n    }\n\n    return result.data;\n  }\n\n  /**\n   * Get gas estimate for a transaction\n   */\n  async estimateGas(transaction: TransactionResponse): Promise<{ gasLimit: string; gasPrice: string }> {\n    const result = await this.request<{ gasLimit: string; gasPrice: string }>('/estimate_gas', {\n      method: 'POST',\n      body: transaction,\n    });\n\n    if (!result.success || !result.data) {\n      throw new Error(result.error || 'Failed to estimate gas');\n    }\n\n    return result.data;\n  }\n}\n\n// Export a default instance\nexport const euclidRESTClient = new EuclidRESTClient();\n","/**\n * Unified API Client for Euclid Protocol\n * Combines GraphQL and REST clients for a single interface\n */\n\nimport { euclidGraphQLClient } from './graphql-client';\nimport { euclidRESTClient } from './rest-client';\nimport type {\n  EuclidChainConfig,\n  TokenMetadata,\n  PoolInfo,\n  UserBalance,\n  RoutePath,\n  SwapRequest,\n  AddLiquidityRequest,\n  RemoveLiquidityRequest,\n  TransactionResponse,\n  CrossChainUser,\n  GetRoutesRequest\n} from './types/api.types';\n\n/**\n * Main API client that provides a unified interface to Euclid Protocol\n * Uses dedicated GraphQL and REST clients under the hood\n */\nexport class EuclidAPIClient {\n  private graphql = euclidGraphQLClient;\n  private rest = euclidRESTClient;\n\n  // ============================================================================\n  // CHAIN & TOKEN METADATA (GraphQL)\n  // ============================================================================\n\n  /**\n   * Get all supported blockchain networks\n   */\n  async getChains(options?: { showAllChains?: boolean; type?: string }): Promise<EuclidChainConfig[]> {\n    return this.graphql.getChains(options);\n  }\n\n  /**\n   * Get token metadata information\n   */\n  async getTokenMetadata(options?: {\n    limit?: number;\n    offset?: number;\n    verified?: boolean;\n    dex?: string[];\n    chainUids?: string[];\n    showVolume?: boolean;\n    search?: string;\n  }): Promise<TokenMetadata[]> {\n    return this.graphql.getTokenMetadata(options);\n  }\n\n  /**\n   * Search for tokens by symbol or name\n   */\n  async searchTokens(searchTerm: string, chainUID?: string): Promise<TokenMetadata[]> {\n    return this.graphql.searchTokens(searchTerm, chainUID);\n  }\n\n  /**\n   * Get a specific token by symbol and chain\n   */\n  async getTokenBySymbol(symbol: string, chainUID: string): Promise<TokenMetadata | null> {\n    return this.graphql.getTokenBySymbol(symbol, chainUID);\n  }\n\n  // ============================================================================\n  // LIQUIDITY POOLS (GraphQL)\n  // ============================================================================\n\n  /**\n   * Get all liquidity pools\n   * @param onlyVerified - Whether to show only verified pools (default: true)\n   */\n  async getAllPools(onlyVerified: boolean = true): Promise<{ success: boolean; data?: PoolInfo[]; error?: string }> {\n    try {\n      const data = await this.graphql.getAllPools(undefined, onlyVerified);\n      return { success: true, data };\n    } catch (error) {\n      return { success: false, error: error instanceof Error ? error.message : 'Failed to get pools' };\n    }\n  }\n\n  /**\n   * Get pool information for a specific token pair\n   */\n  async getPoolInfo(token1: string, token2: string): Promise<PoolInfo | null> {\n    return this.graphql.getPoolInfo(token1, token2);\n  }\n\n  // ============================================================================\n  // LEGACY METHOD ALIASES FOR BACKWARD COMPATIBILITY\n  // ============================================================================\n\n  /**\n   * @deprecated Use getChains() instead\n   */\n  async getAllChains(showAllChains?: boolean): Promise<{ success: boolean; data?: EuclidChainConfig[]; error?: string }> {\n    try {\n      const data = await this.getChains({ showAllChains });\n      return { success: true, data };\n    } catch (error) {\n      return { success: false, error: error instanceof Error ? error.message : 'Failed to get chains' };\n    }\n  }\n\n  /**\n   * @deprecated Use getTokenMetadata() instead\n   */\n  async getAllTokens(): Promise<{ success: boolean; data?: TokenMetadata[]; error?: string }> {\n    try {\n      const data = await this.getTokenMetadata();\n      return { success: true, data };\n    } catch (error) {\n      return { success: false, error: error instanceof Error ? error.message : 'Failed to get tokens' };\n    }\n  }\n\n  /**\n   * Get token denominations for a token ID (placeholder - not implemented in Euclid API)\n   */\n  async getTokenDenoms(tokenId: string): Promise<{ success: boolean; data?: { router: { token_denoms: { denoms: string[] } } }; error?: string }> {\n    // This method doesn't exist in the real Euclid API\n    console.warn(`getTokenDenoms(${tokenId}) is not implemented in Euclid API`);\n    return { success: true, data: { router: { token_denoms: { denoms: [] } } } };\n  }\n\n  /**\n   * Get escrow information for a token (placeholder - not implemented in Euclid API)\n   */\n  async getEscrows(tokenId: string): Promise<{ success: boolean; data?: { router: { escrows: unknown[] } }; error?: string }> {\n    // This method doesn't exist in the real Euclid API\n    console.warn(`getEscrows(${tokenId}) is not implemented in Euclid API`);\n    return { success: true, data: { router: { escrows: [] } } };\n  }\n\n  /**\n   * Get balance for a specific address and chain (legacy compatibility)\n   */\n  async getBalance(address: string, chainUID: string): Promise<{ success: boolean; data?: { balance?: { all?: Array<{ denom: string; amount: string }> } }; error?: string }> {\n    try {\n      const balances = await this.getUserBalances({ address, chain_uid: chainUID });\n      const data = {\n        balance: {\n          all: balances.map(b => ({\n            denom: b.token,\n            amount: b.balance\n          }))\n        }\n      };\n      return { success: true, data };\n    } catch (error) {\n      return { success: false, error: error instanceof Error ? error.message : 'Failed to get balance' };\n    }\n  }\n\n  // ============================================================================\n  // USER DATA (GraphQL)\n  // ============================================================================\n\n  /**\n   * Get user token balances across all chains\n   */\n  async getUserBalances(user: CrossChainUser): Promise<UserBalance[]> {\n    return this.graphql.getUserBalances(user);\n  }\n\n  // ============================================================================\n  // ROUTING & SWAPS (REST)\n  // ============================================================================\n\n  /**\n   * Get routing paths for a swap\n   */\n  async getRoutes(request: GetRoutesRequest): Promise<RoutePath[]> {\n    return this.rest.getRoutes(request);\n  }\n\n  /**\n   * Legacy method that returns wrapped response format (used by swap controller)\n   */\n  async getRoutesWrapped(request: GetRoutesRequest): Promise<{ success: boolean; data?: { paths: RoutePath[] }; error?: string }> {\n    try {\n      const paths = await this.getRoutes(request);\n      return { success: true, data: { paths } };\n    } catch (error) {\n      return { success: false, error: error instanceof Error ? error.message : 'Failed to get routes' };\n    }\n  }\n\n  /**\n   * Override getRoutes to return wrapped format by default for backward compatibility\n   */\n  async getRoutesLegacy(request: GetRoutesRequest): Promise<{ success: boolean; data?: { paths: RoutePath[] }; error?: string }> {\n    return this.getRoutesWrapped(request);\n  }\n\n  /**\n   * Get the optimal route for a swap\n   */\n  async getBestRoute(request: GetRoutesRequest): Promise<RoutePath | null> {\n    return this.rest.getBestRoute(request);\n  }\n\n  /**\n   * Simulate a swap to get expected output\n   */\n  async simulateSwap(request: {\n    amount_in: string;\n    token_in: string;\n    token_out: string;\n    chain_uid?: string;\n  }): Promise<{ amount_out: string; price_impact: string }> {\n    return this.rest.simulateSwap(request);\n  }\n\n  // ============================================================================\n  // TRANSACTION BUILDING (REST)\n  // ============================================================================\n\n  /**\n   * Create a swap transaction\n   */\n  async createSwapTransaction(request: SwapRequest): Promise<TransactionResponse> {\n    return this.rest.buildSwapTransaction(request);\n  }\n\n  /**\n   * Create a swap transaction with wrapped response\n   */\n  async createSwapTransactionWrapped(request: SwapRequest): Promise<{ success: boolean; data?: TransactionResponse; error?: string }> {\n    try {\n      const data = await this.createSwapTransaction(request);\n      return { success: true, data };\n    } catch (error) {\n      return { success: false, error: error instanceof Error ? error.message : 'Failed to create swap transaction' };\n    }\n  }\n\n  /**\n   * Create a swap transaction (legacy method name)\n   */\n  async buildSwapTransaction(request: SwapRequest): Promise<TransactionResponse> {\n    return this.createSwapTransaction(request);\n  }\n\n  /**\n   * Create add liquidity transaction (legacy method name)\n   */\n  async createAddLiquidityTransaction(request: AddLiquidityRequest): Promise<TransactionResponse> {\n    return this.rest.buildAddLiquidityTransaction(request);\n  }\n\n  /**\n   * Create add liquidity transaction with wrapped response\n   */\n  async createAddLiquidityTransactionWrapped(request: AddLiquidityRequest): Promise<{ success: boolean; data?: TransactionResponse; error?: string }> {\n    try {\n      const data = await this.createAddLiquidityTransaction(request);\n      return { success: true, data };\n    } catch (error) {\n      return { success: false, error: error instanceof Error ? error.message : 'Failed to create add liquidity transaction' };\n    }\n  }\n\n  /**\n   * Create remove liquidity transaction (legacy method name)\n   */\n  async createRemoveLiquidityTransaction(request: RemoveLiquidityRequest): Promise<TransactionResponse> {\n    return this.rest.buildRemoveLiquidityTransaction(request);\n  }\n\n  /**\n   * Create remove liquidity transaction with wrapped response\n   */\n  async createRemoveLiquidityTransactionWrapped(request: RemoveLiquidityRequest): Promise<{ success: boolean; data?: TransactionResponse; error?: string }> {\n    try {\n      const data = await this.createRemoveLiquidityTransaction(request);\n      return { success: true, data };\n    } catch (error) {\n      return { success: false, error: error instanceof Error ? error.message : 'Failed to create remove liquidity transaction' };\n    }\n  }\n\n  /**\n   * Track transaction status (placeholder - not implemented in Euclid API)\n   */\n  async trackTransaction(txHash: string, chainUID: string): Promise<{ status: 'pending' | 'confirmed' | 'failed' }> {\n    // This would typically query blockchain for transaction status\n    console.warn(`trackTransaction(${txHash}, ${chainUID}) not implemented`);\n    return { status: 'pending' };\n  }\n\n  /**\n   * Track transaction status with wrapped response\n   */\n  async trackTransactionWrapped(txHash: string, chainUID: string): Promise<{ success: boolean; data?: { status: 'pending' | 'confirmed' | 'failed' }; error?: string }> {\n    try {\n      const data = await this.trackTransaction(txHash, chainUID);\n      return { success: true, data };\n    } catch (error) {\n      return { success: false, error: error instanceof Error ? error.message : 'Failed to track transaction' };\n    }\n  }\n\n  /**\n   * Build an add liquidity transaction\n   */\n  async buildAddLiquidityTransaction(request: AddLiquidityRequest): Promise<TransactionResponse> {\n    return this.rest.buildAddLiquidityTransaction(request);\n  }\n\n  /**\n   * Build a remove liquidity transaction\n   */\n  async buildRemoveLiquidityTransaction(request: RemoveLiquidityRequest): Promise<TransactionResponse> {\n    return this.rest.buildRemoveLiquidityTransaction(request);\n  }\n\n  // ============================================================================\n  // TRANSACTION STATUS & GAS ESTIMATION (REST)\n  // ============================================================================\n\n  /**\n   * Get transaction status\n   */\n  async getTransactionStatus(txHash: string, chainUID: string): Promise<{\n    status: 'pending' | 'success' | 'failed';\n    blockHeight?: number;\n    gasUsed?: string;\n    fee?: string;\n  }> {\n    return this.rest.getTransactionStatus(txHash, chainUID);\n  }\n\n  /**\n   * Estimate gas for a transaction\n   */\n  async estimateGas(transaction: TransactionResponse): Promise<{ gasLimit: string; gasPrice: string }> {\n    return this.rest.estimateGas(transaction);\n  }\n\n  // ============================================================================\n  // CONVENIENCE METHODS\n  // ============================================================================\n\n  /**\n   * Get comprehensive market data\n   */\n  async getMarketData(): Promise<{\n    chains: EuclidChainConfig[];\n    tokens: TokenMetadata[];\n    pools: PoolInfo[];\n  }> {\n    const [chains, tokens, poolsResult] = await Promise.all([\n      this.getChains(),\n      this.getTokenMetadata(),\n      this.getAllPools(),\n    ]);\n\n    const pools = poolsResult.success ? (poolsResult.data || []) : [];\n\n    return { chains, tokens, pools };\n  }\n\n  /**\n   * Get user's complete portfolio\n   */\n  async getUserPortfolio(user: CrossChainUser): Promise<{\n    balances: UserBalance[];\n    chains: EuclidChainConfig[];\n    tokens: TokenMetadata[];\n  }> {\n    const [balances, chains, tokens] = await Promise.all([\n      this.getUserBalances(user),\n      this.getChains(),\n      this.getTokenMetadata(),\n    ]);\n\n    return { balances, chains, tokens };\n  }\n\n  /**\n   * Get quote for a swap with the best route\n   */\n  async getSwapQuote(\n    tokenIn: string,\n    tokenOut: string,\n    amountIn: string,\n    chainUIDs?: string[]\n  ): Promise<{\n    route: RoutePath | null;\n    expectedOutput: string;\n    priceImpact: string;\n  }> {\n    const routeRequest: GetRoutesRequest = {\n      amount_in: amountIn,\n      token_in: tokenIn,\n      token_out: tokenOut,\n      chain_uids: chainUIDs,\n    };\n\n    const [route, simulation] = await Promise.all([\n      this.getBestRoute(routeRequest),\n      this.simulateSwap({\n        amount_in: amountIn,\n        token_in: tokenIn,\n        token_out: tokenOut,\n      }).catch(() => ({ amount_out: '0', price_impact: '0' })),\n    ]);\n\n    return {\n      route,\n      expectedOutput: simulation.amount_out,\n      priceImpact: simulation.price_impact,\n    };\n  }\n}\n\n// Export the default instance\nexport const apiClient = new EuclidAPIClient();\n\n// Re-export types for convenience\nexport type {\n  EuclidChainConfig,\n  TokenMetadata,\n  PoolInfo,\n  UserBalance,\n  RoutePath,\n  SwapRequest,\n  AddLiquidityRequest,\n  RemoveLiquidityRequest,\n  TransactionResponse,\n  CrossChainUser,\n  GetRoutesRequest\n} from './types/api.types';\n"],"version":3}