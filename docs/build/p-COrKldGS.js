import{D as n}from"./p-9CRWQAc1.js";async function t(t,o,e){const s={...n,...e};const i=new AbortController;const a=setTimeout((()=>i.abort()),s.apiTimeout);try{const n=await fetch(s.graphqlEndpoint,{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({query:t,variables:o}),signal:i.signal});clearTimeout(a);if(!n.ok){throw new Error(`HTTP ${n.status}: ${n.statusText}`)}const e=await n.json();if(e.errors){throw new Error(`GraphQL errors: ${e.errors.map((n=>n.message)).join(", ")}`)}return e.data}catch(n){clearTimeout(a);const t=n instanceof Error?n.message:"Unknown error";throw new Error(`Router query failed: ${t}`)}}async function o(){const n=`\n    query Router {\n      router {\n        all_chains {\n          factory_address\n          chain_id\n          chain_uid\n        }\n      }\n    }\n  `;const o=await t(n);return o.router.all_chains}async function e(n,o){const e=`\n    query All_escrows($limit: Int, $offset: Int) {\n      router {\n        all_escrows(limit: $limit, offset: $offset) {\n          escrows {\n            escrow_address\n            token_id\n            chain_uid\n            balance\n            denoms\n          }\n          pagination {\n            total_count\n            limit\n            offset\n          }\n        }\n      }\n    }\n  `;const s=await t(e,{limit:n,offset:o});return s.router.all_escrows}async function s(n,o){const e=`\n    query All_tokens($limit: Int, $offset: Int) {\n      router {\n        all_tokens(limit: $limit, offset: $offset) {\n          tokens {\n            token_id\n            display_name\n            type\n            denoms\n            chains\n          }\n          pagination {\n            total_count\n            limit\n            offset\n          }\n        }\n      }\n    }\n  `;const s=await t(e,{limit:n,offset:o});return s.router.all_tokens}async function i(n,o){const e=`\n    query All_vlps($limit: Int, $offset: Int) {\n      router {\n        all_vlps(limit: $limit, offset: $offset) {\n          vlps {\n            vlp_address\n            pair {\n              token_1\n              token_2\n            }\n            total_liquidity\n            chains\n          }\n          pagination {\n            total_count\n            limit\n            offset\n          }\n        }\n      }\n    }\n  `;const s=await t(e,{limit:n,offset:o});return s.router.all_vlps}async function a(n){const o=`\n    query Chain($chainUid: String!) {\n      router {\n        chain(chain_uid: $chainUid) {\n          chain_uid\n          display_name\n          type\n          status\n          router_address\n          factory_address\n          supported_tokens\n        }\n      }\n    }\n  `;const e=await t(o,{chainUid:n});return e.router.chain}async function r(n,o,e){const s=`\n    query Escrows($chainUid: String!, $limit: Int, $offset: Int) {\n      router {\n        escrows(chain_uid: $chainUid, limit: $limit, offset: $offset) {\n          escrows {\n            escrow_address\n            token_id\n            balance\n            denoms\n          }\n          pagination {\n            total_count\n            limit\n            offset\n          }\n        }\n      }\n    }\n  `;const i=await t(s,{chainUid:n,limit:o,offset:e});return i.router.escrows}async function c(n,o){const e=`\n    query Simulate_escrow_release($escrowId: String!, $recipient: String!) {\n      router {\n        simulate_escrow_release(escrow_id: $escrowId, recipient: $recipient) {\n          amount_released\n          fees_paid\n          gas_estimate\n          success\n        }\n      }\n    }\n  `;const s=await t(e,{escrowId:n,recipient:o});return s.router.simulate_escrow_release}async function u(n,o,e,s,i){const a=`\n    query Simulate_swap($assetIn: String!, $amountIn: String!, $assetOut: String!, $minAmountOut: String!, $swaps: [String!]) {\n      router {\n        simulate_swap(asset_in: $assetIn, amount_in: $amountIn, asset_out: $assetOut, min_amount_out: $minAmountOut, swaps: $swaps) {\n          amount_out\n          asset_out\n        }\n      }\n    }\n  `;const r=await t(a,{assetIn:n,amountIn:o,assetOut:e,minAmountOut:s,swaps:i});return r.router.simulate_swap}async function l(){const n=`\n    query State {\n      router {\n        state {\n          router_address\n          total_chains\n          total_tokens\n          total_vlps\n          total_escrows\n          total_volume\n          protocol_version\n        }\n      }\n    }\n  `;const o=await t(n);return o.router.state}async function _(n){const o=`\n    query Token_denoms($tokenId: String!) {\n      router {\n        token_denoms(token_id: $tokenId) {\n          denoms {\n            denom\n            chain_uid\n            decimals\n            symbol\n          }\n        }\n      }\n    }\n  `;const e=await t(o,{tokenId:n});return e.router.token_denoms}async function f(n){const o=`\n    query Token_pair_from_vlp($vlp: String!) {\n      router {\n        token_pair_from_vlp(vlp: $vlp) {\n          pair {\n            token_1\n            token_2\n          }\n          vlp_address\n        }\n      }\n    }\n  `;const e=await t(o,{vlp:n});return e.router.token_pair_from_vlp}async function d(n){const o=`\n    query VLP($pair: PairInput!) {\n      router {\n        vlp(pair: $pair) {\n          vlp_address\n          pair {\n            token_1\n            token_2\n          }\n          total_liquidity\n          chains\n          status\n        }\n      }\n    }\n  `;const e=await t(o,{pair:n});return e.router.vlp}export{o as getAllChainsImpl,e as getAllEscrowsImpl,s as getAllTokensImpl,i as getAllVLPsImpl,a as getChainImpl,r as getEscrowsImpl,l as getStateImpl,_ as getTokenDenomsImpl,f as getTokenPairFromVLPImpl,d as getVLPImpl,c as simulateEscrowReleaseImpl,u as simulateSwapImpl};
//# sourceMappingURL=p-COrKldGS.js.map