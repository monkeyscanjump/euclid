---
sidebar_position: 3
---
import Tabs from '@site/src/components/Tabs';

# Add Liquidity
To add liquidity to a pool, a liquidity transaction needs to be generated by calling the `Liquidity Add` endpoint in the Rest API and then broadcast to a chain. 

The [Add Liquidity](../REST/Transactions/Add%20Liquidity.md) parameters are the following:

```bash
pair_info
token_1_liquidity
token_2_liquidity
slippage_tolerance
timeout
```
We will go through all the steps needed to get each of the parameters.

## Steps

The following steps describe the workflow to add liquidity to a pool using the Euclid Layer:

### 1. Get all available pools

The first step of the process will be retrieving all the available VLP. This can be done using the [All VLPS](../GQL/Router/All%20VLPs.md) query:

:::note
You can use pagination to iterate through all the pools as you like.
:::

```graphql
query All_vlps {
  router {
    all_vlps {
      vlps {
        vlp
        token_1
        token_2
      }
    }
  }
}
```
This will return all the available pools in the Euclid Layer:

```JSON
{
  "data": {
    "router": {
      "all_vlps": {
        "vlps": [
          {
            "vlp": "nibi1qyhzzpkqysyvra3g88ady5af2532kd2e8l987n6m0r9ca2vm280q0wz02r",
            "token_1": "axs",
            "token_2": "ron"
          },
          {
            "vlp": "nibi13tdnxhwexkj528dke4hhduraus6w58yzl3mcxk5p2wtfmu8pj2sslx9mgx",
            "token_1": "bnb",
            "token_2": "euclid"
          },
          {
            "vlp": "nibi1wu3y423gmdv8ytkc6q2d0hwen7pmhm9rd39rxw70hde0txgd8gzqsz9ng8",
            "token_1": "eth",
            "token_2": "euclid"
          },
          {
            "vlp": "nibi17e5uq086kxlav8s2gpr6qlezfv9qsaeeaar2m58z2j4ue7qczgws3hydp9",
            "token_1": "eth",
            "token_2": "sp500"
          },
          {
            "vlp": "nibi156qtenwsr08g8kw3qwm3teg73sgg4arvjfc4nrwcs4j2vccjy28qx848js",
            "token_1": "eth",
            "token_2": "usdc"
          },
          {
            "vlp": "nibi1w0dywahjxpqhgv5jgclupq58my228cexuwgj7zfr6gleapuheedqys0sl5",
            "token_1": "eth",
            "token_2": "usdt"
          }
        ]
      }
    }
  }
}
```
Using this data, you can prompt the user to select the pool they wish to provide liquidity to. You will also need the address of the VLP, so make sure to keep that saved.

### 2. Select the chain to add liquidity on
Now that we have chosen the token pair to add liquidity to, we can check the chains that can be used to add liquidity. This can be done using the [All Pools](../GQL/VLP/All%20Pools.md) query:

:::note
Use the contract address of the VLP contract for the token pair selected by the user.
:::

```graphql
query Vlp($contract: String!) {
  vlp(contract: $contract) {
    all_pools {
      pools {
        chain_uid
        pool {
          reserve_1
          reserve_2
          lp_shares
        }
      }
    }
  }
}
```
The response will retrieve the chains where this pair exists (`eth-euclid` in this example):

```JSON
{
  "data": {
    "vlp": {
      "all_pools": {
        "pools": [
          {
            "chain_uid": "arbitrum",
            "pool": {
              "reserve_1": "3052595291791029289",
              "reserve_2": "4105362908",
              "lp_shares": "88591197298970"
            }
          },
          {
            "chain_uid": "base",
            "pool": {
              "reserve_1": "16603608176937143257",
              "reserve_2": "22329798298",
              "lp_shares": "481863262985903"
            }
          },
          {
            "chain_uid": "manta",
            "pool": {
              "reserve_1": "132357131471934793",
              "reserve_2": "178003962",
              "lp_shares": "3841215630414"
            }
          },
          {
            "chain_uid": "optimism",
            "pool": {
              "reserve_1": "5810647211079423950",
              "reserve_2": "7814601430",
              "lp_shares": "168634274872847"
            }
          },
          {
            "chain_uid": "scroll",
            "pool": {
              "reserve_1": "2491975658960022483",
              "reserve_2": "3351398878",
              "lp_shares": "72321118970746"
            }
          },
          {
            "chain_uid": "sepolia",
            "pool": {
              "reserve_1": "14764746867692563426",
              "reserve_2": "19856757397",
              "lp_shares": "428496566951609"
            }
          }
        ]
      }
    }
  }
}
```
The user can select the pool they wish to add to. 

### 3. Get the allowed denoms for each of the tokens

For each of the tokens in the pair, we need to get the allowed denoms. This will be used to specify the `pair_info` field for the add liquidity call. The allowed denoms can be fetched using the [Escrow](../GQL/Factory/Escrow.md) query:

:::tip
Use the `chain_uid` from the last step and `token Id` from step 1.
:::

```graphql
query Escrow($chainUid: String!, $tokenId: String) {
  factory(chain_uid: $chainUid) {
    escrow(token_id: $tokenId) {
      escrow_address
      denoms {
        ... on SmartTokenType {
          smart {
            contract_address
          }
        }
        ... on NativeTokenType {
          native {
            denom
          }
        }
      }
    }
  }
}
```
The response will return the denom to be used:

```JSON
{
  "data": {
    "factory": {
      "escrow": {
        "denoms": [
          {
            "smart": {
              "contract_address": "0x1ecc257dc10a8478af1f742a5069e80b6236daa2"
            }
          }
        ],
        "escrow_address": "0xEb4d418834B0e18e3E38617042bd9AB9D5fFf1a5"
      }
    }
  }
}
```
We then perform the same query for the second token in the pool getting the denom for it as well. 

### 4. Specify the amount of liquidity to be added

The user can specify the amount of liquidity to add for one of the tokens, and we can calculate the seconds amount automatically. Given the amount of token 1 to add, the second amount can be calculated as follows:

$$
\text{Amount of Token 2} = \frac{\text{Current Reserve of Token 2}}{\text{Current Reserve of Token 1}} \times \text{Amount of Token 1}
$$

This ensures that the ratio of liquidity remains the same. 

### 5. Generate Add Liquidity transaction
:::note
- Use the responses we got in all the previous steps for the fields.
- For sender address and chain_uid use the ones from the connected chain. In the example below, we are using a Keplr wallet.
- You can add (prompt the user) the slippage tolerance for the transaction. Specified as a pecent between 1 and 100.
:::

We now have everything needed to generate the Add Liquidity transaction message:

<Tabs
  tabs={[
    {
      id: 'cosmwasm-liquidity-js',
      label: 'CosmWasm',
      language: 'javascript',
      content: `const msg = await axios.post("https://testnet.api.euclidprotocol.com/api/v1/execute/liquidity/add", {
  token_1_liquidity: token1Amount, // Liquidity to add for token 1
  token_2_liquidity: token2Amount, // Liquidity to add for token 2
  slippage_tolerance: slippageTolerance, // Slippage tolerance in %
  pair_info: pair, // Token pair information
  sender: {
    address: wallet!.bech32Address,
    chain_uid: chain!.chain_uid,
  },
}).then((res) => res.data as TxResult);

console.log(msg.msgs, "Liquidity Response");`
    },
    {
      id: 'evm-liquidity-js',
      label: 'EVM',
      language: 'javascript',
      content: `const msg = await axios.post("https://testnet.api.euclidprotocol.com/api/v1/execute/liquidity/add", {
  token_1_liquidity: token1Amount,
  token_2_liquidity: token2Amount,
  slippage_tolerance: slippageTolerance,
  pair_info: pair,
  sender: {
    address: walletAddress, // EVM address
    chain_uid: chainUid
  }
}).then((res) => res.data);`
    }
  ]}
/>

### 6. Broadcast the transaction to chain

The final step will be broadcasting this transaction to the chain and signing it with the connected wallet:

<Tabs
  tabs={[
    {
      id: 'cosmos-liquidity-broadcast',
      label: 'CosmWasm',
      language: 'javascript',
      content: `const tx = await client!.executeMultiple(
  wallet!.bech32Address,
  msg.msgs,
  "auto",
  "Add Liquidity"
);
return tx;`
    },
    {
      id: 'evm-liquidity-broadcast',
      label: 'EVM',
      language: 'javascript',
      content: `const provider = new ethers.providers.Web3Provider(window.ethereum);
const signer = provider.getSigner();

// Construct the transaction data
const tx = {
  to: msg.msgs[0].to, // Contract address
  data: msg.msgs[0].data, // Encoded calldata
  value: msg.msgs[0].value || "0x0" 
};

// Send transaction using signer (e.g. MetaMask)
const receipt = await signer.sendTransaction(tx);

// Optional: Wait for confirmation
const confirmed = await receipt.wait();
return confirmed;`
    }
  ]}
/>
