{"version":3,"file":"p-BZ6fXqkj.js","sources":["node_modules/@stencil/store/dist/index.js","src/utils/store-update-coordinator.ts","src/store/market.store.ts"],"sourcesContent":["import { getRenderingRef, forceUpdate } from '@stencil/core';\n\nconst appendToMap = (map, propName, value) => {\n    const items = map.get(propName);\n    if (!items) {\n        map.set(propName, [value]);\n    }\n    else if (!items.includes(value)) {\n        items.push(value);\n    }\n};\nconst debounce = (fn, ms) => {\n    let timeoutId;\n    return (...args) => {\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        timeoutId = setTimeout(() => {\n            timeoutId = 0;\n            fn(...args);\n        }, ms);\n    };\n};\n\n/**\n * Check if a possible element isConnected.\n * The property might not be there, so we check for it.\n *\n * We want it to return true if isConnected is not a property,\n * otherwise we would remove these elements and would not update.\n *\n * Better leak in Edge than to be useless.\n */\nconst isConnected = (maybeElement) => !('isConnected' in maybeElement) || maybeElement.isConnected;\nconst cleanupElements = debounce((map) => {\n    for (let key of map.keys()) {\n        map.set(key, map.get(key).filter(isConnected));\n    }\n}, 2_000);\nconst stencilSubscription = () => {\n    if (typeof getRenderingRef !== 'function') {\n        // If we are not in a stencil project, we do nothing.\n        // This function is not really exported by @stencil/core.\n        return {};\n    }\n    const elmsToUpdate = new Map();\n    return {\n        dispose: () => elmsToUpdate.clear(),\n        get: (propName) => {\n            const elm = getRenderingRef();\n            if (elm) {\n                appendToMap(elmsToUpdate, propName, elm);\n            }\n        },\n        set: (propName) => {\n            const elements = elmsToUpdate.get(propName);\n            if (elements) {\n                elmsToUpdate.set(propName, elements.filter(forceUpdate));\n            }\n            cleanupElements(elmsToUpdate);\n        },\n        reset: () => {\n            elmsToUpdate.forEach((elms) => elms.forEach(forceUpdate));\n            cleanupElements(elmsToUpdate);\n        },\n    };\n};\n\nconst unwrap = (val) => (typeof val === 'function' ? val() : val);\nconst createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {\n    const unwrappedState = unwrap(defaultState);\n    let states = new Map(Object.entries(unwrappedState ?? {}));\n    const handlers = {\n        dispose: [],\n        get: [],\n        set: [],\n        reset: [],\n    };\n    // Track onChange listeners to enable removeListener functionality\n    const changeListeners = new Map();\n    const reset = () => {\n        // When resetting the state, the default state may be a function - unwrap it to invoke it.\n        // otherwise, the state won't be properly reset\n        states = new Map(Object.entries(unwrap(defaultState) ?? {}));\n        handlers.reset.forEach((cb) => cb());\n    };\n    const dispose = () => {\n        // Call first dispose as resetting the state would\n        // cause less updates ;)\n        handlers.dispose.forEach((cb) => cb());\n        reset();\n    };\n    const get = (propName) => {\n        handlers.get.forEach((cb) => cb(propName));\n        return states.get(propName);\n    };\n    const set = (propName, value) => {\n        const oldValue = states.get(propName);\n        if (shouldUpdate(value, oldValue, propName)) {\n            states.set(propName, value);\n            handlers.set.forEach((cb) => cb(propName, value, oldValue));\n        }\n    };\n    const state = (typeof Proxy === 'undefined'\n        ? {}\n        : new Proxy(unwrappedState, {\n            get(_, propName) {\n                return get(propName);\n            },\n            ownKeys(_) {\n                return Array.from(states.keys());\n            },\n            getOwnPropertyDescriptor() {\n                return {\n                    enumerable: true,\n                    configurable: true,\n                };\n            },\n            has(_, propName) {\n                return states.has(propName);\n            },\n            set(_, propName, value) {\n                set(propName, value);\n                return true;\n            },\n        }));\n    const on = (eventName, callback) => {\n        handlers[eventName].push(callback);\n        return () => {\n            removeFromArray(handlers[eventName], callback);\n        };\n    };\n    const onChange = (propName, cb) => {\n        const setHandler = (key, newValue) => {\n            if (key === propName) {\n                cb(newValue);\n            }\n        };\n        const resetHandler = () => cb(unwrap(defaultState)[propName]);\n        // Register the handlers\n        const unSet = on('set', setHandler);\n        const unReset = on('reset', resetHandler);\n        // Track the relationship between the user callback and internal handlers\n        changeListeners.set(cb, { setHandler, resetHandler, propName });\n        return () => {\n            unSet();\n            unReset();\n            changeListeners.delete(cb);\n        };\n    };\n    const use = (...subscriptions) => {\n        const unsubs = subscriptions.reduce((unsubs, subscription) => {\n            if (subscription.set) {\n                unsubs.push(on('set', subscription.set));\n            }\n            if (subscription.get) {\n                unsubs.push(on('get', subscription.get));\n            }\n            if (subscription.reset) {\n                unsubs.push(on('reset', subscription.reset));\n            }\n            if (subscription.dispose) {\n                unsubs.push(on('dispose', subscription.dispose));\n            }\n            return unsubs;\n        }, []);\n        return () => unsubs.forEach((unsub) => unsub());\n    };\n    const forceUpdate = (key) => {\n        const oldValue = states.get(key);\n        handlers.set.forEach((cb) => cb(key, oldValue, oldValue));\n    };\n    const removeListener = (propName, listener) => {\n        const listenerInfo = changeListeners.get(listener);\n        if (listenerInfo && listenerInfo.propName === propName) {\n            // Remove the specific handlers that were created for this listener\n            removeFromArray(handlers.set, listenerInfo.setHandler);\n            removeFromArray(handlers.reset, listenerInfo.resetHandler);\n            changeListeners.delete(listener);\n        }\n    };\n    return {\n        state,\n        get,\n        set,\n        on,\n        onChange,\n        use,\n        dispose,\n        reset,\n        forceUpdate,\n        removeListener,\n    };\n};\nconst removeFromArray = (array, item) => {\n    const index = array.indexOf(item);\n    if (index >= 0) {\n        array[index] = array[array.length - 1];\n        array.length--;\n    }\n};\n\nconst createStore = (defaultState, shouldUpdate) => {\n    const map = createObservableMap(defaultState, shouldUpdate);\n    map.use(stencilSubscription());\n    return map;\n};\n\nexport { createObservableMap, createStore };\n","/**\n * Store Update Coordinator\n * Prevents UI flickering by implementing smart state diffing and debounced updates\n */\n\nimport { createStore } from '@stencil/store';\n\nexport interface StateChanges {\n  [key: string]: {\n    oldValue: unknown;\n    newValue: unknown;\n    hasChanged: boolean;\n  };\n}\n\nexport interface StoreUpdateOptions {\n  debounceMs?: number;\n  deepCompare?: boolean;\n  skipFields?: string[];\n  forceUpdate?: boolean;\n}\n\nexport class StoreUpdateCoordinator {\n  private pendingUpdates = new Map<string, {\n    timer: number;\n    updateFn: () => void;\n    options: StoreUpdateOptions;\n  }>();\n\n  private stateSnapshots = new Map<string, Record<string, unknown>>();\n\n  /**\n   * Deep compare two values to check if they're actually different\n   */\n  private deepEquals(a: unknown, b: unknown): boolean {\n    if (a === b) return true;\n\n    if (a === null || b === null || a === undefined || b === undefined) {\n      return a === b;\n    }\n\n    if (typeof a !== typeof b) return false;\n\n    if (typeof a === 'object') {\n      if (Array.isArray(a) !== Array.isArray(b)) return false;\n\n      if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) return false;\n        return a.every((item, index) => this.deepEquals(item, b[index]));\n      }\n\n      const aKeys = Object.keys(a as Record<string, unknown>);\n      const bKeys = Object.keys(b as Record<string, unknown>);\n\n      if (aKeys.length !== bKeys.length) return false;\n\n      return aKeys.every(key =>\n        bKeys.includes(key) &&\n        this.deepEquals(\n          (a as Record<string, unknown>)[key],\n          (b as Record<string, unknown>)[key]\n        )\n      );\n    }\n\n    return false;\n  }\n\n  /**\n   * Create a checksum for quick comparison\n   */\n  private createChecksum(data: unknown): string {\n    try {\n      const str = JSON.stringify(data, Object.keys(data as object).sort());\n      let hash = 0;\n      for (let i = 0; i < str.length; i++) {\n        const char = str.charCodeAt(i);\n        hash = ((hash << 5) - hash) + char;\n        hash = hash & hash; // Convert to 32-bit integer\n      }\n      return hash.toString(36);\n    } catch {\n      return Math.random().toString(36);\n    }\n  }\n\n  /**\n   * Compare current state with previous state to detect changes\n   */\n  private detectChanges(\n    storeId: string,\n    currentState: Record<string, unknown>,\n    options: StoreUpdateOptions\n  ): StateChanges {\n    const previousState = this.stateSnapshots.get(storeId) || {};\n    const changes: StateChanges = {};\n    const skipFields = new Set(options.skipFields || []);\n\n    for (const [key, newValue] of Object.entries(currentState)) {\n      if (skipFields.has(key)) continue;\n\n      const oldValue = previousState[key];\n      const hasChanged = options.deepCompare\n        ? !this.deepEquals(oldValue, newValue)\n        : oldValue !== newValue;\n\n      changes[key] = {\n        oldValue,\n        newValue,\n        hasChanged\n      };\n    }\n\n    return changes;\n  }\n\n  /**\n   * Determine if an update should proceed based on changes\n   */\n  private shouldUpdate(changes: StateChanges, options: StoreUpdateOptions): boolean {\n    if (options.forceUpdate) return true;\n\n    // Check if any significant changes occurred\n    return Object.values(changes).some(change => change.hasChanged);\n  }\n\n  /**\n   * Schedule a store update with debouncing and change detection\n   */\n  scheduleUpdate(\n    storeId: string,\n    getCurrentState: () => Record<string, unknown>,\n    updateFn: () => void,\n    options: StoreUpdateOptions = {}\n  ): void {\n    // Clear existing timer\n    const existing = this.pendingUpdates.get(storeId);\n    if (existing) {\n      clearTimeout(existing.timer);\n    }\n\n    const finalOptions: StoreUpdateOptions = {\n      debounceMs: 100,\n      deepCompare: true,\n      skipFields: ['loading', 'error', 'lastUpdated'], // Common fields that change frequently\n      ...options\n    };\n\n    // If no debounce, execute immediately with change detection\n    if (finalOptions.debounceMs === 0) {\n      this.executeUpdate(storeId, getCurrentState, updateFn, finalOptions);\n      return;\n    }\n\n    // Schedule debounced update\n    const timer = window.setTimeout(() => {\n      this.executeUpdate(storeId, getCurrentState, updateFn, finalOptions);\n      this.pendingUpdates.delete(storeId);\n    }, finalOptions.debounceMs);\n\n    this.pendingUpdates.set(storeId, {\n      timer,\n      updateFn,\n      options: finalOptions\n    });\n  }\n\n  /**\n   * Execute the actual update with change detection\n   */\n  private executeUpdate(\n    storeId: string,\n    getCurrentState: () => Record<string, unknown>,\n    updateFn: () => void,\n    options: StoreUpdateOptions\n  ): void {\n    const currentState = getCurrentState();\n    const changes = this.detectChanges(storeId, currentState, options);\n\n    // Only proceed if there are actual changes\n    if (this.shouldUpdate(changes, options)) {\n      console.log(`🔄 Store update [${storeId}]:`, {\n        changedFields: Object.keys(changes).filter(key => changes[key].hasChanged),\n        totalFields: Object.keys(changes).length\n      });\n\n      updateFn();\n\n      // Update snapshot\n      this.stateSnapshots.set(storeId, { ...currentState });\n    } else {\n      console.log(`⏭️ Store update skipped [${storeId}]: No significant changes detected`);\n    }\n  }\n\n  /**\n   * Force an immediate update bypassing all checks\n   */\n  forceUpdate(\n    storeId: string,\n    getCurrentState: () => Record<string, unknown>,\n    updateFn: () => void\n  ): void {\n    this.executeUpdate(storeId, getCurrentState, updateFn, { forceUpdate: true });\n  }\n\n  /**\n   * Clear pending updates for a store\n   */\n  clearPendingUpdates(storeId: string): void {\n    const pending = this.pendingUpdates.get(storeId);\n    if (pending) {\n      clearTimeout(pending.timer);\n      this.pendingUpdates.delete(storeId);\n    }\n  }\n\n  /**\n   * Clear all pending updates\n   */\n  clearAllPendingUpdates(): void {\n    for (const [storeId] of this.pendingUpdates) {\n      this.clearPendingUpdates(storeId);\n    }\n  }\n\n  /**\n   * Get information about pending updates\n   */\n  getPendingUpdates(): string[] {\n    return Array.from(this.pendingUpdates.keys());\n  }\n\n  /**\n   * Cleanup - call when the coordinator is no longer needed\n   */\n  destroy(): void {\n    this.clearAllPendingUpdates();\n    this.stateSnapshots.clear();\n  }\n}\n\n// Global coordinator instance\nexport const storeUpdateCoordinator = new StoreUpdateCoordinator();\n\n/**\n * Enhanced store wrapper that provides automatic change detection and debouncing\n */\nexport function createSmartStore<T extends Record<string, unknown>>(\n  initialState: T,\n  storeId: string,\n  options: StoreUpdateOptions = {}\n): {\n  state: T;\n  onChange: (key: keyof T | '*', fn: () => void) => () => void;\n  reset: () => void;\n  dispose: () => void;\n  updateState: (updates: Partial<T>, updateOptions?: StoreUpdateOptions) => void;\n  setField: <K extends keyof T>(field: K, value: T[K], updateOptions?: StoreUpdateOptions) => void;\n  forceUpdate: (updates: Partial<T>) => void;\n  batchUpdate: (updateFn: (state: T) => void, updateOptions?: StoreUpdateOptions) => void;\n} {\n  const { state, onChange, reset, dispose } = createStore(initialState);\n\n  // Track the original onChange behavior\n  const originalOnChange = onChange;\n\n  const smartActions = {\n    updateState: (updates: Partial<T>, updateOptions?: StoreUpdateOptions) => {\n      const finalOptions = { ...options, ...updateOptions };\n\n      storeUpdateCoordinator.scheduleUpdate(\n        storeId,\n        () => state as Record<string, unknown>,\n        () => {\n          Object.assign(state, updates);\n        },\n        finalOptions\n      );\n    },\n\n    setField: <K extends keyof T>(field: K, value: T[K], updateOptions?: StoreUpdateOptions) => {\n      smartActions.updateState({ [field]: value } as unknown as Partial<T>, updateOptions);\n    },\n\n    forceUpdate: (updates: Partial<T>) => {\n      storeUpdateCoordinator.forceUpdate(\n        storeId,\n        () => state as Record<string, unknown>,\n        () => {\n          Object.assign(state, updates);\n        }\n      );\n    },\n\n    batchUpdate: (updateFn: (state: T) => void, updateOptions?: StoreUpdateOptions) => {\n      const finalOptions = { ...options, ...updateOptions };\n\n      storeUpdateCoordinator.scheduleUpdate(\n        storeId,\n        () => state as Record<string, unknown>,\n        () => updateFn(state),\n        finalOptions\n      );\n    }\n  };\n\n  return {\n    state,\n    onChange: originalOnChange,\n    reset,\n    dispose: () => {\n      storeUpdateCoordinator.clearPendingUpdates(storeId);\n      dispose();\n    },\n    ...smartActions\n  };\n}\n\n/**\n * Utility to wrap existing stores with smart update capabilities\n */\nexport function wrapStoreWithSmartUpdates<T extends Record<string, unknown>>(\n  store: { state: T; onChange: (key: keyof T | '*', fn: () => void) => () => void },\n  storeId: string,\n  options: StoreUpdateOptions = {}\n) {\n  return {\n    ...store,\n    smartUpdate: (updates: Partial<T>, updateOptions?: StoreUpdateOptions) => {\n      const finalOptions = { ...options, ...updateOptions };\n\n      storeUpdateCoordinator.scheduleUpdate(\n        storeId,\n        () => store.state as Record<string, unknown>,\n        () => {\n          Object.assign(store.state, updates);\n        },\n        finalOptions\n      );\n    },\n\n    smartSetField: <K extends keyof T>(field: K, value: T[K], updateOptions?: StoreUpdateOptions) => {\n      const finalOptions = { ...options, ...updateOptions };\n\n      storeUpdateCoordinator.scheduleUpdate(\n        storeId,\n        () => store.state as Record<string, unknown>,\n        () => {\n          store.state[field] = value;\n        },\n        finalOptions\n      );\n    }\n  };\n}\n","import { createStore } from '@stencil/store';\nimport type { EuclidChainConfig, TokenMetadata, PoolInfo } from '../utils/types/api.types';\nimport type { MarketState } from '../utils/types/euclid-api.types';\nimport type { BaseStore } from './types';\nimport { wrapStoreWithSmartUpdates } from '../utils/store-update-coordinator';\n\nconst initialState: MarketState = {\n  chains: [],\n  tokens: [],\n  pools: [],\n  prices: {},\n  loading: false,\n  error: null,\n  lastUpdated: 0,\n  lastChainsUpdate: 0,\n  lastTokensUpdate: 0,\n};\n\nconst { state, onChange, reset, dispose } = createStore(initialState);\n\n// Wrap the store with smart update capabilities\nconst smartStore = wrapStoreWithSmartUpdates(\n  { state, onChange },\n  'market-store',\n  {\n    debounceMs: 150, // Debounce updates for 150ms\n    deepCompare: true,\n    skipFields: ['loading', 'error'] // Don't debounce loading/error changes\n  }\n);\n\n// Actions with smart updates to prevent flickering\nconst actions = {\n  setLoading(loading: boolean) {\n    // Loading state should update immediately (not debounced)\n    state.loading = loading;\n  },\n\n  setError(error: string | null) {\n    // Error state should update immediately (not debounced)\n    state.error = error;\n  },\n\n  // Immediate update methods for initial data loads\n  setChains(chains: EuclidChainConfig[]) {\n    // Use immediate update to ensure UI gets data quickly\n    state.chains = [...chains];\n    state.lastChainsUpdate = Date.now();\n    state.lastUpdated = Date.now();\n  },\n\n  setTokens(tokens: TokenMetadata[]) {\n    // Use immediate update to ensure UI gets data quickly\n    state.tokens = [...tokens];\n    state.lastTokensUpdate = Date.now();\n    state.lastUpdated = Date.now();\n  },  setPools(pools: PoolInfo[]) {\n    // Use immediate update to ensure UI gets data quickly\n    state.pools = [...pools];\n    state.lastUpdated = Date.now();\n  },\n\n  setPrices(prices: Record<string, number>) {\n    // Use immediate update for price changes\n    state.prices = { ...prices };\n    state.lastUpdated = Date.now();\n  },\n\n  // Smart update methods for incremental/polling updates\n  updateChainsSmartly(chains: EuclidChainConfig[]) {\n    smartStore.smartUpdate({\n      chains: [...chains],\n      lastUpdated: Date.now(),\n    });\n  },\n\n  updateTokensSmartly(tokens: TokenMetadata[]) {\n    smartStore.smartUpdate({\n      tokens: [...tokens],\n      lastUpdated: Date.now(),\n    });\n  },\n\n  updatePoolsSmartly(pools: PoolInfo[]) {\n    smartStore.smartUpdate({\n      pools: [...pools],\n      lastUpdated: Date.now(),\n    });\n  },\n\n  addToken(token: TokenMetadata) {\n    // Use smart update for incremental changes (can be debounced)\n    smartStore.smartUpdate({\n      tokens: [...state.tokens, token],\n    }, { debounceMs: 0 });\n  },\n\n  updateToken(tokenId: string, updates: Partial<TokenMetadata>) {\n    // Use smart update for incremental changes (can be debounced)\n    smartStore.smartUpdate({\n      tokens: state.tokens.map(token =>\n        token.id === tokenId ? { ...token, ...updates } : token\n      ),\n    }, { debounceMs: 0 });\n  },\n\n  clear() {\n    reset();\n  },\n};\n\n// Getters\nconst getters = {\n  getChain: (chainUID: string) =>\n    state.chains.find(chain => chain.chain_uid === chainUID),\n\n  getToken: (tokenId: string) =>\n    state.tokens.find(token => token.id === tokenId),\n\n  getTokensByChain: (chainUID: string) =>\n    state.tokens.filter(token => token.chain_uid === chainUID),\n\n  getPool: (poolId: string) =>\n    state.pools.find(pool => pool.pool_id === poolId),\n\n  getPoolsForTokenPair: (token1: string, token2: string) =>\n    state.pools.filter(pool =>\n      (pool.token_1 === token1 && pool.token_2 === token2) ||\n      (pool.token_1 === token2 && pool.token_2 === token1)\n    ),\n\n  getPrice: (tokenId: string) =>\n    state.prices[tokenId] || 0,\n\n  isDataStale: (maxAge: number = 5 * 60 * 1000) => { // 5 minutes default\n    if (!state.lastUpdated) return true;\n    return Date.now() - state.lastUpdated > maxAge;\n  },\n\n  isChainsStale: (maxAge: number = 5 * 60 * 1000) => {\n    if (!state.lastChainsUpdate) return true;\n    return Date.now() - state.lastChainsUpdate > maxAge;\n  },\n\n  isTokensStale: (maxAge: number = 5 * 60 * 1000) => {\n    if (!state.lastTokensUpdate) return true;\n    return Date.now() - state.lastTokensUpdate > maxAge;\n  },\n};\n\n// Proper store type definition extending BaseStore\nexport interface MarketStore extends BaseStore<MarketState> {\n  setLoading: (loading: boolean) => void;\n  setError: (error: string | null) => void;\n  setChains: (chains: EuclidChainConfig[]) => void;\n  setTokens: (tokens: TokenMetadata[]) => void;\n  setPools: (pools: PoolInfo[]) => void;\n  setPrices: (prices: Record<string, number>) => void;\n  addToken: (token: TokenMetadata) => void;\n  updateToken: (tokenId: string, updates: Partial<TokenMetadata>) => void;\n  clear: () => void;\n  getChain: (chainUID: string) => EuclidChainConfig | undefined;\n  getToken: (tokenId: string) => TokenMetadata | undefined;\n  getTokensByChain: (chainUID: string) => TokenMetadata[];\n  getPool: (poolId: string) => PoolInfo | undefined;\n  getPoolsForTokenPair: (token1: string, token2: string) => PoolInfo[];\n  getPrice: (tokenId: string) => number;\n  isDataStale: (maxAge?: number) => boolean;\n  isChainsStale: (maxAge?: number) => boolean;\n  isTokensStale: (maxAge?: number) => boolean;\n}\n\nexport const marketStore: MarketStore = {\n  state,\n  onChange,\n  reset,\n  dispose,\n  ...actions,\n  ...getters,\n};\n\n// Expose store globally for debugging and testing\nif (typeof window !== 'undefined') {\n  (window as unknown as { marketStore: MarketStore }).marketStore = marketStore;\n}\n\nexport type { MarketState, EuclidChainConfig, TokenMetadata, PoolInfo };\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}