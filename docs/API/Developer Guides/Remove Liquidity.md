---
sidebar_position: 7
---
import Tabs from '@site/src/components/Tabs';

# Remove Liquidity
To withdraw liquidity from a pool, a remove liquidity transaction needs to be generated by calling the `Liquidity Remove` endpoint in the Rest API and then broadcast to a chain. 

The [Remove Liquidity](../REST/Transactions/Remove%20Liquidity.md) parameters are the following:

```bash
pair
lp_allocation
timeout
cross_chain_addresses
```
We will go through all the steps needed to get each of the parameters.

## Steps

The following steps describe the workflow to remove liquidity from a pool using the Euclid Layer:

### 1. Get all available pools

The first step of the process will be retrieving all the available VLP. This can be done using the [All VLPS](../GQL/Router/All%20VLPs.md) query:

:::note
You can use pagination to iterate through all the pools as you like.
:::

```graphql
query All_vlps {
  router {
    all_vlps {
      vlps {
        vlp
        token_1
        token_2
      }
    }
  }
}
```
This will return all the available pools in the Euclid Layer:

```JSON
{
  "data": {
    "router": {
      "all_vlps": {
        "vlps": [
          {
            "vlp": "nibi1qyhzzpkqysyvra3g88ady5af2532kd2e8l987n6m0r9ca2vm280q0wz02r",
            "token_1": "axs",
            "token_2": "ron"
          },
          {
            "vlp": "nibi13tdnxhwexkj528dke4hhduraus6w58yzl3mcxk5p2wtfmu8pj2sslx9mgx",
            "token_1": "bnb",
            "token_2": "euclid"
          },
          {
            "vlp": "nibi1wu3y423gmdv8ytkc6q2d0hwen7pmhm9rd39rxw70hde0txgd8gzqsz9ng8",
            "token_1": "eth",
            "token_2": "euclid"
          },
          {
            "vlp": "nibi17e5uq086kxlav8s2gpr6qlezfv9qsaeeaar2m58z2j4ue7qczgws3hydp9",
            "token_1": "eth",
            "token_2": "sp500"
          },
          {
            "vlp": "nibi156qtenwsr08g8kw3qwm3teg73sgg4arvjfc4nrwcs4j2vccjy28qx848js",
            "token_1": "eth",
            "token_2": "usdc"
          },
          {
            "vlp": "nibi1w0dywahjxpqhgv5jgclupq58my228cexuwgj7zfr6gleapuheedqys0sl5",
            "token_1": "eth",
            "token_2": "usdt"
          }
        ]
      }
    }
  }
}
```
Using this data, you can prompt the user to select the pool they wish to remove liquidity from. You will also need the address of the VLP, so make sure to keep that saved.

### 2. Select the chain to remove liquidity from

Now that weâ€™ve selected the token pair for withdrawing liquidity, the next step is to identify the available chains where this pair is supported for liquidity withdrawal. This can be done using the [All Pools](../GQL/VLP/All%20Pools.md) query:

:::note
Use the contract address of the VLP contract for the token pair selected by the user.
:::

```graphql
query Vlp($contract: String!) {
  vlp(contract: $contract) {
    all_pools {
      pools {
        chain_uid
        pool {
          reserve_1
          reserve_2
          lp_shares
        }
      }
    }
  }
}
```
The response will retrieve the chains where this pair exists (`eth-euclid` in this example):

```JSON
{
  "data": {
    "vlp": {
      "all_pools": {
        "pools": [
          {
            "chain_uid": "arbitrum",
            "pool": {
              "reserve_1": "3052595291791029289",
              "reserve_2": "4105362908",
              "lp_shares": "88591197298970"
            }
          },
          {
            "chain_uid": "base",
            "pool": {
              "reserve_1": "16603608176937143257",
              "reserve_2": "22329798298",
              "lp_shares": "481863262985903"
            }
          },
          {
            "chain_uid": "manta",
            "pool": {
              "reserve_1": "132357131471934793",
              "reserve_2": "178003962",
              "lp_shares": "3841215630414"
            }
          },
          {
            "chain_uid": "optimism",
            "pool": {
              "reserve_1": "5810647211079423950",
              "reserve_2": "7814601430",
              "lp_shares": "168634274872847"
            }
          },
          {
            "chain_uid": "scroll",
            "pool": {
              "reserve_1": "2491975658960022483",
              "reserve_2": "3351398878",
              "lp_shares": "72321118970746"
            }
          },
          {
            "chain_uid": "sepolia",
            "pool": {
              "reserve_1": "14764746867692563426",
              "reserve_2": "19856757397",
              "lp_shares": "428496566951609"
            }
          }
        ]
      }
    }
  }
}
```
:::note
The user will only be able to withdraw liquidity from the pools they have added liquidity to in the past. 
:::

The user can select the chain they wish to withdraw from. 

### 3. Get the contract address for the LP tokens

The third step will be getting the contract address for the LP tokens that were transferred to the user when liquidity was added. This address can be fetched using the [Get Token Address](../GQL/Factory/Get%20Token%20Address.md) query:

```graphql
query Factory($chainUid: String!, $vlpAddress: String!) {
  factory(chain_uid: $chainUid) {
    get_LpToken_address(vlp_address: $vlpAddress) {
      token_address
    }
  }
}
```
The response will return the CW20 contract address of the LP tokens.

```JSON
{
  "data": {
    "factory": {
      "get_LpToken_address": {
        "token_address": "0x03Ed5843ED3BB20268b5e437CfeFfa571C66b7fA"
      }
    }
  }
}
```

### 4. Check the user's balance and select the amount to wihtdraw

Before prompting the user to specify the amount to withdraw, we have to get the balance of LP tokens for the user to make sure they do not try to withdraw an amount they do not have. The balance can be fetched using the [CW20 Balance](../GQL/CW/Balance.md) query:

:::tip
Use the connected wallet for the address field.
:::

```graphql
query Cw($contract: String!, $chainUid: String!, $address: String!) {
  cw(contract: $contract, chain_uid: $chainUid) {
    balance(address: $address) {
      balance
    }
  }
}
```
The response will return the amount of LP tokens the user has:

```JSON
{
  "data": {
    "cw": {
      "balance": {
        "balance": "10000019998932"
      }
    }
  }
}
```
Now when the user specifies the amount, you can do a check to make sure the amount does not exceed their balance.

### 5. Generate Remove Liquidity transaction

:::note
- Use the responses we got in all the previous steps for the fields.
- For sender address and chain_uid use the ones from the connected chain. In the example below, we are using a Keplr wallet.
- The `cross_chain_addresses` are taken as an input from the user. The addresses for different chains can be fetched from the wallet using the chain Id.
:::

<Tabs
  tabs={[
    {
      id: 'cosmwasm-remove-liquidity-js',
      label: 'CosmWasm',
      language: 'javascript',
      content: `const msg = await axios.post("https://testnet.api.euclidprotocol.com/api/v1/execute/liquidity/remove", {
  lp_allocation: data.lp_allocation, // Amount of LP tokens to remove
  vlp_address: data.vlp_address, // Address of the LP token contract
  sender: {
    address: wallet!.bech32Address,
    chain_uid: chain!.chain_uid,
  },
}).then((res) => res.data as TxResult);`
    },
    {
      id: 'evm-remove-liquidity-js',
      label: 'EVM',
      language: 'javascript',
      content: `const msg = await axios.post("https://testnet.api.euclidprotocol.com/api/v1/execute/liquidity/remove", {
  lp_allocation: data.lp_allocation,
  vlp_address: data.vlp_address,
  sender: {
    address: walletAddress,
    chain_uid: chainUid
  }
}).then((res) => res.data);`
    }
  ]}
/>


### 6. Broadcast the transaction to chain

The final step will be broadcasting this transaction to the chain and signing it with the connected wallet:

<Tabs
  tabs={[
    {
      id: 'cosmos-remove-broadcast',
      label: 'CosmWasm',
      language: 'javascript',
      content: `const tx = await client!.executeMultiple(
  wallet!.bech32Address,
  msg.msgs,
  "auto",
  "Remove Liquidity"
);
return tx;`
    },
    {
      id: 'evm-remove-broadcast',
      label: 'EVM',
      language: 'javascript',
      content: `const provider = new ethers.providers.Web3Provider(window.ethereum);
const signer = provider.getSigner();

// Construct the transaction data
const tx = {
  to: msg.msgs[0].to, // Contract address
  data: msg.msgs[0].data, // Encoded calldata
  value: msg.msgs[0].value || "0x0"
};

// Send transaction using signer (e.g. MetaMask)
const receipt = await signer.sendTransaction(tx);

// Optional: Wait for confirmation
const confirmed = await receipt.wait();
return confirmed;`
    }
  ]}
/>



