import{D as n}from"./p-9CRWQAc1.js";async function t(t,e,o){const i={...n,...o};const s=new AbortController;const a=setTimeout((()=>s.abort()),i.apiTimeout);try{const n=await fetch(i.graphqlEndpoint,{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({query:t,variables:e}),signal:s.signal});clearTimeout(a);if(!n.ok){throw new Error(`HTTP ${n.status}: ${n.statusText}`)}const o=await n.json();if(o.errors){throw new Error(`GraphQL errors: ${o.errors.map((n=>n.message)).join(", ")}`)}return o.data}catch(n){clearTimeout(a);const t=n instanceof Error?n.message:"Unknown error";throw new Error(`Router query failed: ${t}`)}}async function e(){const n=`\n    query Router {\n      router {\n        all_chains {\n          factory_address\n          chain_id\n          chain_uid\n        }\n      }\n    }\n  `;const e=await t(n);return e.router.all_chains}async function o(n,e){const o=`\n    query All_escrows($limit: Int, $offset: Int) {\n      router {\n        all_escrows(limit: $limit, offset: $offset) {\n          escrows {\n            escrow_address\n            token_id\n            chain_uid\n            balance\n            denoms\n          }\n          pagination {\n            total_count\n            limit\n            offset\n          }\n        }\n      }\n    }\n  `;const i=await t(o,{limit:n,offset:e});return i.router.all_escrows}async function i(n,e){const o=`\n    query All_tokens($limit: Int, $offset: Int) {\n      router {\n        all_tokens(limit: $limit, offset: $offset) {\n          tokens {\n            token_id\n            display_name\n            type\n            denoms\n            chains\n          }\n          pagination {\n            total_count\n            limit\n            offset\n          }\n        }\n      }\n    }\n  `;const i=await t(o,{limit:n,offset:e});return i.router.all_tokens}async function s(n,e){const o=`\n    query All_vlps($limit: Int, $offset: Int) {\n      router {\n        all_vlps(limit: $limit, offset: $offset) {\n          vlps {\n            vlp_address\n            pair {\n              token_1\n              token_2\n            }\n            total_liquidity\n            chains\n          }\n          pagination {\n            total_count\n            limit\n            offset\n          }\n        }\n      }\n    }\n  `;const i=await t(o,{limit:n,offset:e});return i.router.all_vlps}async function a(n){const e=`\n    query Chain($chainUid: String!) {\n      router {\n        chain(chain_uid: $chainUid) {\n          chain_uid\n          display_name\n          type\n          status\n          router_address\n          factory_address\n          supported_tokens\n        }\n      }\n    }\n  `;const o=await t(e,{chainUid:n});return o.router.chain}async function r(n,e,o){const i=`\n    query Escrows($chainUid: String!, $limit: Int, $offset: Int) {\n      router {\n        escrows(chain_uid: $chainUid, limit: $limit, offset: $offset) {\n          escrows {\n            escrow_address\n            token_id\n            balance\n            denoms\n          }\n          pagination {\n            total_count\n            limit\n            offset\n          }\n        }\n      }\n    }\n  `;const s=await t(i,{chainUid:n,limit:e,offset:o});return s.router.escrows}async function c(n,e){const o=`\n    query Simulate_escrow_release($escrowId: String!, $recipient: String!) {\n      router {\n        simulate_escrow_release(escrow_id: $escrowId, recipient: $recipient) {\n          amount_released\n          fees_paid\n          gas_estimate\n          success\n        }\n      }\n    }\n  `;const i=await t(o,{escrowId:n,recipient:e});return i.router.simulate_escrow_release}async function u(n,e,o,i,s){const a=`\n    query Simulate_swap($assetIn: String!, $amountIn: String!, $assetOut: String!, $minAmountOut: String!, $swaps: [String!]) {\n      router {\n        simulate_swap(asset_in: $assetIn, amount_in: $amountIn, asset_out: $assetOut, min_amount_out: $minAmountOut, swaps: $swaps) {\n          amount_out\n          asset_out\n        }\n      }\n    }\n  `;const r=await t(a,{assetIn:n,amountIn:e,assetOut:o,minAmountOut:i,swaps:s});return r.router.simulate_swap}async function l(){const n=`\n    query State {\n      router {\n        state {\n          admin\n          vlp_code_id\n          virtual_balance_address\n        }\n      }\n    }\n  `;const e=await t(n);return e.router.state}async function _(n){const e=`\n    query Token_denoms($token: String!) {\n      router {\n        token_denoms(token: $token) {\n          denoms {\n            chain_uid\n            token_type {\n              __typename\n            }\n          }\n        }\n      }\n    }\n  `;const o=await t(e,{token:n});return o.router.token_denoms}async function f(n){const e=`\n    query Token_pairs_from_vlp($vlp: String!) {\n      router {\n        token_pairs_from_vlp(vlp: $vlp) {\n          pair {\n            token_1\n            token_2\n          }\n          vlp_address\n        }\n      }\n    }\n  `;const o=await t(e,{vlp:n});return o.router.token_pairs_from_vlp}async function d(n){const e=`\n    query VLP($pair: PairInput!) {\n      router {\n        vlp(pair: $pair) {\n          vlp_address\n          pair {\n            token_1\n            token_2\n          }\n          total_liquidity\n          chains\n          status\n        }\n      }\n    }\n  `;const o=await t(e,{pair:n});return o.router.vlp}export{e as getAllChainsImpl,o as getAllEscrowsImpl,i as getAllTokensImpl,s as getAllVLPsImpl,a as getChainImpl,r as getEscrowsImpl,l as getStateImpl,_ as getTokenDenomsImpl,f as getTokenPairFromVLPImpl,d as getVLPImpl,c as simulateEscrowReleaseImpl,u as simulateSwapImpl};
//# sourceMappingURL=p-Db2wm2T2.js.map