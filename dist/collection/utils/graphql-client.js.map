{"version":3,"file":"graphql-client.js","sourceRoot":"","sources":["../../src/utils/graphql-client.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  EuclidChainConfig,\n  TokenMetadata,\n  PoolInfo,\n  UserBalance,\n  CrossChainUser,\n  ChainsQueryResponse,\n  TokenMetadataQueryResponse,\n  UserBalanceQueryResponse,\n  ApiResponse\n} from './types/api.types';\n\n// GraphQL endpoint for Euclid testnet\nconst EUCLID_GRAPHQL_ENDPOINT = 'https://testnet.api.euclidprotocol.com/graphql';\n\n/**\n * GraphQL client for Euclid Protocol\n * Handles all GraphQL queries to the Euclid API\n */\nexport class EuclidGraphQLClient {\n  private endpoint: string;\n\n  constructor(endpoint: string = EUCLID_GRAPHQL_ENDPOINT) {\n    this.endpoint = endpoint;\n  }\n\n  /**\n   * Execute a GraphQL query\n   */\n  private async query<T>(query: string, variables?: Record<string, unknown>): Promise<ApiResponse<T>> {\n    try {\n      const response = await fetch(this.endpoint, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Accept': 'application/json',\n        },\n        body: JSON.stringify({\n          query,\n          variables: variables || {},\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const result = await response.json();\n\n      if (result.errors) {\n        throw new Error(`GraphQL error: ${result.errors.map((e: { message: string }) => e.message).join(', ')}`);\n      }\n\n      return {\n        success: true,\n        data: result.data,\n      };\n    } catch (error) {\n      console.error('GraphQL query failed:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  /**\n   * Get all supported chains\n   */\n  async getChains(variables?: { showAllChains?: boolean; type?: string }): Promise<EuclidChainConfig[]> {\n    const query = `\n      query Chains($showAllChains: Boolean, $type: String) {\n        chains {\n          all_chains(show_all_chains: $showAllChains, type: $type) {\n            chain_id\n            chain_uid\n            display_name\n            factory_address\n            token_factory_address\n            explorer_url\n            logo\n            type\n          }\n        }\n      }\n    `;\n\n    const result = await this.query<ChainsQueryResponse>(query, variables);\n\n    if (!result.success || !result.data) {\n      throw new Error(result.error || 'Failed to fetch chains');\n    }\n\n    return result.data.chains.all_chains;\n  }\n\n  /**\n   * Get token metadata\n   */\n  async getTokenMetadata(variables?: {\n    limit?: number;\n    offset?: number;\n    verified?: boolean;\n    dex?: string[];\n    chainUids?: string[];\n    showVolume?: boolean;\n    search?: string;\n  }): Promise<TokenMetadata[]> {\n    const query = `\n      query Token(\n        $limit: Int,\n        $offset: Int,\n        $verified: Boolean,\n        $dex: [String!],\n        $chainUids: [String!],\n        $showVolume: Boolean,\n        $search: String\n      ) {\n        token {\n          token_metadatas(\n            limit: $limit,\n            offset: $offset,\n            verified: $verified,\n            dex: $dex,\n            chain_uids: $chainUids,\n            show_volume: $showVolume,\n            search: $search\n          ) {\n            coinDecimal\n            displayName\n            tokenId\n            description\n            image\n            price\n            price_change_24h\n            price_change_7d\n            dex\n            chain_uids\n            total_volume\n            total_volume_24h\n            tags\n            min_swap_value\n            social\n            is_verified\n          }\n        }\n      }\n    `;\n\n    const result = await this.query<TokenMetadataQueryResponse>(query, variables);\n\n    if (!result.success || !result.data) {\n      throw new Error(result.error || 'Failed to fetch token metadata');\n    }\n\n    return result.data.token.token_metadatas;\n  }\n\n  /**\n   * Get all liquidity pools with proper TVL and APR data\n   * @param chainUid - Optional chain filter (unused for now)\n   * @param onlyVerified - Whether to show only verified pools (default: true)\n   */\n  async getAllPools(_chainUid?: string, onlyVerified: boolean = true): Promise<PoolInfo[]> {\n    try {\n      const query = `\n        query Token_pair_with_liquidity($limit: Int, $onlyShowVerified: Boolean) {\n          pool {\n            token_pair_with_liquidity(limit: $limit, only_show_verified: $onlyShowVerified) {\n              results {\n                pair {\n                  token_1\n                  token_2\n                }\n                vlp\n                total_liquidity\n                apr\n                tags\n                created_at\n              }\n              pagination {\n                total_count\n                limit\n                offset\n              }\n            }\n          }\n        }\n      `;\n\n      const result = await this.query<{\n        pool: {\n          token_pair_with_liquidity: {\n            results: Array<{\n              pair: { token_1: string; token_2: string };\n              vlp: string;\n              total_liquidity: string;\n              apr: string;\n              tags: string[] | null;\n              created_at: string;\n            }>;\n            pagination: {\n              total_count: number;\n              limit: number;\n              offset: number;\n            };\n          };\n        };\n      }>(query, {\n        limit: 1000,\n        onlyShowVerified: onlyVerified\n      });\n\n      if (!result.success || !result.data?.pool?.token_pair_with_liquidity?.results) {\n        throw new Error(result.error || 'Failed to fetch pools with liquidity data');\n      }\n\n      // Transform the API response to our PoolInfo interface\n      const pools = result.data.pool.token_pair_with_liquidity.results.map((pool) => {\n        return {\n          pool_id: `${pool.pair.token_1}-${pool.pair.token_2}`,\n          token_1: pool.pair.token_1,\n          token_2: pool.pair.token_2,\n          total_liquidity: pool.total_liquidity,\n          volume_24h: '0', // This API doesn't provide volume data\n          fees_24h: '0', // This API doesn't provide fees data\n          apr: pool.apr,\n        } satisfies PoolInfo;\n      });\n\n      console.log(`✅ Loaded ${pools.length} pools with real liquidity and APR data from official API`);\n      return pools;\n\n    } catch (error) {\n      console.error('Failed to fetch pools with liquidity data:', error);\n      return [];\n    }\n  }  /**\n   * Get user balances across all chains\n   */\n  async getUserBalances(user: CrossChainUser): Promise<UserBalance[]> {\n    const query = `\n      query Vcoin($user: CrossChainUserInput) {\n        vcoin {\n          user_balance(user: $user) {\n            balances {\n              amount\n              token_id\n            }\n          }\n        }\n      }\n    `;\n\n    const variables = {\n      user: {\n        address: user.address,\n        chain_uid: user.chain_uid,\n      },\n    };\n\n    const result = await this.query<UserBalanceQueryResponse>(query, variables);\n\n    if (!result.success || !result.data) {\n      throw new Error(result.error || 'Failed to fetch user balances');\n    }\n\n    return result.data.vcoin.user_balance.balances;\n  }\n\n  /**\n   * Get pool information for a specific pair\n   */\n  async getPoolInfo(token1: string, token2: string): Promise<PoolInfo | null> {\n    const pools = await this.getAllPools();\n    return pools.find(pool =>\n      (pool.token_1 === token1 && pool.token_2 === token2) ||\n      (pool.token_1 === token2 && pool.token_2 === token1)\n    ) || null;\n  }\n\n  /**\n   * Search tokens by symbol or name\n   */\n    async searchTokens(searchTerm: string, chainUID?: string): Promise<TokenMetadata[]> {\n    const options: Parameters<typeof this.getTokenMetadata>[0] = { search: searchTerm };\n    if (chainUID) {\n      options.chainUids = [chainUID];\n    }\n    const tokens = await this.getTokenMetadata(options);\n\n    const lowerSearchTerm = searchTerm.toLowerCase();\n    return tokens.filter(token =>\n      token.displayName?.toLowerCase().includes(lowerSearchTerm) ||\n      token.tokenId?.toLowerCase().includes(lowerSearchTerm) ||\n      token.description?.toLowerCase().includes(lowerSearchTerm) ||\n      // Legacy field fallbacks\n      token.symbol?.toLowerCase().includes(lowerSearchTerm) ||\n      token.name?.toLowerCase().includes(lowerSearchTerm)\n    );\n  }\n\n  /**\n   * Get token by symbol and chain\n   */\n  async getTokenBySymbol(symbol: string, chainUID: string): Promise<TokenMetadata | null> {\n    const tokens = await this.getTokenMetadata({ chainUids: [chainUID] });\n    // Use displayName (symbol equivalent) for comparison, with fallback to legacy fields\n    return tokens.find(token =>\n      token.displayName?.toLowerCase() === symbol.toLowerCase() ||\n      token.symbol?.toLowerCase() === symbol.toLowerCase()\n    ) || null;\n  }\n}\n\n// Export a default instance\nexport const euclidGraphQLClient = new EuclidGraphQLClient();\n"]}