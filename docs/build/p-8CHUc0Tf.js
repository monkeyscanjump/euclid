import{c as t,w as n}from"./p-DWrf3bWA.js";class e{constructor(){this.type="metamask"}isAvailable(){return typeof window!=="undefined"&&Boolean(window.ethereum?.isMetaMask)}async connect(t){if(!this.isAvailable()){throw new Error("MetaMask is not installed")}try{const n=await window.ethereum.request({method:"eth_requestAccounts"});if(!n||n.length===0){throw new Error("No accounts found")}const e=await window.ethereum.request({method:"eth_chainId"});if(t&&t!==e){await this.switchChain(t)}return{address:n[0],chainId:t||e}}catch(t){throw new Error(`Failed to connect MetaMask: ${t.message}`)}}async disconnect(){console.log("MetaMask disconnect requested")}async getBalance(t){if(!this.isAvailable()){throw new Error("MetaMask is not available")}try{const n=await window.ethereum.request({method:"eth_getBalance",params:[t,"latest"]});return n}catch(t){throw new Error(`Failed to get balance: ${t.message}`)}}async signAndBroadcast(t){if(!this.isAvailable()){throw new Error("MetaMask is not available")}if(t.type!=="evm"){throw new Error("MetaMask can only handle EVM transactions")}try{const n=await window.ethereum.request({method:"eth_sendTransaction",params:t.msgs.map((n=>({from:t.sender.address,to:n.to,data:n.data,value:n.value,gasLimit:n.gasLimit})))});return n}catch(t){throw new Error(`Failed to send transaction: ${t.message}`)}}async switchChain(t){if(!this.isAvailable()){throw new Error("MetaMask is not available")}try{await window.ethereum.request({method:"wallet_switchEthereumChain",params:[{chainId:t}]})}catch(t){if(t.code===4902){throw new Error("Chain not added to MetaMask. Please add the chain first.")}throw new Error(`Failed to switch chain: ${t.message}`)}}async addChain(t){if(!this.isAvailable()){throw new Error("MetaMask is not available")}if(t.type!=="EVM"){throw new Error("MetaMask only supports EVM chains")}try{await window.ethereum.request({method:"wallet_addEthereumChain",params:[{chainId:t.chain_id,chainName:t.display_name,nativeCurrency:{name:"ETH",symbol:"ETH",decimals:18},rpcUrls:[t.explorer_url],blockExplorerUrls:[t.explorer_url]}]})}catch(t){throw new Error(`Failed to add chain: ${t.message}`)}}}class o{constructor(){this.type="keplr"}isAvailable(){return typeof window!=="undefined"&&Boolean(window.keplr)}async connect(t){if(!this.isAvailable()){throw new Error("Keplr is not installed")}try{const n=t||"cosmoshub-4";await window.keplr.enable(n);const e=window.keplr.getOfflineSigner(n);const o=await e.getAccounts();if(!o||o.length===0){throw new Error("No accounts found")}return{address:o[0].address,chainId:n}}catch(t){throw new Error(`Failed to connect Keplr: ${t.message}`)}}async disconnect(){console.log("Keplr disconnect requested")}async getBalance(t){throw new Error("Balance checking not implemented for Keplr")}async signAndBroadcast(t){if(!this.isAvailable()){throw new Error("Keplr is not available")}if(t.type!=="cosmwasm"){throw new Error("Keplr can only handle CosmWasm transactions")}try{throw new Error("CosmWasm transaction signing not fully implemented")}catch(t){throw new Error(`Failed to send transaction: ${t.message}`)}}async switchChain(t){if(!this.isAvailable()){throw new Error("Keplr is not available")}try{await window.keplr.enable(t)}catch(n){throw new Error(`Failed to switch to chain ${t}: ${n.message}`)}}async addChain(t){if(!this.isAvailable()){throw new Error("Keplr is not available")}if(t.type!=="Cosmwasm"){throw new Error("Keplr only supports Cosmos chains")}try{await window.keplr.experimentalSuggestChain({chainId:t.chain_id,chainName:t.display_name,rpc:t.explorer_url,rest:t.explorer_url,bip44:{coinType:118},bech32Config:{bech32PrefixAccAddr:"cosmos",bech32PrefixAccPub:"cosmospub",bech32PrefixValAddr:"cosmosvaloper",bech32PrefixValPub:"cosmosvaloperpub",bech32PrefixConsAddr:"cosmosvalcons",bech32PrefixConsPub:"cosmosvalconspub"},currencies:[{coinDenom:"ATOM",coinMinimalDenom:"uatom",coinDecimals:6}],feeCurrencies:[{coinDenom:"ATOM",coinMinimalDenom:"uatom",coinDecimals:6}],stakeCurrency:{coinDenom:"ATOM",coinMinimalDenom:"uatom",coinDecimals:6}})}catch(t){throw new Error(`Failed to add chain: ${t.message}`)}}}class a{constructor(){this.type="phantom"}isAvailable(){return typeof window!=="undefined"&&Boolean(window.solana?.isPhantom)}async connect(t){if(!this.isAvailable()){throw new Error("Phantom is not installed")}try{const n=await window.solana.connect();return{address:n.publicKey.toString(),chainId:t||"mainnet-beta"}}catch(t){throw new Error(`Failed to connect Phantom: ${t.message}`)}}async disconnect(){if(this.isAvailable()){await window.solana.disconnect()}}async getBalance(t){throw new Error("Balance checking not implemented for Phantom")}async signAndBroadcast(t){throw new Error("Solana transaction signing not implemented")}async switchChain(t){console.log(`Chain switching not supported by Phantom: ${t}`)}async addChain(t){throw new Error("Adding chains not supported by Phantom")}}class s{constructor(){this.adapters=new Map;this.adapters.set("metamask",new e);this.adapters.set("keplr",new o);this.adapters.set("phantom",new a)}getAdapter(t){const n=this.adapters.get(t);if(!n){throw new Error(`Unsupported wallet type: ${t}`)}return n}getAvailableAdapters(){return Array.from(this.adapters.values()).filter((t=>t.isAvailable()))}getAvailableWalletTypes(){return this.getAvailableAdapters().map((t=>t.type))}}const r=new s;class i{constructor(t="euclid-storage",n={}){this.db=null;this.cryptoKey=null;this.initPromise=null;this.dbName=t;this.version=n.version||1}async init(){if(this.initPromise){return this.initPromise}this.initPromise=this._init();return this.initPromise}async _init(){await Promise.all([this.initDatabase(),this.initCrypto()])}async initDatabase(){return new Promise(((t,n)=>{const e=indexedDB.open(this.dbName,this.version);e.onerror=()=>{n(new Error(`Failed to open database: ${e.error?.message}`))};e.onsuccess=()=>{this.db=e.result;t()};e.onupgradeneeded=t=>{const n=t.target.result;const e=["wallet-data","user-preferences","app-state","cache"];for(const t of e){if(!n.objectStoreNames.contains(t)){const e=n.createObjectStore(t,{keyPath:"key"});e.createIndex("timestamp","timestamp",{unique:false})}}}}))}async initCrypto(){if(!window.crypto?.subtle){console.warn("Web Crypto API not available - storage will not be encrypted");return}try{const t=await this.getStoredCryptoKey();if(!t){this.cryptoKey=await window.crypto.subtle.generateKey({name:"AES-GCM",length:256},true,["encrypt","decrypt"]);await this.storeCryptoKey(this.cryptoKey)}else{this.cryptoKey=await window.crypto.subtle.importKey("jwk",t,{name:"AES-GCM"},true,["encrypt","decrypt"])}}catch(t){console.warn("Failed to initialize encryption:",t)}}async getStoredCryptoKey(){try{const t=localStorage.getItem("euclid-crypto-key");return t?JSON.parse(t):null}catch{return null}}async storeCryptoKey(t){try{const n=await window.crypto.subtle.exportKey("jwk",t);localStorage.setItem("euclid-crypto-key",JSON.stringify(n))}catch(t){console.warn("Failed to store crypto key:",t)}}async encrypt(t){if(!this.cryptoKey||!window.crypto?.subtle){throw new Error("Encryption not available")}const n=window.crypto.getRandomValues(new Uint8Array(12));const e=(new TextEncoder).encode(JSON.stringify(t));const o=await window.crypto.subtle.encrypt({name:"AES-GCM",iv:n.buffer},this.cryptoKey,e);return{encrypted:o,iv:n}}async decrypt(t,n){if(!this.cryptoKey||!window.crypto?.subtle){throw new Error("Decryption not available")}const e=await window.crypto.subtle.decrypt({name:"AES-GCM",iv:n.buffer},this.cryptoKey,t);const o=(new TextDecoder).decode(e);return JSON.parse(o)}async setItem(t,n,e,o={}){await this.init();if(!this.db){throw new Error("Database not initialized")}const a=o.encrypt!==false&&t==="wallet-data";let s=e;let r=false;if(a&&this.cryptoKey){try{const{encrypted:t,iv:n}=await this.encrypt(e);s={data:Array.from(new Uint8Array(t)),iv:Array.from(n)};r=true}catch(t){console.warn("Encryption failed, storing unencrypted:",t)}}const i={key:n,value:s,timestamp:Date.now(),encrypted:r};return new Promise(((n,e)=>{const o=this.db.transaction([t],"readwrite");const a=o.objectStore(t);const s=a.put(i);s.onsuccess=()=>n();s.onerror=()=>e(new Error(`Failed to store item: ${s.error?.message}`))}))}async getItem(t,n){await this.init();if(!this.db){throw new Error("Database not initialized")}return new Promise(((e,o)=>{const a=this.db.transaction([t],"readonly");const s=a.objectStore(t);const r=s.get(n);r.onsuccess=async()=>{const t=r.result;if(!t){e(null);return}if(t.encrypted&&this.cryptoKey){try{const n=t.value;const o=new Uint8Array(n.data);const a=new Uint8Array(n.iv);const s=await this.decrypt(o.buffer,a);e(s)}catch(t){console.error("Decryption failed:",t);e(null)}}else{e(t.value)}};r.onerror=()=>o(new Error(`Failed to retrieve item: ${r.error?.message}`))}))}async removeItem(t,n){await this.init();if(!this.db){throw new Error("Database not initialized")}return new Promise(((e,o)=>{const a=this.db.transaction([t],"readwrite");const s=a.objectStore(t);const r=s.delete(n);r.onsuccess=()=>e();r.onerror=()=>o(new Error(`Failed to remove item: ${r.error?.message}`))}))}async clear(t){await this.init();if(!this.db){throw new Error("Database not initialized")}return new Promise(((n,e)=>{const o=this.db.transaction([t],"readwrite");const a=o.objectStore(t);const s=a.clear();s.onsuccess=()=>n();s.onerror=()=>e(new Error(`Failed to clear store: ${s.error?.message}`))}))}async getAllKeys(t){await this.init();if(!this.db){throw new Error("Database not initialized")}return new Promise(((n,e)=>{const o=this.db.transaction([t],"readonly");const a=o.objectStore(t);const s=a.getAllKeys();s.onsuccess=()=>n(s.result);s.onerror=()=>e(new Error(`Failed to get keys: ${s.error?.message}`))}))}async cleanupCache(t=24*60*60*1e3){await this.init();if(!this.db){throw new Error("Database not initialized")}const n=Date.now()-t;return new Promise(((t,e)=>{const o=this.db.transaction(["cache"],"readwrite");const a=o.objectStore("cache");const s=a.index("timestamp");const r=s.openCursor(IDBKeyRange.upperBound(n));r.onsuccess=n=>{const e=n.target.result;if(e){e.delete();e.continue()}else{t()}};r.onerror=()=>e(new Error(`Failed to cleanup cache: ${r.error?.message}`))}))}close(){if(this.db){this.db.close();this.db=null}this.initPromise=null}}const c=new i;const l={async setConnectedWallets(t){const n=Object.fromEntries(t);return c.setItem("wallet-data","connected-wallets",n,{encrypt:true})},async getConnectedWallets(){const t=await c.getItem("wallet-data","connected-wallets");return t?new Map(Object.entries(t)):new Map},async setAddressBook(t){return c.setItem("wallet-data","address-book",t,{encrypt:true})},async getAddressBook(){return await c.getItem("wallet-data","address-book")||[]},async clearWalletData(){return c.clear("wallet-data")}};async function d(){const t=[{old:"euclid-address-book",new:"address-book",store:"wallet-data"}];for(const n of t){try{const t=localStorage.getItem(n.old);if(t){const e=JSON.parse(t);await c.setItem(n.store,n.new,e);localStorage.removeItem(n.old);console.log(`Migrated ${n.old} to IndexedDB`)}}catch(t){console.warn(`Failed to migrate ${n.old}:`,t)}}}const u={isConnected:false,address:null,chainId:null,chainUID:null,walletType:null,balances:[],loading:false,error:null,connectedWallets:new Map,wallets:new Map};const{state:h,onChange:p,reset:w,dispose:y}=t(u);const m=n({state:h,onChange:p},"wallet-store",{debounceMs:100,deepCompare:true,skipFields:["loading","error"]});const f={setLoading(t){h.loading=t},setError(t){h.error=t},async initialize(){await d();try{const t=await l.getConnectedWallets();if(t.size>0){m.smartUpdate({connectedWallets:t,wallets:t});const n=Array.from(t.values())[0];if(n){m.smartUpdate({isConnected:true,address:n.address,chainUID:n.chainUID,walletType:n.walletType,balances:[...n.balances]})}}}catch(t){console.warn("Failed to load persisted wallets:",t)}console.log("Wallet store initialized")},async connectWallet(t,n){h.loading=true;h.error=null;try{const e=r.getAdapter(t);if(!e.isAvailable()){throw new Error(`${t} wallet is not installed`)}const o=await e.connect(n);h.isConnected=true;h.address=o.address;h.chainId=o.chainId;h.chainUID=o.chainId;h.walletType=t;h.error=null}catch(t){h.error=t instanceof Error?t.message:"Failed to connect wallet"}finally{h.loading=false}},async disconnectWallet(t){if(t){f.removeWallet(t)}else{if(h.walletType){try{const t=r.getAdapter(h.walletType);await t.disconnect()}catch(t){console.warn("Error disconnecting wallet:",t)}}h.isConnected=false;h.address=null;h.chainId=null;h.chainUID=null;h.walletType=null;h.balances=[];h.connectedWallets.clear();h.error=null}},setBalances(t){h.balances=[...t]},updateBalance(t,n){const e=h.balances.findIndex((n=>n.token===t));const o={amount:n,token_id:t,token:t,balance:n,chain_uid:h.chainUID||"",token_type:{native:{denom:t}}};if(e>=0){h.balances[e]=o}else{h.balances.push(o)}},async switchChain(t){if(!h.walletType){throw new Error("No wallet connected")}h.loading=true;h.error=null;try{const n=r.getAdapter(h.walletType);await n.switchChain(t);h.chainId=t;h.chainUID=t;h.error=null}catch(t){h.error=t instanceof Error?t.message:"Failed to switch chain"}finally{h.loading=false}},clear(){w()},addWallet(t,n){const e={...n,chainUID:t,type:n.walletType,name:n.walletType};const o=new Map(h.connectedWallets);o.set(t,e);m.smartUpdate({connectedWallets:o,wallets:o});if(!h.isConnected){m.smartUpdate({isConnected:true,address:n.address,chainUID:t,walletType:n.walletType,balances:[...n.balances]})}l.setConnectedWallets(o).catch((t=>{console.warn("Failed to persist wallet connections:",t)}))},removeWallet(t){const n=new Map(h.connectedWallets);n.delete(t);m.smartUpdate({connectedWallets:n,wallets:n});if(h.chainUID===t){const t=Array.from(n.values());if(t.length>0){const n=t[0];m.smartUpdate({address:n.address,chainUID:n.chainUID,walletType:n.walletType,balances:[...n.balances]})}else{m.smartUpdate({isConnected:false,address:null,chainUID:null,walletType:null,balances:[]})}}l.setConnectedWallets(n).catch((t=>{console.warn("Failed to persist wallet connections:",t)}))},updateWalletBalances(t,n){const e=h.connectedWallets.get(t);if(e){const o={...e,balances:[...n]};const a=new Map(h.connectedWallets);a.set(t,o);m.smartUpdate({connectedWallets:a,wallets:a});if(h.chainUID===t){m.smartUpdate({balances:[...n]})}l.setConnectedWallets(a).catch((t=>{console.warn("Failed to persist wallet connections:",t)}))}}};const _={getBalance:t=>h.balances.find((n=>n.token===t)),getFormattedBalance:(t,n=18)=>{const e=_.getBalance(t);if(!e)return"0";try{const t=BigInt(e.balance);const o=BigInt(10**n);const a=t/o;const s=t%o;return`${a.toString()}.${s.toString().padStart(n,"0")}`}catch{return"0"}},hasSufficientBalance:(t,n,e)=>{if(typeof e==="string"&&n&&e){const o=t;const a=n;const s=e;const r=h.connectedWallets.get(o);if(!r)return false;const i=r.balances.find((t=>t.token===a));if(!i)return false;try{return BigInt(i.balance)>=BigInt(s)}catch{return false}}else{const e=t;const o=n||"";const a=_.getBalance(e);if(!a)return false;try{return BigInt(a.balance)>=BigInt(o)}catch{return false}}},isWalletAvailable:t=>{try{const n=r.getAdapter(t);return n.isAvailable()}catch{return false}},getAvailableWallets:()=>r.getAvailableWalletTypes(),isWalletConnected:t=>{const n=h.connectedWallets.get(t);return n?n.isConnected:false},getAllConnectedWallets:()=>Array.from(h.connectedWallets.values()).filter((t=>t.isConnected)),getWalletBalance:(t,n)=>{const e=h.connectedWallets.get(t);if(!e)return null;return e.balances.find((t=>t.token===n||t.token.toLowerCase()===n.toLowerCase()))},getWallet:t=>h.connectedWallets.get(t)||null,addTransaction:(t,n)=>{console.log(`Transaction added for ${t}:`,n)},updateTransactionStatus:(t,n,e)=>{console.log(`Transaction ${n} on ${t} updated to status: ${e}`)}};const g={state:h,onChange:p,reset:w,dispose:y,...f,..._};const k={walletModalOpen:false,walletModalFilter:null,tokenModalOpen:false,tokenSelectorType:null,isInitialized:false,theme:"auto"};const{state:E,onChange:T,reset:I,dispose:$}=t(k);const A={initialize(){E.isInitialized=true},openWalletModal(t){E.walletModalOpen=true;E.walletModalFilter=t||null},closeWalletModal(){E.walletModalOpen=false;E.walletModalFilter=null},openTokenModal(t="input"){E.tokenModalOpen=true;E.tokenSelectorType=t},closeTokenModal(){E.tokenModalOpen=false;E.tokenSelectorType=null},setTheme(t){E.theme=t},clear(){I()}};const S={state:E,onChange:T,reset:I,dispose:$,...A};const b={tokenIn:null,tokenOut:null,fromToken:null,toToken:null,amountIn:"",amountOut:"",fromAmount:"",toAmount:"",routes:[],selectedRoute:null,slippage:.5,loading:false,error:null};const{state:v,onChange:P,reset:F,dispose:C}=t(b);const q={setTokenIn(t){v.tokenIn=t;v.fromToken=t;v.routes=[];v.selectedRoute=null;v.amountOut="";v.toAmount=""},setTokenOut(t){v.tokenOut=t;v.toToken=t;v.routes=[];v.selectedRoute=null;v.amountOut="";v.toAmount=""},setFromToken(t){q.setTokenIn(t)},setToToken(t){q.setTokenOut(t)},setAmountIn(t){v.amountIn=t;v.fromAmount=t;if(!t){v.amountOut="";v.toAmount="";v.routes=[];v.selectedRoute=null}},setAmountOut(t){v.amountOut=t;v.toAmount=t},setFromAmount(t){q.setAmountIn(t)},setToAmount(t){q.setAmountOut(t)},setRoutes(t){v.routes=[...t];v.loading=false;v.error=null;if(t.length>0){q.setSelectedRoute(t[0])}},setSelectedRoute(t){v.selectedRoute=t;if(t&&t.path.length>0){const n=t.path[t.path.length-1];v.amountOut=n.amount_out}},setLoading(t){v.loading=t},setError(t){v.error=t},setSlippage(t){v.slippage=t},setLoadingRoutes(t){v.loading=t},setSwapping(t){v.loading=t},swapTokens(){const t=v.tokenIn;const n=v.tokenOut;const e=v.amountIn;v.tokenIn=n;v.tokenOut=t;v.fromToken=n;v.toToken=t;v.amountIn="";v.amountOut=e;v.fromAmount="";v.toAmount=e;v.routes=[];v.selectedRoute=null;v.error=null},clear(){F()}};const O={canSwap:()=>!!(v.tokenIn&&v.tokenOut&&v.amountIn&&parseFloat(v.amountIn)>0&&v.selectedRoute&&!v.loading),getPriceImpact:()=>v.selectedRoute?.total_price_impact||"0",getEstimatedGas:()=>{if(!v.selectedRoute)return"0";const t=v.selectedRoute.path.length;return(t*1e5).toString()},isValidPair:()=>!!(v.tokenIn&&v.tokenOut&&v.tokenIn.id!==v.tokenOut.id),getSlippageAmount:()=>{if(!v.amountOut||!v.slippage)return"0";try{const t=BigInt(v.amountOut);const n=BigInt(Math.floor(v.slippage*100));const e=t*n/BigInt(1e4);const o=t-e;return o.toString()}catch{return"0"}}};const R={state:v,onChange:P,reset:F,dispose:C,...q,...O};const D={token1:null,token2:null,amount1:"",amount2:"",token1Amount:"",token2Amount:"",pool:null,selectedPool:null,userLpBalance:"0",loading:false,error:null};const{state:M,onChange:N,reset:L,dispose:B}=t(D);const U={setLoading(t){M.loading=t},setError(t){M.error=t},setToken1(t){M.token1=t;if(M.pool&&t&&M.pool.token_1!==t.id&&M.pool.token_2!==t.id){M.pool=null}},setToken2(t){M.token2=t;if(M.pool&&t&&M.pool.token_1!==t.id&&M.pool.token_2!==t.id){M.pool=null}},setAmount1(t){M.amount1=t;M.token1Amount=t},setAmount2(t){M.amount2=t;M.token2Amount=t},setToken1Amount(t){U.setAmount1(t)},setToken2Amount(t){U.setAmount2(t)},setPool(t){M.pool=t;M.selectedPool=t},setSelectedPool(t){U.setPool(t)},setUserLpBalance(t){M.userLpBalance=t},swapTokens(){const t=M.token1;const n=M.token2;const e=M.amount1;const o=M.amount2;M.token1=n;M.token2=t;M.amount1=o;M.amount2=e},clear(){L()},setAddingLiquidity(t){M.loading=t},setRemovingLiquidity(t){M.loading=t},getPosition(t){console.warn(`getPosition(${t}) not implemented`);return null}};const W={canAddLiquidity:()=>!!(M.token1&&M.token2&&M.amount1&&M.amount2&&parseFloat(M.amount1)>0&&parseFloat(M.amount2)>0&&!M.loading),canRemoveLiquidity:()=>!!(M.pool&&M.userLpBalance&&parseFloat(M.userLpBalance)>0&&!M.loading),getPoolLiquidity:()=>M.pool?.total_liquidity||"0",getPoolVolume24h:()=>M.pool?.volume_24h||"0",getPoolFees24h:()=>M.pool?.fees_24h||"0",getPoolAPR:()=>M.pool?.apr||"0",isValidPair:()=>!!(M.token1&&M.token2&&M.token1.id!==M.token2.id)};const x={state:M,onChange:N,reset:L,dispose:B,...U,...W};const V={graphqlEndpoint:"https://testnet.api.euclidprotocol.com/graphql",restEndpoint:"https://testnet.api.euclidprotocol.com/api/v1",apiTimeout:1e4,environment:"testnet",refreshIntervals:{marketData:3e4,balances:6e4,routes:3e5},performance:{cache:{marketData:5e3,chains:3e5,routes:3e4,balances:6e4,tokens:5e3},polling:{active:{marketData:5e3,chains:3e5,balances:6e4,routes:1e4},background:{marketData:3e5,chains:18e5,balances:6e5,routes:6e4}},requestDeduplication:true,pauseOnHidden:true},ui:{defaultSlippage:.5,animationDuration:250,zIndex:{modal:1e3,tooltip:1070,dropdown:1e3}},features:{darkMode:true,transactionHistory:true,advancedRouting:true},defaultWallet:"keplr",supportedWallets:["keplr","metamask","walletconnect","coinbase"],defaultChain:"osmosis-1",supportedChains:["cosmoshub-4","osmosis-1","juno-1","stargaze-1","ethereum","polygon","arbitrum","optimism"]};const H={mainnet:{graphqlEndpoint:"https://api.euclidprotocol.com/graphql",restEndpoint:"https://api.euclidprotocol.com/api/v1",environment:"mainnet"},testnet:{graphqlEndpoint:"https://testnet.api.euclidprotocol.com/graphql",restEndpoint:"https://testnet.api.euclidprotocol.com/api/v1",environment:"testnet"},devnet:{graphqlEndpoint:"https://devnet.api.euclidprotocol.com/graphql",restEndpoint:"https://devnet.api.euclidprotocol.com/api/v1",environment:"devnet"}};const K=(t,n)=>({...t,...n,refreshIntervals:{...t.refreshIntervals,...n.refreshIntervals},ui:{...t.ui,...n.ui,zIndex:{...t.ui.zIndex,...n.ui?.zIndex}},features:{...t.features,...n.features}});class z{constructor(t){const n={...V,...t};this.endpoint=n.graphqlEndpoint;this.timeout=n.apiTimeout}async query(t,n){const e=new AbortController;const o=setTimeout((()=>e.abort()),this.timeout);try{const a=await fetch(this.endpoint,{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({query:t,variables:n||{}}),signal:e.signal});clearTimeout(o);if(!a.ok){throw new Error(`HTTP error! status: ${a.status}`)}const s=await a.json();if(s.errors){throw new Error(`GraphQL error: ${s.errors.map((t=>t.message)).join(", ")}`)}return{success:true,data:s.data}}catch(t){clearTimeout(o);console.error("GraphQL query failed:",t);return{success:false,error:t instanceof Error?t.message:"Unknown error"}}}async getChains(t){const n=`\n      query Chains($showAllChains: Boolean, $type: String) {\n        chains {\n          all_chains(show_all_chains: $showAllChains, type: $type) {\n            chain_id\n            chain_uid\n            display_name\n            factory_address\n            token_factory_address\n            explorer_url\n            logo\n            type\n          }\n        }\n      }\n    `;const e=await this.query(n,t);if(!e.success||!e.data){throw new Error(e.error||"Failed to fetch chains")}return e.data.chains.all_chains}async getTokenMetadata(t){const n=`\n      query Token(\n        $limit: Int,\n        $offset: Int,\n        $verified: Boolean,\n        $dex: [String!],\n        $chainUids: [String!],\n        $showVolume: Boolean,\n        $search: String\n      ) {\n        token {\n          token_metadatas(\n            limit: $limit,\n            offset: $offset,\n            verified: $verified,\n            dex: $dex,\n            chain_uids: $chainUids,\n            show_volume: $showVolume,\n            search: $search\n          ) {\n            coinDecimal\n            displayName\n            tokenId\n            description\n            image\n            price\n            price_change_24h\n            price_change_7d\n            dex\n            chain_uids\n            total_volume\n            total_volume_24h\n            tags\n            min_swap_value\n            social\n            is_verified\n          }\n        }\n      }\n    `;const e=await this.query(n,t);if(!e.success||!e.data){throw new Error(e.error||"Failed to fetch token metadata")}return e.data.token.token_metadatas}async getAllPools(t,n=true){try{const t=`\n        query Token_pair_with_liquidity($limit: Int, $onlyShowVerified: Boolean) {\n          pool {\n            token_pair_with_liquidity(limit: $limit, only_show_verified: $onlyShowVerified) {\n              results {\n                pair {\n                  token_1\n                  token_2\n                }\n                vlp\n                total_liquidity\n                apr\n                tags\n                created_at\n              }\n              pagination {\n                total_count\n                limit\n                offset\n              }\n            }\n          }\n        }\n      `;const e=await this.query(t,{limit:1e3,onlyShowVerified:n});if(!e.success||!e.data?.pool?.token_pair_with_liquidity?.results){throw new Error(e.error||"Failed to fetch pools with liquidity data")}const o=e.data.pool.token_pair_with_liquidity.results.map((t=>({pool_id:`${t.pair.token_1}-${t.pair.token_2}`,token_1:t.pair.token_1,token_2:t.pair.token_2,total_liquidity:t.total_liquidity,volume_24h:"0",fees_24h:"0",apr:t.apr})));console.log(`✅ Loaded ${o.length} pools with real liquidity and APR data from official API`);return o}catch(t){console.error("Failed to fetch pools with liquidity data:",t);return[]}}async getUserBalances(t){const n=`\n      query Vcoin($user: CrossChainUserInput) {\n        vcoin {\n          user_balance(user: $user) {\n            balances {\n              amount\n              token_id\n            }\n          }\n        }\n      }\n    `;const e={user:{address:t.address,chain_uid:t.chain_uid}};const o=await this.query(n,e);if(!o.success||!o.data){throw new Error(o.error||"Failed to fetch user balances")}return o.data.vcoin.user_balance.balances}async getPoolInfo(t,n){const e=await this.getAllPools();return e.find((e=>e.token_1===t&&e.token_2===n||e.token_1===n&&e.token_2===t))||null}async getPoolById(t){const n=`\n      query Pool($poolId: String!) {\n        pool {\n          pool_by_id(pool_id: $poolId) {\n            pool_id\n            token_1\n            token_2\n            total_liquidity\n            volume_24h\n            volume_7d\n            fees_24h\n            apr\n            apy\n            tvl_change_24h\n            volume_change_24h\n            pool_address\n            dex\n            chain_uid\n            created_at\n            fee_rate\n            tags\n          }\n        }\n      }\n    `;const e=await this.query(n,{poolId:t});if(!e.success||!e.data?.pool?.pool_by_id){return null}return e.data.pool.pool_by_id}async getPoolStatistics(t,n="24h"){const e=`\n      query Pool($poolId: String!, $timeframe: String!) {\n        pool {\n          statistics(pool_id: $poolId, timeframe: $timeframe) {\n            liquidity_metrics {\n              current_liquidity\n              liquidity_change\n              liquidity_change_percentage\n              token_1_reserve\n              token_2_reserve\n            }\n            volume_metrics {\n              volume\n              volume_change\n              volume_change_percentage\n              trade_count\n            }\n            fee_metrics {\n              fees_collected\n              fee_rate\n              protocol_fees\n              lp_fees\n            }\n            price_metrics {\n              current_price\n              price_change\n              price_change_percentage\n              high\n              low\n            }\n          }\n        }\n      }\n    `;const o=await this.query(e,{poolId:t,timeframe:n});if(!o.success||!o.data?.pool?.statistics){throw new Error(o.error||"Failed to fetch pool statistics")}return o.data.pool.statistics}async getPoolLiquidityProviders(t,n=50,e=0){const o=`\n      query Pool($poolId: String!, $limit: Int, $offset: Int) {\n        pool {\n          liquidity_providers(pool_id: $poolId, limit: $limit, offset: $offset) {\n            providers {\n              address\n              liquidity_provided\n              percentage_share\n              token_1_amount\n              token_2_amount\n              rewards_earned\n              joined_at\n              chain_uid\n            }\n            total_providers\n          }\n        }\n      }\n    `;const a=await this.query(o,{poolId:t,limit:n,offset:e});if(!a.success||!a.data?.pool?.liquidity_providers){throw new Error(a.error||"Failed to fetch pool liquidity providers")}return a.data.pool.liquidity_providers}async getPoolTransactions(t,n=50,e=0,o){const a=`\n      query Pool($poolId: String!, $limit: Int, $offset: Int, $type: String) {\n        pool {\n          transactions(pool_id: $poolId, limit: $limit, offset: $offset, type: $type) {\n            transactions {\n              tx_hash\n              type\n              user\n              token_in\n              token_out\n              amount_in\n              amount_out\n              token_1_amount\n              token_2_amount\n              liquidity_amount\n              fee_paid\n              timestamp\n              block_height\n              chain_uid\n            }\n            total_transactions\n          }\n        }\n      }\n    `;const s=await this.query(a,{poolId:t,limit:n,offset:e,type:o});if(!s.success||!s.data?.pool?.transactions){throw new Error(s.error||"Failed to fetch pool transactions")}return s.data.pool.transactions}async getPoolVolume(t,n="24h"){const e=`\n      query Pool($poolId: String!, $period: String!) {\n        pool {\n          volume(pool_id: $poolId, period: $period) {\n            volume_data {\n              timestamp\n              volume\n              trade_count\n              unique_traders\n            }\n            total_volume\n            average_volume\n          }\n        }\n      }\n    `;const o=await this.query(e,{poolId:t,period:n});if(!o.success||!o.data?.pool?.volume){throw new Error(o.error||"Failed to fetch pool volume")}return o.data.pool.volume}async getPoolFees(t,n="24h"){const e=`\n      query Pool($poolId: String!, $period: String!) {\n        pool {\n          fees(pool_id: $poolId, period: $period) {\n            fees_data {\n              timestamp\n              fees_collected\n              protocol_fees\n              lp_fees\n            }\n            total_fees\n            fee_rate\n          }\n        }\n      }\n    `;const o=await this.query(e,{poolId:t,period:n});if(!o.success||!o.data?.pool?.fees){throw new Error(o.error||"Failed to fetch pool fees")}return o.data.pool.fees}async getPoolAPR(t){const n=`\n      query Pool($poolId: String!) {\n        pool {\n          apr(pool_id: $poolId) {\n            current_apr\n            current_apy\n            apr_7d_avg\n            apr_30d_avg\n            fee_apr\n            reward_apr\n            breakdown {\n              component\n              apr\n              description\n            }\n          }\n        }\n      }\n    `;const e=await this.query(n,{poolId:t});if(!e.success||!e.data?.pool?.apr){throw new Error(e.error||"Failed to fetch pool APR")}return e.data.pool.apr}async getPoolTVL(t,n="24h"){const e=`\n      query Pool($poolId: String!, $period: String!) {\n        pool {\n          tvl(pool_id: $poolId, period: $period) {\n            tvl_data {\n              timestamp\n              tvl\n              token_1_reserve\n              token_2_reserve\n            }\n            current_tvl\n            tvl_change\n            tvl_change_percentage\n          }\n        }\n      }\n    `;const o=await this.query(e,{poolId:t,period:n});if(!o.success||!o.data?.pool?.tvl){throw new Error(o.error||"Failed to fetch pool TVL")}return o.data.pool.tvl}async getPoolComposition(t){const n=`\n      query Pool($poolId: String!) {\n        pool {\n          composition(pool_id: $poolId) {\n            token_1 {\n              symbol\n              amount\n              value_usd\n              percentage\n            }\n            token_2 {\n              symbol\n              amount\n              value_usd\n              percentage\n            }\n            total_value\n            price_ratio\n          }\n        }\n      }\n    `;const e=await this.query(n,{poolId:t});if(!e.success||!e.data?.pool?.composition){throw new Error(e.error||"Failed to fetch pool composition")}return e.data.pool.composition}async searchTokens(t,n){const e={search:t};if(n){e.chainUids=[n]}const o=await this.getTokenMetadata(e);const a=t.toLowerCase();return o.filter((t=>t.displayName?.toLowerCase().includes(a)||t.tokenId?.toLowerCase().includes(a)||t.description?.toLowerCase().includes(a)||t.symbol?.toLowerCase().includes(a)||t.name?.toLowerCase().includes(a)))}async getTokenBySymbol(t,n){const e=await this.getTokenMetadata({chainUids:[n]});return e.find((n=>n.displayName?.toLowerCase()===t.toLowerCase()||n.symbol?.toLowerCase()===t.toLowerCase()))||null}async getTokenById(t){const n=`\n      query Token($tokenId: String!) {\n        token {\n          token_metadata(token_id: $tokenId) {\n            coinDecimal\n            displayName\n            tokenId\n            description\n            image\n            price\n            price_change_24h\n            price_change_7d\n            dex\n            chain_uids\n            total_volume\n            total_volume_24h\n            tags\n            min_swap_value\n            social\n            is_verified\n            market_cap\n            circulating_supply\n            total_supply\n            max_supply\n            holders_count\n          }\n        }\n      }\n    `;const e=await this.query(n,{tokenId:t});if(!e.success||!e.data?.token?.token_metadata){return null}return e.data.token.token_metadata}async getTokenPriceHistory(t,n="24h"){const e=`\n      query Token($tokenId: String!, $period: String!) {\n        token {\n          price_history(token_id: $tokenId, period: $period) {\n            data {\n              timestamp\n              price\n              volume\n            }\n          }\n        }\n      }\n    `;const o=await this.query(e,{tokenId:t,period:n});if(!o.success||!o.data?.token?.price_history?.data){throw new Error(o.error||"Failed to fetch token price history")}return o.data.token.price_history.data}async getTokenHolders(t,n=100,e=0){const o=`\n      query Token($tokenId: String!, $limit: Int, $offset: Int) {\n        token {\n          holders(token_id: $tokenId, limit: $limit, offset: $offset) {\n            holders {\n              address\n              balance\n              percentage\n              chain_uid\n            }\n            total_holders\n          }\n        }\n      }\n    `;const a=await this.query(o,{tokenId:t,limit:n,offset:e});if(!a.success||!a.data?.token?.holders){throw new Error(a.error||"Failed to fetch token holders")}return a.data.token.holders}async getTokenTransfers(t,n=50,e=0){const o=`\n      query Token($tokenId: String!, $limit: Int, $offset: Int) {\n        token {\n          transfers(token_id: $tokenId, limit: $limit, offset: $offset) {\n            transfers {\n              tx_hash\n              from\n              to\n              amount\n              timestamp\n              block_height\n              chain_uid\n            }\n            total_transfers\n          }\n        }\n      }\n    `;const a=await this.query(o,{tokenId:t,limit:n,offset:e});if(!a.success||!a.data?.token?.transfers){throw new Error(a.error||"Failed to fetch token transfers")}return a.data.token.transfers}async getTokenSupply(t){const n=`\n      query Token($tokenId: String!) {\n        token {\n          supply(token_id: $tokenId) {\n            total_supply\n            circulating_supply\n            max_supply\n            burned_supply\n            locked_supply\n          }\n        }\n      }\n    `;const e=await this.query(n,{tokenId:t});if(!e.success||!e.data?.token?.supply){throw new Error(e.error||"Failed to fetch token supply")}return e.data.token.supply}async getTokenMarketData(t){const n=`\n      query Token($tokenId: String!) {\n        token {\n          market_data(token_id: $tokenId) {\n            price\n            price_change_24h\n            price_change_7d\n            market_cap\n            volume_24h\n            liquidity\n            fdv\n            high_24h\n            low_24h\n            ath\n            ath_date\n            atl\n            atl_date\n          }\n        }\n      }\n    `;const e=await this.query(n,{tokenId:t});if(!e.success||!e.data?.token?.market_data){throw new Error(e.error||"Failed to fetch token market data")}return e.data.token.market_data}async getTokenSocial(t){const n=`\n      query Token($tokenId: String!) {\n        token {\n          social(token_id: $tokenId) {\n            website\n            twitter\n            telegram\n            discord\n            github\n            reddit\n            coingecko\n            coinmarketcap\n          }\n        }\n      }\n    `;const e=await this.query(n,{tokenId:t});if(!e.success||!e.data?.token?.social){throw new Error(e.error||"Failed to fetch token social data")}return e.data.token.social}async getTokenPairs(t){const n=`\n      query Token($tokenId: String!) {\n        token {\n          pairs(token_id: $tokenId) {\n            pair_id\n            token_1\n            token_2\n            pool_address\n            liquidity_usd\n            volume_24h\n            apr\n            dex\n            chain_uid\n          }\n        }\n      }\n    `;const e=await this.query(n,{tokenId:t});if(!e.success||!e.data?.token?.pairs){throw new Error(e.error||"Failed to fetch token pairs")}return e.data.token.pairs}async getVerifiedTokens(t){return this.getTokenMetadata({verified:true,chainUids:t,limit:1e3})}async getTokenAnalytics(t,n="24h"){const e=`\n      query Token($tokenId: String!, $timeframe: String!) {\n        token {\n          analytics(token_id: $tokenId, timeframe: $timeframe) {\n            price_metrics {\n              current_price\n              price_change\n              price_change_percentage\n              high\n              low\n            }\n            volume_metrics {\n              volume\n              volume_change\n              volume_change_percentage\n            }\n            liquidity_metrics {\n              total_liquidity\n              liquidity_change\n              liquidity_change_percentage\n            }\n            trading_metrics {\n              trades_count\n              unique_traders\n              avg_trade_size\n            }\n          }\n        }\n      }\n    `;const o=await this.query(e,{tokenId:t,timeframe:n});if(!o.success||!o.data?.token?.analytics){throw new Error(o.error||"Failed to fetch token analytics")}return o.data.token.analytics}}const G=t=>new z(t);class j{constructor(t){const n={...V,...t};this.endpoint=n.restEndpoint;this.timeout=n.apiTimeout}async request(t,n={}){const e=new AbortController;const o=setTimeout((()=>e.abort()),this.timeout);try{const{method:a="GET",body:s,headers:r={}}=n;const i=await fetch(`${this.endpoint}${t}`,{method:a,headers:{"Content-Type":"application/json",Accept:"application/json",...r},body:s?JSON.stringify(s):undefined,signal:e.signal});clearTimeout(o);if(!i.ok){const t=await i.text();throw new Error(`HTTP ${i.status}: ${t}`)}const c=await i.json();return{success:true,data:c}}catch(n){clearTimeout(o);console.error(`REST API request failed (${t}):`,n);return{success:false,error:n instanceof Error?n.message:"Unknown error"}}}async getRoutes(t){const n=new URLSearchParams({amount_in:t.amount_in,token_in:t.token_in,token_out:t.token_out});if(t.external!==undefined){n.append("external",t.external.toString())}if(t.chain_uids&&t.chain_uids.length>0){t.chain_uids.forEach((t=>{n.append("chain_uids",t)}))}const e=await this.request(`/routes?${n}`);if(!e.success||!e.data){throw new Error(e.error||"Failed to fetch routes")}return e.data.paths}async getOptimalRoute(t){const n=await this.request("/routes/optimal",{method:"POST",body:t});if(!n.success||!n.data){throw new Error(n.error||"Failed to fetch optimal route")}return n.data.route}async getMultiRoutes(t){const n=await this.request("/routes/multi",{method:"POST",body:t});if(!n.success||!n.data){throw new Error(n.error||"Failed to fetch multi routes")}return n.data.routes}async getRouteStatistics(t){const n=t?`?timeframe=${t}`:"";const e=await this.request(`/routes/statistics${n}`);if(!e.success||!e.data){throw new Error(e.error||"Failed to fetch route statistics")}return e.data}async getRouteFees(t){const n=await this.request("/routes/fees",{method:"POST",body:t});if(!n.success||!n.data){throw new Error(n.error||"Failed to fetch route fees")}return n.data}async simulateRoute(t){const n=await this.request("/routes/simulate",{method:"POST",body:t});if(!n.success||!n.data){throw new Error(n.error||"Failed to simulate route")}return n.data}async buildSwapTransaction(t){const n=await this.request("/swap",{method:"POST",body:t});if(!n.success||!n.data){throw new Error(n.error||"Failed to build swap transaction")}return n.data}async buildAddLiquidityTransaction(t){const n=await this.request("/add_liquidity",{method:"POST",body:t});if(!n.success||!n.data){throw new Error(n.error||"Failed to build add liquidity transaction")}return n.data}async buildRemoveLiquidityTransaction(t){const n=await this.request("/remove_liquidity",{method:"POST",body:t});if(!n.success||!n.data){throw new Error(n.error||"Failed to build remove liquidity transaction")}return n.data}async simulateSwap(t){const n=new URLSearchParams({amount_in:t.amount_in,token_in:t.token_in,token_out:t.token_out});if(t.chain_uid){n.append("chain_uid",t.chain_uid)}const e=await this.request(`/simulate_swap?${n}`);if(!e.success||!e.data){throw new Error(e.error||"Failed to simulate swap")}return e.data}async getBestRoute(t){const n=await this.getRoutes(t);if(n.length===0){return null}return n.sort(((t,n)=>parseFloat(t.total_price_impact)-parseFloat(n.total_price_impact)))[0]}async getTransactionStatus(t,n){const e=await this.request(`/transaction/${t}?chain_uid=${n}`);if(!e.success||!e.data){throw new Error(e.error||"Failed to get transaction status")}return e.data}async getTransactionDetails(t,n){const e=await this.request(`/transactions/${t}?chain_uid=${n}`);if(!e.success||!e.data){throw new Error(e.error||"Failed to get transaction details")}return e.data}async broadcastTransaction(t,n){const e=await this.request("/transactions/broadcast",{method:"POST",body:{tx:t,chain_uid:n}});if(!e.success||!e.data){throw new Error(e.error||"Failed to broadcast transaction")}return e.data}async estimateTransactionFees(t,n){const e=await this.request("/transactions/estimate_fees",{method:"POST",body:{transaction:t,chain_uid:n}});if(!e.success||!e.data){throw new Error(e.error||"Failed to estimate transaction fees")}return e.data}async simulateTransaction(t,n){const e=await this.request("/transactions/simulate",{method:"POST",body:{transaction:t,chain_uid:n}});if(!e.success||!e.data){throw new Error(e.error||"Failed to simulate transaction")}return e.data}async getUserTransactions(t,n,e){const o=new URLSearchParams({address:t,chain_uid:n});if(e?.limit)o.append("limit",e.limit.toString());if(e?.offset)o.append("offset",e.offset.toString());if(e?.type)o.append("type",e.type);if(e?.status)o.append("status",e.status);const a=await this.request(`/transactions/user/${t}?${o}`);if(!a.success||!a.data){throw new Error(a.error||"Failed to get user transactions")}return a.data}async getPendingTransactions(t,n){const e=await this.request(`/transactions/pending?address=${t}&chain_uid=${n}`);if(!e.success||!e.data){throw new Error(e.error||"Failed to get pending transactions")}return e.data}async batchTransactions(t){const n=await this.request("/transactions/batch",{method:"POST",body:{transactions:t}});if(!n.success||!n.data){throw new Error(n.error||"Failed to batch transactions")}return n.data}async estimateGas(t){const n=await this.request("/estimate_gas",{method:"POST",body:t});if(!n.success||!n.data){throw new Error(n.error||"Failed to estimate gas")}return n.data}}const J=t=>new j(t);class Q{constructor(t){this.graphql=G(t);this.rest=J(t)}async getChains(t){return this.graphql.getChains(t)}async getTokenMetadata(t){return this.graphql.getTokenMetadata(t)}async getTokenById(t){return this.graphql.getTokenById(t)}async getTokenPriceHistory(t,n="24h"){return this.graphql.getTokenPriceHistory(t,n)}async getTokenHolders(t,n=100,e=0){return this.graphql.getTokenHolders(t,n,e)}async getTokenTransfers(t,n=50,e=0){return this.graphql.getTokenTransfers(t,n,e)}async getTokenSupply(t){return this.graphql.getTokenSupply(t)}async getTokenMarketData(t){return this.graphql.getTokenMarketData(t)}async getTokenSocial(t){return this.graphql.getTokenSocial(t)}async getTokenPairs(t){return this.graphql.getTokenPairs(t)}async getVerifiedTokens(t){return this.graphql.getVerifiedTokens(t)}async getTokenAnalytics(t,n="24h"){return this.graphql.getTokenAnalytics(t,n)}async searchTokens(t,n){return this.graphql.searchTokens(t,n)}async getTokenBySymbol(t,n){return this.graphql.getTokenBySymbol(t,n)}async getAllPools(t=true){try{const n=await this.graphql.getAllPools(undefined,t);return{success:true,data:n}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to get pools"}}}async getPoolInfo(t,n){return this.graphql.getPoolInfo(t,n)}async getPoolById(t){return this.graphql.getPoolById(t)}async getPoolStatistics(t,n="24h"){return this.graphql.getPoolStatistics(t,n)}async getPoolLiquidityProviders(t,n=50,e=0){return this.graphql.getPoolLiquidityProviders(t,n,e)}async getPoolTransactions(t,n=50,e=0,o){return this.graphql.getPoolTransactions(t,n,e,o)}async getPoolVolume(t,n="24h"){return this.graphql.getPoolVolume(t,n)}async getPoolFees(t,n="24h"){return this.graphql.getPoolFees(t,n)}async getPoolAPR(t){return this.graphql.getPoolAPR(t)}async getPoolTVL(t,n="24h"){return this.graphql.getPoolTVL(t,n)}async getPoolComposition(t){return this.graphql.getPoolComposition(t)}async getAllChains(t){try{const n=await this.getChains({showAllChains:t});return{success:true,data:n}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to get chains"}}}async getAllTokens(){try{const t=await this.getTokenMetadata();return{success:true,data:t}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to get tokens"}}}async getTokenDenoms(t){console.warn(`getTokenDenoms(${t}) is not implemented in Euclid API`);return{success:true,data:{router:{token_denoms:{denoms:[]}}}}}async getEscrows(t){console.warn(`getEscrows(${t}) is not implemented in Euclid API`);return{success:true,data:{router:{escrows:[]}}}}async getBalance(t,n){try{const e=await this.getUserBalances({address:t,chain_uid:n});const o={balance:{all:e.map((t=>({denom:t.token,amount:t.balance})))}};return{success:true,data:o}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to get balance"}}}async getUserBalances(t){return this.graphql.getUserBalances(t)}async getRoutes(t){return this.rest.getRoutes(t)}async getOptimalRoute(t){return this.rest.getOptimalRoute(t)}async getMultiRoutes(t){return this.rest.getMultiRoutes(t)}async getRouteStatistics(t){return this.rest.getRouteStatistics(t)}async getRouteFees(t){return this.rest.getRouteFees(t)}async simulateRoute(t){return this.rest.simulateRoute(t)}async getRoutesWrapped(t){try{const n=await this.getRoutes(t);return{success:true,data:{paths:n}}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to get routes"}}}async getRoutesLegacy(t){return this.getRoutesWrapped(t)}async getBestRoute(t){return this.rest.getBestRoute(t)}async simulateSwap(t){return this.rest.simulateSwap(t)}async createSwapTransaction(t){return this.rest.buildSwapTransaction(t)}async createSwapTransactionWrapped(t){try{const n=await this.createSwapTransaction(t);return{success:true,data:n}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to create swap transaction"}}}async buildSwapTransaction(t){return this.createSwapTransaction(t)}async createAddLiquidityTransaction(t){return this.rest.buildAddLiquidityTransaction(t)}async createAddLiquidityTransactionWrapped(t){try{const n=await this.createAddLiquidityTransaction(t);return{success:true,data:n}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to create add liquidity transaction"}}}async createRemoveLiquidityTransaction(t){return this.rest.buildRemoveLiquidityTransaction(t)}async createRemoveLiquidityTransactionWrapped(t){try{const n=await this.createRemoveLiquidityTransaction(t);return{success:true,data:n}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to create remove liquidity transaction"}}}async trackTransaction(t,n){console.warn(`trackTransaction(${t}, ${n}) not implemented`);return{status:"pending"}}async trackTransactionWrapped(t,n){try{const e=await this.trackTransaction(t,n);return{success:true,data:e}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to track transaction"}}}async buildAddLiquidityTransaction(t){return this.rest.buildAddLiquidityTransaction(t)}async buildRemoveLiquidityTransaction(t){return this.rest.buildRemoveLiquidityTransaction(t)}async getTransactionStatus(t,n){return this.rest.getTransactionStatus(t,n)}async getTransactionDetails(t,n){return this.rest.getTransactionDetails(t,n)}async broadcastTransaction(t,n){return this.rest.broadcastTransaction(t,n)}async estimateTransactionFees(t,n){return this.rest.estimateTransactionFees(t,n)}async simulateTransaction(t,n){return this.rest.simulateTransaction(t,n)}async getUserTransactions(t,n,e){return this.rest.getUserTransactions(t,n,e)}async getPendingTransactions(t,n){return this.rest.getPendingTransactions(t,n)}async batchTransactions(t){return this.rest.batchTransactions(t)}async estimateGas(t){return this.rest.estimateGas(t)}async getMarketData(){const[t,n,e]=await Promise.all([this.getChains(),this.getTokenMetadata(),this.getAllPools()]);const o=e.success?e.data||[]:[];return{chains:t,tokens:n,pools:o}}async getUserPortfolio(t){const[n,e,o]=await Promise.all([this.getUserBalances(t),this.getChains(),this.getTokenMetadata()]);return{balances:n,chains:e,tokens:o}}async getSwapQuote(t,n,e,o){const a={amount_in:e,token_in:t,token_out:n,chain_uids:o};const[s,r]=await Promise.all([this.getBestRoute(a),this.simulateSwap({amount_in:e,token_in:t,token_out:n}).catch((()=>({amount_out:"0",price_impact:"0"})))]);return{route:s,expectedOutput:r.amount_out,priceImpact:r.price_impact}}}const Y=new Q;const Z={ETHEREUM:"ethereum",POLYGON:"polygon",ARBITRUM:"arbitrum",OPTIMISM:"optimism",COSMOS_HUB:"cosmoshub-4",OSMOSIS:"osmosis-1",JUNO:"juno-1",STARGAZE:"stargaze-1"};const X={METAMASK:"metamask",KEPLR:"keplr",WALLET_CONNECT:"walletconnect",COINBASE:"coinbase",OTHER:"other"};const tt={SWAP:"swap",ADD_LIQUIDITY:"add_liquidity",REMOVE_LIQUIDITY:"remove_liquidity",TRANSFER:"transfer"};const nt={PENDING:"pending",SUCCESS:"success",FAILED:"failed"};const et={CHAINS:"/api/chains",TOKENS:"/api/tokens",POOLS:"/api/pools",ROUTES:"/api/routes",BALANCES:"/api/balances",TRANSACTIONS:"/api/transactions",GRAPHQL:"/graphql"};const ot={WALLET_PREFERENCES:"euclid_wallet_preferences",THEME:"euclid_theme",SLIPPAGE:"euclid_slippage",TRANSACTION_HISTORY:"euclid_transaction_history"};const at={SLIPPAGE:V.ui.defaultSlippage,ROUTE_REFRESH_INTERVAL:V.refreshIntervals.routes,MARKET_DATA_REFRESH_INTERVAL:V.refreshIntervals.marketData,BALANCE_REFRESH_INTERVAL:V.refreshIntervals.balances,TRANSACTION_TIMEOUT:3e5};const st={MODAL_Z_INDEX:V.ui.zIndex.modal,TOOLTIP_Z_INDEX:V.ui.zIndex.tooltip,DROPDOWN_Z_INDEX:V.ui.zIndex.dropdown,ANIMATION_DURATION:V.ui.animationDuration};const rt={ETH_ADDRESS:/^0x[a-fA-F0-9]{40}$/,COSMOS_ADDRESS:/^[a-z0-9]{39,59}$/,DECIMAL_NUMBER:/^\d*\.?\d*$/,POSITIVE_NUMBER:/^[+]?([0-9]*[.])?[0-9]+$/};const it={WALLET_NOT_CONNECTED:"Wallet not connected",INSUFFICIENT_BALANCE:"Insufficient balance",INVALID_AMOUNT:"Invalid amount",NO_ROUTE_FOUND:"No route found for this swap",TRANSACTION_FAILED:"Transaction failed",NETWORK_ERROR:"Network error occurred",TIMEOUT:"Request timeout"};const ct={WALLET_CONNECTED:"Wallet connected successfully",TRANSACTION_SUBMITTED:"Transaction submitted",TRANSACTION_CONFIRMED:"Transaction confirmed",LIQUIDITY_ADDED:"Liquidity added successfully",LIQUIDITY_REMOVED:"Liquidity removed successfully"};const lt={DARK_MODE:V.features.darkMode,ADVANCED_ROUTING:V.features.advancedRouting,TRANSACTION_HISTORY:V.features.transactionHistory};export{et as A,Z as C,V as D,H as E,lt as F,rt as P,ot as S,tt as T,st as U,X as W,S as a,l as b,at as c,Y as d,nt as e,it as f,ct as g,x as l,K as m,R as s,g as w};
//# sourceMappingURL=p-8CHUc0Tf.js.map