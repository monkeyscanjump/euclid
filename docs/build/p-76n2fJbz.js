import{D as n}from"./p-9CRWQAc1.js";async function e(e,o,t){const i={...n,...t};const r=new AbortController;const s=setTimeout((()=>r.abort()),i.apiTimeout);try{const n=await fetch(i.graphqlEndpoint,{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({query:e,variables:o}),signal:r.signal});clearTimeout(s);if(!n.ok){throw new Error(`HTTP ${n.status}: ${n.statusText}`)}const t=await n.json();if(t.errors){throw new Error(`GraphQL errors: ${t.errors.map((n=>n.message)).join(", ")}`)}return t.data}catch(n){clearTimeout(s);const e=n instanceof Error?n.message:"Unknown error";throw new Error(`Pool query failed: ${e}`)}}async function o(n,o,t){const i=`\n    query Pool($chainUid: String!, $poolAddress: String!, $pair: PairInput!) {\n      pool(chain_uid: $chainUid, pool_address: $poolAddress, pair: $pair) {\n        pool_id\n        pair {\n          token_1\n          token_2\n        }\n        total_liquidity\n        reserves {\n          token_1_reserve\n          token_2_reserve\n        }\n        volume_24h\n        volume_7d\n        volume_30d\n        fees_collected_24h\n        fees_collected_7d\n        fees_collected_30d\n        fee_tier\n        apy\n        price_ratio\n        pool_type\n        status\n        created_at\n        last_updated\n      }\n    }\n  `;const r=await e(i,{chainUid:n,poolAddress:o,pair:t});return r.pool}async function t(n,o,t){const i=`\n    query Pool_fees($chainUid: String!, $poolAddress: String!, $timeframe: String) {\n      pool(chain_uid: $chainUid, pool_address: $poolAddress) {\n        pool_fees(timeframe: $timeframe) {\n          total_fees_collected\n          fees_by_token {\n            token_id\n            amount\n            value_usd\n          }\n          fee_percentage\n          timeframe\n          collection_period {\n            start_date\n            end_date\n          }\n          historical_data {\n            date\n            fees_collected\n            volume\n          }\n        }\n      }\n    }\n  `;const r=await e(i,{chainUid:n,poolAddress:o,timeframe:t});return r.pool.pool_fees}async function i(n,o,t){const i=`\n    query Simulate_join_pool($chainUid: String!, $poolAddress: String!, $tokenAmounts: [TokenAmountInput!]!) {\n      pool(chain_uid: $chainUid, pool_address: $poolAddress) {\n        simulate_join_pool(token_amounts: $tokenAmounts) {\n          liquidity_tokens_out\n          price_impact\n          minimum_liquidity_out\n          gas_estimate\n          fees_paid\n          slippage_tolerance\n          success\n          error_message\n        }\n      }\n    }\n  `;const r=await e(i,{chainUid:n,poolAddress:o,tokenAmounts:t});return r.pool.simulate_join_pool}async function r(n,o,t,i){const r=`\n    query Simulate_exit_pool($chainUid: String!, $poolAddress: String!, $liquidityAmount: String!, $exitType: String) {\n      pool(chain_uid: $chainUid, pool_address: $poolAddress) {\n        simulate_exit_pool(liquidity_amount: $liquidityAmount, exit_type: $exitType) {\n          tokens_out {\n            token_id\n            amount\n            value_usd\n          }\n          price_impact\n          minimum_tokens_out {\n            token_id\n            minimum_amount\n          }\n          gas_estimate\n          fees_paid\n          slippage_tolerance\n          success\n          error_message\n        }\n      }\n    }\n  `;const s=await e(r,{chainUid:n,poolAddress:o,liquidityAmount:t,exitType:i});return s.pool.simulate_exit_pool}export{t as getPoolFeesImpl,o as getPoolImpl,r as getSimulateExitPoolImpl,i as getSimulateJoinPoolImpl};
//# sourceMappingURL=p-76n2fJbz.js.map