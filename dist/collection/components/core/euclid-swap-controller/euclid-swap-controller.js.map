{"version":3,"file":"euclid-swap-controller.js","sourceRoot":"","sources":["../../../../src/components/core/euclid-swap-controller/euclid-swap-controller.tsx"],"names":[],"mappings":"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","sourcesContent":["import { Component, Listen, State, Watch } from '@stencil/core';\nimport { swapStore } from '../../../store/swap.store';\nimport { walletStore } from '../../../store/wallet.store';\nimport { apiClient } from '../../../utils/api-client';\nimport { WalletAdapterFactory } from '../../../utils/wallet-adapter';\nimport { DEFAULTS } from '../../../utils/constants';\nimport { EUCLID_EVENTS, dispatchEuclidEvent } from '../../../utils/events';\n\n@Component({\n  tag: 'euclid-swap-controller',\n})\nexport class EuclidSwapController {\n  @State() isInitialized = false;\n  private routePollingInterval: number;\n  private routePollingActive = false;\n\n  async componentDidLoad() {\n    await this.initialize();\n  }\n\n  disconnectedCallback() {\n    this.stopRoutePolling();\n  }\n\n  private async initialize() {\n    console.log('🔄 Initializing Swap Controller...');\n\n    // Subscribe to swap store changes for smart polling\n    swapStore.onChange('fromToken', () => this.handleTokenChange());\n    swapStore.onChange('toToken', () => this.handleTokenChange());\n    swapStore.onChange('fromAmount', () => this.handleAmountChange());\n\n    this.isInitialized = true;\n    console.log('✅ Swap Controller initialized');\n  }\n\n  private handleTokenChange() {\n    // Clear existing routes when tokens change\n    swapStore.setRoutes([]);\n    swapStore.setSelectedRoute(undefined);\n    this.stopRoutePolling();\n\n    // Start polling if we have both tokens and an amount\n    if (swapStore.state.fromToken && swapStore.state.toToken && swapStore.state.fromAmount) {\n      this.startRoutePolling();\n    }\n  }\n\n  private handleAmountChange() {\n    const { fromToken, toToken, fromAmount } = swapStore.state;\n\n    if (fromToken && toToken && fromAmount && parseFloat(fromAmount) > 0) {\n      // Debounce the route fetching\n      this.debounceRouteFetch();\n    } else {\n      this.stopRoutePolling();\n      swapStore.setRoutes([]);\n    }\n  }\n\n  private debounceTimeout: number;\n\n  private debounceRouteFetch() {\n    if (this.debounceTimeout) {\n      clearTimeout(this.debounceTimeout);\n    }\n\n    this.debounceTimeout = window.setTimeout(() => {\n      this.startRoutePolling();\n    }, 500); // 500ms debounce\n  }\n\n  private startRoutePolling() {\n    if (this.routePollingActive) return;\n\n    console.log('🔄 Starting route polling...');\n    this.routePollingActive = true;\n\n    // Fetch routes immediately\n    this.fetchRoutes();\n\n    // Set up periodic polling\n    this.routePollingInterval = window.setInterval(() => {\n      this.fetchRoutes();\n    }, DEFAULTS.ROUTE_REFRESH_INTERVAL);\n  }\n\n  private stopRoutePolling() {\n    if (!this.routePollingActive) return;\n\n    console.log('⏹️ Stopping route polling...');\n    this.routePollingActive = false;\n\n    if (this.routePollingInterval) {\n      clearInterval(this.routePollingInterval);\n    }\n  }\n\n  private async fetchRoutes() {\n    const { fromToken, toToken, fromAmount } = swapStore.state;\n\n    if (!fromToken || !toToken || !fromAmount || parseFloat(fromAmount) <= 0) {\n      return;\n    }\n\n    try {\n      swapStore.setLoadingRoutes(true);\n\n      console.log('🛣️ Fetching swap routes:', {\n        from: fromToken.symbol,\n        to: toToken.symbol,\n        amount: fromAmount,\n      });\n\n      // Call the routes API\n      const response = await apiClient.getRoutesWrapped({\n        amount_in: fromAmount,\n        token_in: fromToken.id,\n        token_out: toToken.id,\n        external: true,\n      });\n\n      if (response.success && response.data) {\n        const routePaths = response.data.paths || [];\n\n        // Store the RoutePath[] directly\n        swapStore.setRoutes(routePaths);\n\n        // Auto-select the best route (first one, typically best by default)\n        if (routePaths.length > 0 && !swapStore.state.selectedRoute) {\n          swapStore.setSelectedRoute(routePaths[0]);\n        }\n\n        console.log(`✅ Found ${routePaths.length} swap routes`);\n      } else {\n        console.warn('⚠️ Failed to fetch routes:', response.error);\n        swapStore.setRoutes([]);\n      }\n    } catch (error) {\n      console.error('❌ Error fetching routes:', error);\n      swapStore.setRoutes([]);\n    } finally {\n      swapStore.setLoadingRoutes(false);\n    }\n  }\n\n  private getUserAddressForChain(chainUID: string): string | undefined {\n    const wallet = walletStore.getWallet(chainUID);\n    return wallet?.address;\n  }\n\n  // Execute swap transaction\n  async executeSwap(): Promise<{ success: boolean; txHash?: string; error?: string }> {\n    try {\n      const { fromToken, toToken, fromAmount, selectedRoute, slippage } = swapStore.state;\n\n      if (!fromToken || !toToken || !fromAmount || !selectedRoute) {\n        return { success: false, error: 'Missing required swap parameters' };\n      }\n\n      // Check if wallet is connected for the required chain\n      const wallet = walletStore.getWallet(fromToken.chainUID);\n      if (!wallet?.isConnected) {\n        return { success: false, error: `Wallet not connected for ${fromToken.chainUID}` };\n      }\n\n      // Check sufficient balance\n      if (!walletStore.hasSufficientBalance(fromToken.chainUID, fromToken.id, fromAmount)) {\n        return { success: false, error: 'Insufficient balance' };\n      }\n\n      swapStore.setSwapping(true);\n\n      console.log('🔄 Executing swap...', {\n        from: fromToken.symbol,\n        to: toToken.symbol,\n        amount: fromAmount,\n        route: selectedRoute.id,\n      });\n\n      // Get the wallet adapter for signing\n      const walletAdapter = WalletAdapterFactory.getAdapter(wallet.type);\n      if (!walletAdapter) {\n        return { success: false, error: `Wallet adapter not found for ${wallet.type}` };\n      }\n\n      // Execute the swap via API - create a basic SwapRequest structure\n      const swapResult = await apiClient.createSwapTransactionWrapped({\n        amount_in: fromAmount,\n        asset_in: {\n          token: fromToken.id,\n          token_type: { native: { denom: fromToken.id } }\n        },\n        slippage: slippage.toString(),\n        minimum_receive: this.calculateMinimumReceived(selectedRoute.outputAmount, slippage),\n        sender: {\n          address: wallet.address,\n          chain_uid: fromToken.chain_uid || fromToken.chainUID\n        },\n        swap_path: {\n          path: selectedRoute.path || []\n        },\n        timeout: (Math.floor(Date.now() / 1000) + 1200).toString() // 20 minutes from now\n      });\n\n      if (swapResult.success && swapResult.data) {\n        const txHash = `swap_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n        // Add transaction to wallet store\n        walletStore.addTransaction(fromToken.chainUID, {\n          txHash,\n          timestamp: Date.now(),\n          type: 'swap'\n        });\n\n        // Emit global event for transaction tracking\n        dispatchEuclidEvent(EUCLID_EVENTS.TRANSACTION.SUBMITTED, {\n          txHash,\n          chainUID: fromToken.chainUID,\n          type: 'swap',\n        });\n\n        console.log('✅ Swap transaction submitted:', txHash);\n        return { success: true, txHash };\n      } else {\n        return { success: false, error: swapResult.error || 'Swap execution failed' };\n      }\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n      console.error('❌ Swap execution error:', errorMessage);\n      return { success: false, error: errorMessage };\n    } finally {\n      swapStore.setSwapping(false);\n    }\n  }\n\n  private calculateMinimumReceived(outputAmount: string, slippage: number): string {\n    try {\n      const amount = BigInt(outputAmount);\n      const slippageMultiplier = BigInt(Math.floor((100 - slippage) * 100)); // Convert to basis points\n      const minimumReceived = (amount * slippageMultiplier) / BigInt(10000);\n      return minimumReceived.toString();\n    } catch {\n      return outputAmount; // Fallback to original amount\n    }\n  }\n\n  // Event listeners\n  @Listen(EUCLID_EVENTS.SWAP.EXECUTE_REQUEST, { target: 'window' })\n  async handleSwapExecution() {\n    console.log('🔄 Swap execution requested via event');\n    const result = await this.executeSwap();\n\n    // Emit result event\n    if (result.success) {\n      dispatchEuclidEvent(EUCLID_EVENTS.SWAP.EXECUTE_SUCCESS, {\n        txHash: result.txHash,\n      });\n    } else {\n      dispatchEuclidEvent(EUCLID_EVENTS.SWAP.EXECUTE_FAILED, {\n        error: result.error,\n      });\n    }\n  }\n\n  @Listen(EUCLID_EVENTS.SWAP.ROUTES_REFRESH, { target: 'window' })\n  handleRouteRefresh() {\n    console.log('🔄 Manual route refresh requested');\n    this.fetchRoutes();\n  }\n\n  @Listen(EUCLID_EVENTS.SWAP.ROUTES_STOP_POLLING, { target: 'window' })\n  handleStopPolling() {\n    this.stopRoutePolling();\n  }\n\n  @Listen(EUCLID_EVENTS.SWAP.ROUTES_START_POLLING, { target: 'window' })\n  handleStartPolling() {\n    this.startRoutePolling();\n  }\n\n  @Watch('isInitialized')\n  onInitializedChange(newValue: boolean) {\n    if (newValue) {\n      console.log('📊 Swap Controller ready for route polling');\n    }\n  }\n\n  render() {\n    // This is a headless controller - no visual output\n    return null;\n  }\n}\n"]}