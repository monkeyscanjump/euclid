import{c as t}from"./p-Cpj4dy2_.js";const e={chains:[],tokens:[],pools:[],prices:{},loading:false,error:null,lastUpdated:0};const{state:n,onChange:s,reset:a,dispose:o}=t(e);const r={setLoading(t){n.loading=t},setError(t){n.error=t},setChains(t){n.chains=[...t];n.lastUpdated=Date.now()},setTokens(t){n.tokens=[...t];n.lastUpdated=Date.now()},setPools(t){n.pools=[...t];n.lastUpdated=Date.now()},setPrices(t){n.prices={...t};n.lastUpdated=Date.now()},addToken(t){n.tokens=[...n.tokens,t]},updateToken(t,e){n.tokens=n.tokens.map((n=>n.id===t?{...n,...e}:n))},clear(){a()}};const i={getChain:t=>n.chains.find((e=>e.chain_uid===t)),getToken:t=>n.tokens.find((e=>e.id===t)),getTokensByChain:t=>n.tokens.filter((e=>e.chain_uid===t)),getPool:t=>n.pools.find((e=>e.pool_id===t)),getPoolsForTokenPair:(t,e)=>n.pools.filter((n=>n.token_1===t&&n.token_2===e||n.token_1===e&&n.token_2===t)),getPrice:t=>n.prices[t]||0,isDataStale:(t=5*60*1e3)=>{if(!n.lastUpdated)return true;return Date.now()-n.lastUpdated>t}};const c={state:n,onChange:s,reset:a,dispose:o,...r,...i};if(typeof window!=="undefined"){window.marketStore=c}const u={token1:null,token2:null,amount1:"",amount2:"",token1Amount:"",token2Amount:"",pool:null,selectedPool:null,userLpBalance:"0",loading:false,error:null};const{state:l,onChange:d,reset:h,dispose:p}=t(u);const y={setLoading(t){l.loading=t},setError(t){l.error=t},setToken1(t){l.token1=t;if(l.pool&&t&&l.pool.token_1!==t.id&&l.pool.token_2!==t.id){l.pool=null}},setToken2(t){l.token2=t;if(l.pool&&t&&l.pool.token_1!==t.id&&l.pool.token_2!==t.id){l.pool=null}},setAmount1(t){l.amount1=t;l.token1Amount=t},setAmount2(t){l.amount2=t;l.token2Amount=t},setToken1Amount(t){y.setAmount1(t)},setToken2Amount(t){y.setAmount2(t)},setPool(t){l.pool=t;l.selectedPool=t},setSelectedPool(t){y.setPool(t)},setUserLpBalance(t){l.userLpBalance=t},swapTokens(){const t=l.token1;const e=l.token2;const n=l.amount1;const s=l.amount2;l.token1=e;l.token2=t;l.amount1=s;l.amount2=n},clear(){h()},setAddingLiquidity(t){l.loading=t},setRemovingLiquidity(t){l.loading=t},getPosition(t){console.warn(`getPosition(${t}) not implemented`);return null}};const m={canAddLiquidity:()=>!!(l.token1&&l.token2&&l.amount1&&l.amount2&&parseFloat(l.amount1)>0&&parseFloat(l.amount2)>0&&!l.loading),canRemoveLiquidity:()=>!!(l.pool&&l.userLpBalance&&parseFloat(l.userLpBalance)>0&&!l.loading),getPoolLiquidity:()=>l.pool?.total_liquidity||"0",getPoolVolume24h:()=>l.pool?.volume_24h||"0",getPoolFees24h:()=>l.pool?.fees_24h||"0",getPoolAPR:()=>l.pool?.apr||"0",isValidPair:()=>!!(l.token1&&l.token2&&l.token1.id!==l.token2.id)};const _={state:l,onChange:d,reset:h,dispose:p,...y,...m};const T="https://testnet.api.euclidprotocol.com/graphql";class E{constructor(t=T){this.endpoint=t}async query(t,e){try{const n=await fetch(this.endpoint,{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({query:t,variables:e||{}})});if(!n.ok){throw new Error(`HTTP error! status: ${n.status}`)}const s=await n.json();if(s.errors){throw new Error(`GraphQL error: ${s.errors.map((t=>t.message)).join(", ")}`)}return{success:true,data:s.data}}catch(t){console.error("GraphQL query failed:",t);return{success:false,error:t instanceof Error?t.message:"Unknown error"}}}async getChains(t){const e=`\n      query Chains($showAllChains: Boolean, $type: String) {\n        chains {\n          all_chains(show_all_chains: $showAllChains, type: $type) {\n            chain_id\n            chain_uid\n            display_name\n            factory_address\n            token_factory_address\n            explorer_url\n            logo\n            type\n          }\n        }\n      }\n    `;const n=await this.query(e,t);if(!n.success||!n.data){throw new Error(n.error||"Failed to fetch chains")}return n.data.chains.all_chains}async getTokenMetadata(t){const e=`\n      query Token(\n        $limit: Int,\n        $offset: Int,\n        $verified: Boolean,\n        $dex: [String!],\n        $chainUids: [String!],\n        $showVolume: Boolean,\n        $search: String\n      ) {\n        token {\n          token_metadatas(\n            limit: $limit,\n            offset: $offset,\n            verified: $verified,\n            dex: $dex,\n            chain_uids: $chainUids,\n            show_volume: $showVolume,\n            search: $search\n          ) {\n            coinDecimal\n            displayName\n            tokenId\n            description\n            image\n            price\n            price_change_24h\n            price_change_7d\n            dex\n            chain_uids\n            total_volume\n            total_volume_24h\n            tags\n            min_swap_value\n            social\n            is_verified\n          }\n        }\n      }\n    `;const n=await this.query(e,t);if(!n.success||!n.data){throw new Error(n.error||"Failed to fetch token metadata")}return n.data.token.token_metadatas}async getAllPools(t,e=true){try{const t=`\n        query Token_pair_with_liquidity($limit: Int, $onlyShowVerified: Boolean) {\n          pool {\n            token_pair_with_liquidity(limit: $limit, only_show_verified: $onlyShowVerified) {\n              results {\n                pair {\n                  token_1\n                  token_2\n                }\n                vlp\n                total_liquidity\n                apr\n                tags\n                created_at\n              }\n              pagination {\n                total_count\n                limit\n                offset\n              }\n            }\n          }\n        }\n      `;const n=await this.query(t,{limit:1e3,onlyShowVerified:e});if(!n.success||!n.data?.pool?.token_pair_with_liquidity?.results){throw new Error(n.error||"Failed to fetch pools with liquidity data")}const s=n.data.pool.token_pair_with_liquidity.results.map((t=>({pool_id:`${t.pair.token_1}-${t.pair.token_2}`,token_1:t.pair.token_1,token_2:t.pair.token_2,total_liquidity:t.total_liquidity,volume_24h:"0",fees_24h:"0",apr:t.apr})));console.log(`âœ… Loaded ${s.length} pools with real liquidity and APR data from official API`);return s}catch(t){console.error("Failed to fetch pools with liquidity data:",t);return[]}}async getUserBalances(t){const e=`\n      query Vcoin($user: CrossChainUserInput) {\n        vcoin {\n          user_balance(user: $user) {\n            balances {\n              amount\n              token_id\n            }\n          }\n        }\n      }\n    `;const n={user:{address:t.address,chain_uid:t.chain_uid}};const s=await this.query(e,n);if(!s.success||!s.data){throw new Error(s.error||"Failed to fetch user balances")}return s.data.vcoin.user_balance.balances}async getPoolInfo(t,e){const n=await this.getAllPools();return n.find((n=>n.token_1===t&&n.token_2===e||n.token_1===e&&n.token_2===t))||null}async searchTokens(t,e){const n={search:t};if(e){n.chainUids=[e]}const s=await this.getTokenMetadata(n);const a=t.toLowerCase();return s.filter((t=>t.displayName?.toLowerCase().includes(a)||t.tokenId?.toLowerCase().includes(a)||t.description?.toLowerCase().includes(a)||t.symbol?.toLowerCase().includes(a)||t.name?.toLowerCase().includes(a)))}async getTokenBySymbol(t,e){const n=await this.getTokenMetadata({chainUids:[e]});return n.find((e=>e.displayName?.toLowerCase()===t.toLowerCase()||e.symbol?.toLowerCase()===t.toLowerCase()))||null}}const f=new E;const w="https://testnet.api.euclidprotocol.com/api/v1";class A{constructor(t=w){this.endpoint=t}async request(t,e={}){try{const{method:n="GET",body:s,headers:a={}}=e;const o=await fetch(`${this.endpoint}${t}`,{method:n,headers:{"Content-Type":"application/json",Accept:"application/json",...a},body:s?JSON.stringify(s):undefined});if(!o.ok){const t=await o.text();throw new Error(`HTTP ${o.status}: ${t}`)}const r=await o.json();return{success:true,data:r}}catch(e){console.error(`REST API request failed (${t}):`,e);return{success:false,error:e instanceof Error?e.message:"Unknown error"}}}async getRoutes(t){const e=new URLSearchParams({amount_in:t.amount_in,token_in:t.token_in,token_out:t.token_out});if(t.external!==undefined){e.append("external",t.external.toString())}if(t.chain_uids&&t.chain_uids.length>0){t.chain_uids.forEach((t=>{e.append("chain_uids",t)}))}const n=await this.request(`/routes?${e}`);if(!n.success||!n.data){throw new Error(n.error||"Failed to fetch routes")}return n.data.paths}async buildSwapTransaction(t){const e=await this.request("/swap",{method:"POST",body:t});if(!e.success||!e.data){throw new Error(e.error||"Failed to build swap transaction")}return e.data}async buildAddLiquidityTransaction(t){const e=await this.request("/add_liquidity",{method:"POST",body:t});if(!e.success||!e.data){throw new Error(e.error||"Failed to build add liquidity transaction")}return e.data}async buildRemoveLiquidityTransaction(t){const e=await this.request("/remove_liquidity",{method:"POST",body:t});if(!e.success||!e.data){throw new Error(e.error||"Failed to build remove liquidity transaction")}return e.data}async simulateSwap(t){const e=new URLSearchParams({amount_in:t.amount_in,token_in:t.token_in,token_out:t.token_out});if(t.chain_uid){e.append("chain_uid",t.chain_uid)}const n=await this.request(`/simulate_swap?${e}`);if(!n.success||!n.data){throw new Error(n.error||"Failed to simulate swap")}return n.data}async getBestRoute(t){const e=await this.getRoutes(t);if(e.length===0){return null}return e.sort(((t,e)=>parseFloat(t.total_price_impact)-parseFloat(e.total_price_impact)))[0]}async getTransactionStatus(t,e){const n=await this.request(`/transaction/${t}?chain_uid=${e}`);if(!n.success||!n.data){throw new Error(n.error||"Failed to get transaction status")}return n.data}async estimateGas(t){const e=await this.request("/estimate_gas",{method:"POST",body:t});if(!e.success||!e.data){throw new Error(e.error||"Failed to estimate gas")}return e.data}}const g=new A;class S{constructor(){this.graphql=f;this.rest=g}async getChains(t){return this.graphql.getChains(t)}async getTokenMetadata(t){return this.graphql.getTokenMetadata(t)}async searchTokens(t,e){return this.graphql.searchTokens(t,e)}async getTokenBySymbol(t,e){return this.graphql.getTokenBySymbol(t,e)}async getAllPools(t=true){try{const e=await this.graphql.getAllPools(undefined,t);return{success:true,data:e}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to get pools"}}}async getPoolInfo(t,e){return this.graphql.getPoolInfo(t,e)}async getAllChains(t){try{const e=await this.getChains({showAllChains:t});return{success:true,data:e}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to get chains"}}}async getAllTokens(){try{const t=await this.getTokenMetadata();return{success:true,data:t}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to get tokens"}}}async getTokenDenoms(t){console.warn(`getTokenDenoms(${t}) is not implemented in Euclid API`);return{success:true,data:{router:{token_denoms:{denoms:[]}}}}}async getEscrows(t){console.warn(`getEscrows(${t}) is not implemented in Euclid API`);return{success:true,data:{router:{escrows:[]}}}}async getBalance(t,e){try{const n=await this.getUserBalances({address:t,chain_uid:e});const s={balance:{all:n.map((t=>({denom:t.token,amount:t.balance})))}};return{success:true,data:s}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to get balance"}}}async getUserBalances(t){return this.graphql.getUserBalances(t)}async getRoutes(t){return this.rest.getRoutes(t)}async getRoutesWrapped(t){try{const e=await this.getRoutes(t);return{success:true,data:{paths:e}}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to get routes"}}}async getRoutesLegacy(t){return this.getRoutesWrapped(t)}async getBestRoute(t){return this.rest.getBestRoute(t)}async simulateSwap(t){return this.rest.simulateSwap(t)}async createSwapTransaction(t){return this.rest.buildSwapTransaction(t)}async createSwapTransactionWrapped(t){try{const e=await this.createSwapTransaction(t);return{success:true,data:e}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to create swap transaction"}}}async buildSwapTransaction(t){return this.createSwapTransaction(t)}async createAddLiquidityTransaction(t){return this.rest.buildAddLiquidityTransaction(t)}async createAddLiquidityTransactionWrapped(t){try{const e=await this.createAddLiquidityTransaction(t);return{success:true,data:e}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to create add liquidity transaction"}}}async createRemoveLiquidityTransaction(t){return this.rest.buildRemoveLiquidityTransaction(t)}async createRemoveLiquidityTransactionWrapped(t){try{const e=await this.createRemoveLiquidityTransaction(t);return{success:true,data:e}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to create remove liquidity transaction"}}}async trackTransaction(t,e){console.warn(`trackTransaction(${t}, ${e}) not implemented`);return{status:"pending"}}async trackTransactionWrapped(t,e){try{const n=await this.trackTransaction(t,e);return{success:true,data:n}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to track transaction"}}}async buildAddLiquidityTransaction(t){return this.rest.buildAddLiquidityTransaction(t)}async buildRemoveLiquidityTransaction(t){return this.rest.buildRemoveLiquidityTransaction(t)}async getTransactionStatus(t,e){return this.rest.getTransactionStatus(t,e)}async estimateGas(t){return this.rest.estimateGas(t)}async getMarketData(){const[t,e,n]=await Promise.all([this.getChains(),this.getTokenMetadata(),this.getAllPools()]);const s=n.success?n.data||[]:[];return{chains:t,tokens:e,pools:s}}async getUserPortfolio(t){const[e,n,s]=await Promise.all([this.getUserBalances(t),this.getChains(),this.getTokenMetadata()]);return{balances:e,chains:n,tokens:s}}async getSwapQuote(t,e,n,s){const a={amount_in:n,token_in:t,token_out:e,chain_uids:s};const[o,r]=await Promise.all([this.getBestRoute(a),this.simulateSwap({amount_in:n,token_in:t,token_out:e}).catch((()=>({amount_out:"0",price_impact:"0"})))]);return{route:o,expectedOutput:r.amount_out,priceImpact:r.price_impact}}}const I=new S;const R={euclidGraphqlEndpoint:"https://testnet.api.euclidprotocol.com/graphql",euclidRestEndpoint:"https://testnet.api.euclidprotocol.com/api/v1",apiTimeout:1e4,devServerPort:3333,devServerHost:"localhost",nodeEnv:"development",features:{serviceWorker:true,darkMode:true,advancedRouting:true,transactionHistory:true,priceAlerts:false,limitOrders:false},refreshIntervals:{routes:3e4,marketData:3e5,balances:6e4},transactionTimeout:3e5,ui:{defaultSlippage:.5,animationDuration:250,zIndex:{modal:1e3,tooltip:1070,dropdown:1e3}},defaultChain:"osmosis-1",supportedChains:["cosmoshub-4","osmosis-1","juno-1","stargaze-1","ethereum","polygon","arbitrum","optimism"],defaultWallet:"keplr",supportedWallets:["keplr","metamask","walletconnect","coinbase"],logLevel:"info",debugMode:false,enablePerformanceMonitoring:false};const k={ETHEREUM:"ethereum",POLYGON:"polygon",ARBITRUM:"arbitrum",OPTIMISM:"optimism",COSMOS_HUB:"cosmoshub-4",OSMOSIS:"osmosis-1",JUNO:"juno-1",STARGAZE:"stargaze-1"};const O={METAMASK:"metamask",KEPLR:"keplr",WALLET_CONNECT:"walletconnect",COINBASE:"coinbase",OTHER:"other"};const N={SWAP:"swap",ADD_LIQUIDITY:"add_liquidity",REMOVE_LIQUIDITY:"remove_liquidity",TRANSFER:"transfer"};const L={PENDING:"pending",SUCCESS:"success",FAILED:"failed"};const P={CHAINS:"/api/chains",TOKENS:"/api/tokens",POOLS:"/api/pools",ROUTES:"/api/routes",BALANCES:"/api/balances",TRANSACTIONS:"/api/transactions",GRAPHQL:"/graphql"};const C={WALLET_PREFERENCES:"euclid_wallet_preferences",THEME:"euclid_theme",SLIPPAGE:"euclid_slippage",TRANSACTION_HISTORY:"euclid_transaction_history"};const D={SLIPPAGE:R.ui.defaultSlippage,ROUTE_REFRESH_INTERVAL:R.refreshIntervals.routes,MARKET_DATA_REFRESH_INTERVAL:R.refreshIntervals.marketData,BALANCE_REFRESH_INTERVAL:R.refreshIntervals.balances,TRANSACTION_TIMEOUT:R.transactionTimeout};const $={MODAL_Z_INDEX:R.ui.zIndex.modal,TOOLTIP_Z_INDEX:R.ui.zIndex.tooltip,DROPDOWN_Z_INDEX:R.ui.zIndex.dropdown,ANIMATION_DURATION:R.ui.animationDuration};const q={ETH_ADDRESS:/^0x[a-fA-F0-9]{40}$/,COSMOS_ADDRESS:/^[a-z0-9]{39,59}$/,DECIMAL_NUMBER:/^\d*\.?\d*$/,POSITIVE_NUMBER:/^[+]?([0-9]*[.])?[0-9]+$/};const F={WALLET_NOT_CONNECTED:"Wallet not connected",INSUFFICIENT_BALANCE:"Insufficient balance",INVALID_AMOUNT:"Invalid amount",NO_ROUTE_FOUND:"No route found for this swap",TRANSACTION_FAILED:"Transaction failed",NETWORK_ERROR:"Network error occurred",TIMEOUT:"Request timeout"};const b={WALLET_CONNECTED:"Wallet connected successfully",TRANSACTION_SUBMITTED:"Transaction submitted",TRANSACTION_CONFIRMED:"Transaction confirmed",LIQUIDITY_ADDED:"Liquidity added successfully",LIQUIDITY_REMOVED:"Liquidity removed successfully"};const v={SERVICE_WORKER:R.features.serviceWorker,DARK_MODE:R.features.darkMode,ADVANCED_ROUTING:R.features.advancedRouting,TRANSACTION_HISTORY:R.features.transactionHistory,PRICE_ALERTS:R.features.priceAlerts,LIMIT_ORDERS:R.features.limitOrders};export{P as A,k as C,D,F as E,v as F,q as P,C as S,N as T,$ as U,O as W,I as a,L as b,b as c,R as e,_ as l,c as m};
//# sourceMappingURL=p-BQd9lUWY.js.map