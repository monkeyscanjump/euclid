import{D as n}from"./p-9CRWQAc1.js";async function t(t,o,i){const r={...n,...i};const a=new AbortController;const e=setTimeout((()=>a.abort()),r.apiTimeout);try{const n=await fetch(r.graphqlEndpoint,{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({query:t,variables:o}),signal:a.signal});clearTimeout(e);if(!n.ok){throw new Error(`HTTP ${n.status}: ${n.statusText}`)}const i=await n.json();if(i.errors){throw new Error(`GraphQL errors: ${i.errors.map((n=>n.message)).join(", ")}`)}return i.data}catch(n){clearTimeout(e);const t=n instanceof Error?n.message:"Unknown error";throw new Error(`VLP query failed: ${t}`)}}async function o(n,o,i,r){const a=`\n    query All_pools($contract: String!, $pair: PairInput!, $limit: Int, $offset: Int) {\n      vlp(contract: $contract, pair: $pair) {\n        all_pools(limit: $limit, offset: $offset) {\n          pools {\n            pool_id\n            pair {\n              token_1\n              token_2\n            }\n            total_liquidity\n            fees_collected\n            volume_24h\n            apy\n          }\n          pagination {\n            total_count\n            limit\n            offset\n          }\n        }\n      }\n    }\n  `;const e=await t(a,{contract:n,pair:o,limit:i,offset:r});return e.vlp.all_pools}async function i(n,o,i,r){const a=`\n    query All_positions($contract: String!, $pair: PairInput!, $limit: Int, $offset: Int) {\n      vlp(contract: $contract, pair: $pair) {\n        all_positions(limit: $limit, offset: $offset) {\n          positions {\n            position_id\n            owner\n            pool_id\n            liquidity_amount\n            fees_earned\n            created_at\n            status\n          }\n          pagination {\n            total_count\n            limit\n            offset\n          }\n        }\n      }\n    }\n  `;const e=await t(a,{contract:n,pair:o,limit:i,offset:r});return e.vlp.all_positions}async function r(n,o,i){const r=`\n    query Asset_list($contract: String!, $pair: PairInput!) {\n      vlp(contract: $contract, pair: $pair) {\n        asset_list {\n          liquidity_token {\n            amount\n            denom\n          }\n          vlp_token {\n            amount\n            denom\n          }\n        }\n      }\n    }\n  `;const a=await t(r,{contract:n,pair:o});return a.vlp.asset_list}async function a(n,o,i,r,a){const e=`\n    query My_positions($contract: String!, $pair: PairInput!, $userAddress: String!, $limit: Int, $offset: Int) {\n      vlp(contract: $contract, pair: $pair) {\n        my_positions(user_address: $userAddress, limit: $limit, offset: $offset) {\n          positions {\n            position_id\n            pool_id\n            liquidity_amount\n            fees_earned\n            current_value\n            pnl\n            created_at\n          }\n          pagination {\n            total_count\n            limit\n            offset\n          }\n        }\n      }\n    }\n  `;const c=await t(e,{contract:n,pair:o,userAddress:i,limit:r,offset:a});return c.vlp.my_positions}async function e(n,o,i){const r=`\n    query Pool($contract: String!, $pair: PairInput!, $poolId: String!) {\n      vlp(contract: $contract, pair: $pair) {\n        pool(pool_id: $poolId) {\n          pool_id\n          pair {\n            token_1\n            token_2\n          }\n          total_liquidity\n          fees_collected\n          volume_24h\n          volume_7d\n          volume_30d\n          apy\n          fee_tier\n          reserves {\n            token_1_reserve\n            token_2_reserve\n          }\n          price_ratio\n          status\n        }\n      }\n    }\n  `;const a=await t(r,{contract:n,pair:o,poolId:i});return a.vlp.pool}async function c(n,o,i){const r=`\n    query Position($contract: String!, $pair: PairInput!, $positionId: String!) {\n      vlp(contract: $contract, pair: $pair) {\n        position(position_id: $positionId) {\n          position_id\n          owner\n          pool_id\n          liquidity_amount\n          fees_earned\n          current_value\n          initial_value\n          pnl\n          pnl_percentage\n          created_at\n          last_updated\n          status\n        }\n      }\n    }\n  `;const a=await t(r,{contract:n,pair:o,positionId:i});return a.vlp.position}async function s(n,o,i){const r=`\n    query Total_fees_collected($contract: String!, $pair: PairInput!, $timeframe: String) {\n      vlp(contract: $contract, pair: $pair) {\n        total_fees_collected(timeframe: $timeframe) {\n          total_fees\n          fees_by_token {\n            token_id\n            amount\n            value_usd\n          }\n          timeframe\n          collection_period {\n            start_date\n            end_date\n          }\n        }\n      }\n    }\n  `;const a=await t(r,{contract:n,pair:o,timeframe:i});return a.vlp.total_fees_collected}export{o as getAllPoolsImpl,i as getAllPositionsImpl,r as getAssetListImpl,a as getMyPositionsImpl,e as getPoolImpl,c as getPositionImpl,s as getTotalFeesCollectedImpl};
//# sourceMappingURL=p-C26UM063.js.map