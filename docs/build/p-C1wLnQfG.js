import{c as t}from"./p-BbQ0yLPq.js";import{l as n}from"./p-b11lwN92.js";import{D as e}from"./p-9CRWQAc1.js";const a=["metamask","keplr","phantom"];const o=["metamask","keplr","phantom","cosmostation","walletconnect","custom"];const r=["metamask","phantom","walletconnect"];const s=["keplr","cosmostation"];function i(t){return a.includes(t)}function c(t){return o.includes(t)}function l(t){return r.includes(t)}function d(t){return s.includes(t)}class u{constructor(){this.type="metamask"}isAvailable(){return typeof window!=="undefined"&&Boolean(window.ethereum?.isMetaMask)}async connect(t){if(!this.isAvailable()){throw new Error("MetaMask is not installed")}try{const n=await window.ethereum.request({method:"eth_requestAccounts"});if(!n||n.length===0){throw new Error("No accounts found")}const e=await window.ethereum.request({method:"eth_chainId"});if(t&&t!==e){await this.switchChain(t)}return{address:n[0],chainId:t||e}}catch(t){throw new Error(`Failed to connect MetaMask: ${t.message}`)}}async disconnect(){n.info("MetaMaskAdapter","MetaMask disconnect requested")}async getCurrentAccount(){if(!this.isAvailable()){return null}try{const t=await window.ethereum.request({method:"eth_accounts"});if(!t||t.length===0){return null}const n=await window.ethereum.request({method:"eth_chainId"});let e;try{e=window.ethereum.isMetaMask?"MetaMask":"EVM Wallet"}catch{e="MetaMask"}return{address:t[0],chainId:parseInt(n,16).toString(),name:e}}catch(t){n.warn("MetaMaskAdapter","Failed to get current MetaMask account",t);return null}}async getBalance(t){if(!this.isAvailable()){throw new Error("MetaMask is not available")}try{const n=await window.ethereum.request({method:"eth_getBalance",params:[t,"latest"]});return n}catch(t){throw new Error(`Failed to get balance: ${t.message}`)}}async signAndBroadcast(t){if(!this.isAvailable()){throw new Error("MetaMask is not available")}if(t.type!=="evm"){throw new Error("MetaMask can only handle EVM transactions")}try{const n=await window.ethereum.request({method:"eth_sendTransaction",params:t.msgs.map((n=>({from:t.sender.address,to:n.to,data:n.data,value:n.value,gasLimit:n.gasLimit})))});return n}catch(t){throw new Error(`Failed to send transaction: ${t.message}`)}}async switchChain(t){if(!this.isAvailable()){throw new Error("MetaMask is not available")}try{await window.ethereum.request({method:"wallet_switchEthereumChain",params:[{chainId:t}]})}catch(t){if(t.code===4902){throw new Error("Chain not added to MetaMask. Please add the chain first.")}throw new Error(`Failed to switch chain: ${t.message}`)}}async addChain(t){if(!this.isAvailable()){throw new Error("MetaMask is not available")}if(t.type!=="EVM"){throw new Error("MetaMask only supports EVM chains")}try{await window.ethereum.request({method:"wallet_addEthereumChain",params:[{chainId:t.chain_id,chainName:t.display_name,nativeCurrency:{name:"ETH",symbol:"ETH",decimals:18},rpcUrls:[t.explorer_url],blockExplorerUrls:[t.explorer_url]}]})}catch(t){throw new Error(`Failed to add chain: ${t.message}`)}}}class h{constructor(){this.type="keplr"}isAvailable(){return typeof window!=="undefined"&&Boolean(window.keplr)}async connect(t){if(!this.isAvailable()){throw new Error("Keplr is not installed")}try{const n=t||"cosmoshub-4";await window.keplr.enable(n);const e=window.keplr.getOfflineSigner(n);const a=await e.getAccounts();if(!a||a.length===0){throw new Error("No accounts found")}return{address:a[0].address,chainId:n}}catch(t){throw new Error(`Failed to connect Keplr: ${t.message}`)}}async disconnect(){n.info("KeplrAdapter","Keplr disconnect requested")}async getCurrentAccount(){if(!this.isAvailable()){return null}try{const t="cosmoshub-4";const n=window.keplr.getOfflineSigner(t);const e=await n.getAccounts();if(!e||e.length===0){return null}let a;try{a=e[0].name||"Keplr Wallet"}catch{a="Keplr Wallet"}return{address:e[0].address,chainId:t,name:a}}catch(t){n.warn("Utils","Failed to get current Keplr account:",t);return null}}async getBalance(t){throw new Error("Balance checking not implemented for Keplr")}async signAndBroadcast(t){if(!this.isAvailable()){throw new Error("Keplr is not available")}if(t.type!=="cosmwasm"){throw new Error("Keplr can only handle CosmWasm transactions")}try{throw new Error("CosmWasm transaction signing not fully implemented")}catch(t){throw new Error(`Failed to send transaction: ${t.message}`)}}async switchChain(t){if(!this.isAvailable()){throw new Error("Keplr is not available")}try{await window.keplr.enable(t)}catch(n){throw new Error(`Failed to switch to chain ${t}: ${n.message}`)}}async addChain(t){if(!this.isAvailable()){throw new Error("Keplr is not available")}if(t.type!=="Cosmwasm"){throw new Error("Keplr only supports Cosmos chains")}try{await window.keplr.experimentalSuggestChain({chainId:t.chain_id,chainName:t.display_name,rpc:t.explorer_url,rest:t.explorer_url,bip44:{coinType:118},bech32Config:{bech32PrefixAccAddr:"cosmos",bech32PrefixAccPub:"cosmospub",bech32PrefixValAddr:"cosmosvaloper",bech32PrefixValPub:"cosmosvaloperpub",bech32PrefixConsAddr:"cosmosvalcons",bech32PrefixConsPub:"cosmosvalconspub"},currencies:[{coinDenom:"ATOM",coinMinimalDenom:"uatom",coinDecimals:6}],feeCurrencies:[{coinDenom:"ATOM",coinMinimalDenom:"uatom",coinDecimals:6}],stakeCurrency:{coinDenom:"ATOM",coinMinimalDenom:"uatom",coinDecimals:6}})}catch(t){throw new Error(`Failed to add chain: ${t.message}`)}}}class w{constructor(){this.type="phantom"}isAvailable(){return typeof window!=="undefined"&&Boolean(window.solana?.isPhantom)}async connect(t){if(!this.isAvailable()){throw new Error("Phantom is not installed")}try{const n=await window.solana.connect();return{address:n.publicKey.toString(),chainId:t||"mainnet-beta"}}catch(t){throw new Error(`Failed to connect Phantom: ${t.message}`)}}async disconnect(){if(this.isAvailable()){await window.solana.disconnect()}}async getCurrentAccount(){if(!this.isAvailable()){return null}try{const t=await window.solana.connect();if(!t?.publicKey){return null}const n="solana-mainnet";let e;try{e=window.solana.isPhantom?"Phantom":"Solana Wallet"}catch{e="Phantom"}return{address:t.publicKey.toString(),chainId:n,name:e}}catch{return null}}async getBalance(t){throw new Error("Balance checking not implemented for Phantom")}async signAndBroadcast(t){throw new Error("Solana transaction signing not implemented")}async switchChain(t){n.info("Utils",`Chain switching not supported by Phantom: ${t}`)}async addChain(t){throw new Error("Adding chains not supported by Phantom")}}class p{constructor(){this.adapters=new Map;this.adapters.set("metamask",new u);this.adapters.set("keplr",new h);this.adapters.set("phantom",new w)}getAdapter(t){let n=t;if(t==="cosmostation")n="keplr";if(t==="walletconnect")n="metamask";if(t==="custom")n="metamask";const e=this.adapters.get(n);if(!e){throw new Error(`Wallet adapter not found for type: ${t}`)}return e}getAvailableAdapters(){return Array.from(this.adapters.values()).filter((t=>t.isAvailable()))}getAvailableWalletTypes(){return this.getAvailableAdapters().map((t=>t.type)).filter((t=>a.includes(t)))}}const y=new p;class m{constructor(t="euclid-storage",n={}){this.db=null;this.cryptoKey=null;this.initPromise=null;this.dbName=t;this.version=n.version||1}async init(){if(this.initPromise){return this.initPromise}this.initPromise=this._init();return this.initPromise}async _init(){await Promise.all([this.initDatabase(),this.initCrypto()])}async initDatabase(){return new Promise(((t,n)=>{const e=indexedDB.open(this.dbName,this.version);e.onerror=()=>{n(new Error(`Failed to open database: ${e.error?.message}`))};e.onsuccess=()=>{this.db=e.result;t()};e.onupgradeneeded=t=>{const n=t.target.result;const e=["wallet-data","user-preferences","app-state","cache"];for(const t of e){if(!n.objectStoreNames.contains(t)){const e=n.createObjectStore(t,{keyPath:"key"});e.createIndex("timestamp","timestamp",{unique:false})}}}}))}async initCrypto(){if(!window.crypto?.subtle){n.warn("Utils","Web Crypto API not available - storage will not be encrypted");return}try{const t=await this.getStoredCryptoKey();if(!t){this.cryptoKey=await window.crypto.subtle.generateKey({name:"AES-GCM",length:256},true,["encrypt","decrypt"]);await this.storeCryptoKey(this.cryptoKey)}else{this.cryptoKey=await window.crypto.subtle.importKey("jwk",t,{name:"AES-GCM"},true,["encrypt","decrypt"])}}catch(t){n.warn("Utils","Failed to initialize encryption:",t)}}async getStoredCryptoKey(){try{const t=localStorage.getItem("euclid-crypto-key");return t?JSON.parse(t):null}catch{return null}}async storeCryptoKey(t){try{const n=await window.crypto.subtle.exportKey("jwk",t);localStorage.setItem("euclid-crypto-key",JSON.stringify(n))}catch(t){n.warn("Utils","Failed to store crypto key:",t)}}async encrypt(t){if(!this.cryptoKey||!window.crypto?.subtle){throw new Error("Encryption not available")}const n=window.crypto.getRandomValues(new Uint8Array(12));const e=(new TextEncoder).encode(JSON.stringify(t));const a=await window.crypto.subtle.encrypt({name:"AES-GCM",iv:n.buffer},this.cryptoKey,e);return{encrypted:a,iv:n}}async decrypt(t,n){if(!this.cryptoKey||!window.crypto?.subtle){throw new Error("Decryption not available")}const e=await window.crypto.subtle.decrypt({name:"AES-GCM",iv:n.buffer},this.cryptoKey,t);const a=(new TextDecoder).decode(e);return JSON.parse(a)}async setItem(t,e,a,o={}){await this.init();if(!this.db){throw new Error("Database not initialized")}const r=o.encrypt!==false&&t==="wallet-data";let s=a;let i=false;if(r&&this.cryptoKey){try{const{encrypted:t,iv:n}=await this.encrypt(a);s={data:Array.from(new Uint8Array(t)),iv:Array.from(n)};i=true}catch(t){n.warn("Utils","Encryption failed, storing unencrypted:",t)}}const c={key:e,value:s,timestamp:Date.now(),encrypted:i};return new Promise(((n,e)=>{const a=this.db.transaction([t],"readwrite");const o=a.objectStore(t);const r=o.put(c);r.onsuccess=()=>n();r.onerror=()=>e(new Error(`Failed to store item: ${r.error?.message}`))}))}async getItem(t,e){await this.init();if(!this.db){throw new Error("Database not initialized")}return new Promise(((a,o)=>{const r=this.db.transaction([t],"readonly");const s=r.objectStore(t);const i=s.get(e);i.onsuccess=async()=>{const t=i.result;if(!t){a(null);return}if(t.encrypted&&this.cryptoKey){try{const n=t.value;const e=new Uint8Array(n.data);const o=new Uint8Array(n.iv);const r=await this.decrypt(e.buffer,o);a(r)}catch(t){n.error("Utils","Decryption failed:",t);a(null)}}else{a(t.value)}};i.onerror=()=>o(new Error(`Failed to retrieve item: ${i.error?.message}`))}))}async removeItem(t,n){await this.init();if(!this.db){throw new Error("Database not initialized")}return new Promise(((e,a)=>{const o=this.db.transaction([t],"readwrite");const r=o.objectStore(t);const s=r.delete(n);s.onsuccess=()=>e();s.onerror=()=>a(new Error(`Failed to remove item: ${s.error?.message}`))}))}async clear(t){await this.init();if(!this.db){throw new Error("Database not initialized")}return new Promise(((n,e)=>{const a=this.db.transaction([t],"readwrite");const o=a.objectStore(t);const r=o.clear();r.onsuccess=()=>n();r.onerror=()=>e(new Error(`Failed to clear store: ${r.error?.message}`))}))}async getAllKeys(t){await this.init();if(!this.db){throw new Error("Database not initialized")}return new Promise(((n,e)=>{const a=this.db.transaction([t],"readonly");const o=a.objectStore(t);const r=o.getAllKeys();r.onsuccess=()=>n(r.result);r.onerror=()=>e(new Error(`Failed to get keys: ${r.error?.message}`))}))}async cleanupCache(t=24*60*60*1e3){await this.init();if(!this.db){throw new Error("Database not initialized")}const n=Date.now()-t;return new Promise(((t,e)=>{const a=this.db.transaction(["cache"],"readwrite");const o=a.objectStore("cache");const r=o.index("timestamp");const s=r.openCursor(IDBKeyRange.upperBound(n));s.onsuccess=n=>{const e=n.target.result;if(e){e.delete();e.continue()}else{t()}};s.onerror=()=>e(new Error(`Failed to cleanup cache: ${s.error?.message}`))}))}close(){if(this.db){this.db.close();this.db=null}this.initPromise=null}}const f=new m;const _={async setConnectedWallets(t){let n;if(t instanceof Map){n=Object.fromEntries(t)}else{n=t}return f.setItem("wallet-data","connected-wallets",n,{encrypt:true})},async getConnectedWallets(){const t=await f.getItem("wallet-data","connected-wallets");return t?new Map(Object.entries(t)):new Map},async getConnectedWalletsAsObject(){const t=await f.getItem("wallet-data","connected-wallets");return t||{}},async setAddressBook(t){return f.setItem("wallet-data","address-book",t,{encrypt:true})},async getAddressBook(){return await f.getItem("wallet-data","address-book")||[]},async clearWalletData(){return f.clear("wallet-data")}};async function g(){const t=[{old:"euclid-address-book",new:"address-book",store:"wallet-data"}];for(const e of t){try{const t=localStorage.getItem(e.old);if(t){const a=JSON.parse(t);await f.setItem(e.store,e.new,a);localStorage.removeItem(e.old);n.info("Utils",`Migrated ${e.old} to IndexedDB`)}}catch(t){n.warn("Utils",`Failed to migrate ${e.old}:`,t)}}}function k(t){if(!t?.trim())return[];return t.split(",").map((t=>t.trim())).filter((t=>t.length>0))}function T(t,n){if(!t?.trim())return n;try{return JSON.parse(t)}catch{return n}}const E=new Map;function I(t){if(E.has(t)){return E.get(t)}const n=JSON.stringify(t);E.set(t,n);return n}const S={Chain:["chain"],Token:["token"],Pool:["pool"],Routing:["route"],Transaction:["transaction","tx"],User:["user","balance"],Swap:["swap"],Liquidity:["liquidity"]};function A(t){const n=t.toLowerCase();for(const[t,e]of Object.entries(S)){if(e.some((t=>n.includes(t)))){return t}}return"Other"}function $(t){return t.replace(/([A-Z])/g," $1").replace(/^./,(t=>t.toUpperCase())).trim()}function b(t){return Boolean(t?.length)}const P={address:null,chainId:null,chainUID:null,walletType:null,balances:[],loading:false,error:null,connectedWallets:{},wallets:{},totalWalletCount:0,lastSync:0};const{state:v,onChange:F,reset:O,dispose:C}=t(P);const M={smartUpdate:t=>{Object.assign(v,t)}};const D={setLoading(t){v.loading=t},setError(t){v.error=t},async initialize(){await g();try{const t=await _.getConnectedWalletsAsObject();if(b(Object.keys(t))){M.smartUpdate({connectedWallets:t,wallets:t,totalWalletCount:Object.keys(t).length,lastSync:Date.now()});const n=Object.values(t)[0];if(n){M.smartUpdate({address:n.address,chainUID:n.chainUID,walletType:n.walletType,balances:[...n.balances]})}}}catch(t){n.warn("WalletStore","Failed to load persisted wallets",t)}n.info("WalletStore","Wallet store initialized")},async connectWallet(t,e){if(!i(t)){throw new Error(`Unsupported wallet type: ${t}`)}v.loading=true;v.error=null;try{const a=y.getAdapter(t);if(!a.isAvailable()){throw new Error(`${t} wallet is not installed`)}const o=await a.connect(e);v.address=o.address;v.chainId=o.chainId;v.chainUID=o.chainId;v.walletType=t;v.error=null;const r=o.chainId;D.addWallet(r,{address:o.address,walletType:t,balances:[],autoConnect:false});n.info("WalletStore","Wallet connected and added to both old and new structures",{address:o.address,chainUID:r,walletType:t})}catch(t){v.error=t instanceof Error?t.message:"Failed to connect wallet"}finally{v.loading=false}},async disconnectWallet(t){if(t){D.removeWallet(t)}else{if(v.walletType&&i(v.walletType)){try{const t=y.getAdapter(v.walletType);await t.disconnect()}catch(t){n.warn("WalletStore","Error disconnecting wallet",t)}}M.smartUpdate({address:null,chainId:null,chainUID:null,walletType:null,balances:[],connectedWallets:{},wallets:{},totalWalletCount:0,lastSync:Date.now(),error:null});try{await _.setConnectedWallets({})}catch(t){n.warn("WalletStore","Failed to clear persisted wallets",t)}}},setBalances(t){v.balances=[...t]},updateBalance(t,n){const e=v.balances.findIndex((n=>n.token===t));const a={amount:n,token_id:t,token:t,balance:n,chain_uid:v.chainUID||"",token_type:{native:{denom:t}}};if(e>=0){v.balances[e]=a}else{v.balances.push(a)}},async switchChain(t){if(!v.walletType||!i(v.walletType)){throw new Error("No supported wallet connected")}v.loading=true;v.error=null;try{v.chainId=t;v.chainUID=t;v.error=null}catch(t){v.error=t instanceof Error?t.message:"Failed to switch chain"}finally{v.loading=false}},clear(){O()},addWallet(t,e){n.debug("WalletStore","addWallet() called with",{chainUID:t,walletInfo:e});const a={...e,chainUID:t,name:e.name||e.walletType,addedAt:new Date,lastUsed:new Date};const o={...v.connectedWallets,[t]:a};n.debug("WalletStore","Adding wallet to store",{chainUID:t,address:e.address,walletType:e.walletType,totalWallets:Object.keys(v.connectedWallets).length+1});M.smartUpdate({connectedWallets:o,wallets:o,totalWalletCount:Object.keys(o).length,lastSync:Date.now()});if(!v.address){n.debug("WalletStore","Setting as primary wallet (no existing primary)");M.smartUpdate({address:e.address,chainUID:t,walletType:e.walletType,balances:[...e.balances]})}else{n.debug("WalletStore","Primary wallet already exists, keeping it as primary")}_.setConnectedWallets(o).catch((t=>{n.warn("Utils","Failed to persist wallet connections:",t)}))},removeWallet(t){const e={...v.connectedWallets};delete e[t];M.smartUpdate({connectedWallets:e,wallets:e,totalWalletCount:Object.keys(e).length,lastSync:Date.now()});if(v.chainUID===t){const t=Object.values(e);if(t.length>0){const n=t[0];M.smartUpdate({address:n.address,chainUID:n.chainUID,walletType:n.walletType,balances:[...n.balances]})}else{M.smartUpdate({address:null,chainUID:null,walletType:null,balances:[]})}}_.setConnectedWallets(e).catch((t=>{n.warn("Utils","Failed to persist wallet connections:",t)}))},updateWalletBalances(t,e){const a=v.connectedWallets[t];if(a){const o={...a,balances:[...e],lastUsed:new Date};const r={...v.connectedWallets,[t]:o};M.smartUpdate({connectedWallets:r,wallets:r,lastSync:Date.now()});if(v.chainUID===t){M.smartUpdate({balances:[...e]})}_.setConnectedWallets(r).catch((t=>{n.warn("Utils","Failed to persist wallet connections:",t)}))}},getAllWalletsAsMap(){return new Map(Object.entries(v.connectedWallets))},getAllWalletsAsArray(){return Object.values(v.connectedWallets)},getWalletByChain(t){return v.connectedWallets[t]||null}};const R={getBalance:t=>v.balances.find((n=>n.token===t)),getFormattedBalance:(t,n=18)=>{const e=R.getBalance(t);if(!e)return"0";try{const t=BigInt(e.balance);const a=BigInt(10**n);const o=t/a;const r=t%a;return`${o.toString()}.${r.toString().padStart(n,"0")}`}catch{return"0"}},hasSufficientBalance:(t,n,e)=>{if(typeof e==="string"&&n&&e){const a=t;const o=n;const r=e;const s=v.connectedWallets[a];if(!s)return false;const i=s.balances.find((t=>t.token===o));if(!i)return false;try{return BigInt(i.balance)>=BigInt(r)}catch{return false}}else{const e=t;const a=n||"";const o=R.getBalance(e);if(!o)return false;try{return BigInt(o.balance)>=BigInt(a)}catch{return false}}},isWalletAvailable:t=>{try{if(i(t)){const n=y.getAdapter(t);return n.isAvailable()}return false}catch{return false}},getAvailableWallets:()=>y.getAvailableWalletTypes(),hasWallet:t=>!!v.connectedWallets[t],getAllWallets:()=>Object.values(v.connectedWallets),isWalletConnected:t=>!!v.connectedWallets[t],getAllConnectedWallets:()=>Object.values(v.connectedWallets),getWalletBalance:(t,n)=>{const e=v.connectedWallets[t];if(!e)return null;return e.balances.find((t=>t.token===n||t.token.toLowerCase()===n.toLowerCase()))},getWallet:t=>v.connectedWallets[t]||null,addTransaction:(t,e)=>{n.info("Utils",`Transaction added for ${t}:`,e)},updateTransactionStatus:(t,e,a)=>{n.info("Utils",`Transaction ${e} on ${t} updated to status: ${a}`)}};const q={state:v,onChange:F,reset:O,dispose:C,...D,...R};const U={walletModalOpen:false,walletModalFilter:null,tokenModalOpen:false,tokenSelectorType:null,isInitialized:false,theme:"auto"};const{state:N,onChange:W,reset:L,dispose:B}=t(U);const x={initialize(){N.isInitialized=true},openWalletModal(t){N.walletModalOpen=true;N.walletModalFilter=t||null},closeWalletModal(){N.walletModalOpen=false;N.walletModalFilter=null},openTokenModal(t="input"){N.tokenModalOpen=true;N.tokenSelectorType=t},closeTokenModal(){N.tokenModalOpen=false;N.tokenSelectorType=null},setTheme(t){N.theme=t},clear(){L()}};const V={state:N,onChange:W,reset:L,dispose:B,...x};const j={tokenIn:null,tokenOut:null,fromToken:null,toToken:null,amountIn:"",amountOut:"",fromAmount:"",toAmount:"",routes:[],selectedRoute:null,slippage:.5,loading:false,error:null};const{state:K,onChange:H,reset:G,dispose:z}=t(j);const J={setTokenIn(t){K.tokenIn=t;K.fromToken=t;K.routes=[];K.selectedRoute=null;K.amountOut="";K.toAmount=""},setTokenOut(t){K.tokenOut=t;K.toToken=t;K.routes=[];K.selectedRoute=null;K.amountOut="";K.toAmount=""},setFromToken(t){J.setTokenIn(t)},setToToken(t){J.setTokenOut(t)},setAmountIn(t){K.amountIn=t;K.fromAmount=t;if(!t){K.amountOut="";K.toAmount="";K.routes=[];K.selectedRoute=null}},setAmountOut(t){K.amountOut=t;K.toAmount=t},setFromAmount(t){J.setAmountIn(t)},setToAmount(t){J.setAmountOut(t)},setRoutes(t){K.routes=[...t];K.loading=false;K.error=null;if(t.length>0){J.setSelectedRoute(t[0])}},setSelectedRoute(t){K.selectedRoute=t;if(t&&t.path.length>0){const n=t.path[t.path.length-1];K.amountOut=n.amount_out}},setLoading(t){K.loading=t},setError(t){K.error=t},setSlippage(t){K.slippage=t},setLoadingRoutes(t){K.loading=t},setSwapping(t){K.loading=t},swapTokens(){const t=K.tokenIn;const n=K.tokenOut;const e=K.amountIn;K.tokenIn=n;K.tokenOut=t;K.fromToken=n;K.toToken=t;K.amountIn="";K.amountOut=e;K.fromAmount="";K.toAmount=e;K.routes=[];K.selectedRoute=null;K.error=null},clear(){G()}};const Q={canSwap:()=>!!(K.tokenIn&&K.tokenOut&&K.amountIn&&parseFloat(K.amountIn)>0&&K.selectedRoute&&!K.loading),getPriceImpact:()=>K.selectedRoute?.total_price_impact||"0",getEstimatedGas:()=>{if(!K.selectedRoute)return"0";const t=K.selectedRoute.path.length;return(t*1e5).toString()},isValidPair:()=>!!(K.tokenIn&&K.tokenOut&&K.tokenIn.id!==K.tokenOut.id),getSlippageAmount:()=>{if(!K.amountOut||!K.slippage)return"0";try{const t=BigInt(K.amountOut);const n=BigInt(Math.floor(K.slippage*100));const e=t*n/BigInt(1e4);const a=t-e;return a.toString()}catch{return"0"}}};const Y={state:K,onChange:H,reset:G,dispose:z,...J,...Q};const Z={token1:null,token2:null,amount1:"",amount2:"",token1Amount:"",token2Amount:"",pool:null,selectedPool:null,userLpBalance:"0",loading:false,error:null};const{state:X,onChange:tt,reset:nt,dispose:et}=t(Z);const at={setLoading(t){X.loading=t},setError(t){X.error=t},setToken1(t){X.token1=t;if(X.pool&&t&&X.pool.token_1!==t.id&&X.pool.token_2!==t.id){X.pool=null}},setToken2(t){X.token2=t;if(X.pool&&t&&X.pool.token_1!==t.id&&X.pool.token_2!==t.id){X.pool=null}},setAmount1(t){X.amount1=t;X.token1Amount=t},setAmount2(t){X.amount2=t;X.token2Amount=t},setToken1Amount(t){at.setAmount1(t)},setToken2Amount(t){at.setAmount2(t)},setPool(t){X.pool=t;X.selectedPool=t},setSelectedPool(t){at.setPool(t)},setUserLpBalance(t){X.userLpBalance=t},swapTokens(){const t=X.token1;const n=X.token2;const e=X.amount1;const a=X.amount2;X.token1=n;X.token2=t;X.amount1=a;X.amount2=e},clear(){nt()},setAddingLiquidity(t){X.loading=t},setRemovingLiquidity(t){X.loading=t},getPosition(t){n.warn("LiquidityStore",`getPosition(${t}) not implemented`);return null}};const ot={canAddLiquidity:()=>!!(X.token1&&X.token2&&X.amount1&&X.amount2&&parseFloat(X.amount1)>0&&parseFloat(X.amount2)>0&&!X.loading),canRemoveLiquidity:()=>!!(X.pool&&X.userLpBalance&&parseFloat(X.userLpBalance)>0&&!X.loading),getPoolLiquidity:()=>X.pool?.total_liquidity||"0",getPoolVolume24h:()=>X.pool?.volume_24h||"0",getPoolFees24h:()=>X.pool?.fees_24h||"0",getPoolAPR:()=>X.pool?.apr||"0",isValidPair:()=>!!(X.token1&&X.token2&&X.token1.id!==X.token2.id)};const rt={state:X,onChange:tt,reset:nt,dispose:et,...at,...ot};class st{constructor(t){const n={...e,...t};this.endpoint=n.graphqlEndpoint;this.timeout=n.apiTimeout}async query(t,e){const a=new AbortController;const o=setTimeout((()=>a.abort()),this.timeout);try{const n=await fetch(this.endpoint,{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({query:t,variables:e||{}}),signal:a.signal});clearTimeout(o);if(!n.ok){throw new Error(`HTTP error! status: ${n.status}`)}const r=await n.json();if(r.errors){throw new Error(`GraphQL error: ${r.errors.map((t=>t.message)).join(", ")}`)}return{success:true,data:r.data}}catch(t){clearTimeout(o);n.error("Utils","GraphQL query failed:",t);return{success:false,error:t instanceof Error?t.message:"Unknown error"}}}async getChains(t){const n=`\n      query Chains($showAllChains: Boolean, $type: String) {\n        chains {\n          all_chains(show_all_chains: $showAllChains, type: $type) {\n            chain_id\n            chain_uid\n            display_name\n            factory_address\n            token_factory_address\n            explorer_url\n            logo\n            type\n          }\n        }\n      }\n    `;const e=await this.query(n,t);if(!e.success||!e.data){throw new Error(e.error||"Failed to fetch chains")}return e.data.chains.all_chains}async getTokenMetadata(t){const n=`\n      query Token(\n        $limit: Int,\n        $offset: Int,\n        $verified: Boolean,\n        $dex: [String!],\n        $chainUids: [String!],\n        $showVolume: Boolean,\n        $search: String\n      ) {\n        token {\n          token_metadatas(\n            limit: $limit,\n            offset: $offset,\n            verified: $verified,\n            dex: $dex,\n            chain_uids: $chainUids,\n            show_volume: $showVolume,\n            search: $search\n          ) {\n            coinDecimal\n            displayName\n            tokenId\n            description\n            image\n            price\n            price_change_24h\n            price_change_7d\n            dex\n            chain_uids\n            total_volume\n            total_volume_24h\n            tags\n            min_swap_value\n            social\n            is_verified\n          }\n        }\n      }\n    `;const e=await this.query(n,t);if(!e.success||!e.data){throw new Error(e.error||"Failed to fetch token metadata")}return e.data.token.token_metadatas}async getAllPools(t,e=true){try{const t=`\n        query Token_pair_with_liquidity($limit: Int, $onlyShowVerified: Boolean) {\n          pool {\n            token_pair_with_liquidity(limit: $limit, only_show_verified: $onlyShowVerified) {\n              results {\n                pair {\n                  token_1\n                  token_2\n                }\n                vlp\n                total_liquidity\n                apr\n                tags\n                created_at\n              }\n              pagination {\n                total_count\n                limit\n                offset\n              }\n            }\n          }\n        }\n      `;const a=await this.query(t,{limit:1e3,onlyShowVerified:e});if(!a.success||!a.data?.pool?.token_pair_with_liquidity?.results){throw new Error(a.error||"Failed to fetch pools with liquidity data")}const o=a.data.pool.token_pair_with_liquidity.results.map((t=>({pool_id:`${t.pair.token_1}-${t.pair.token_2}`,token_1:t.pair.token_1,token_2:t.pair.token_2,total_liquidity:t.total_liquidity,volume_24h:"0",fees_24h:"0",apr:t.apr})));n.info("Utils",`✅ Loaded ${o.length} pools with real liquidity and APR data from official API`);return o}catch(t){n.error("Utils","Failed to fetch pools with liquidity data:",t);return[]}}async getUserBalances(t){const n=`\n      query Vcoin($user: CrossChainUserInput) {\n        vcoin {\n          user_balance(user: $user) {\n            balances {\n              amount\n              token_id\n            }\n          }\n        }\n      }\n    `;const e={user:{address:t.address,chain_uid:t.chain_uid}};const a=await this.query(n,e);if(!a.success||!a.data){throw new Error(a.error||"Failed to fetch user balances")}return a.data.vcoin.user_balance.balances}async getPoolInfo(t,n){const e=await this.getAllPools();return e.find((e=>e.token_1===t&&e.token_2===n||e.token_1===n&&e.token_2===t))||null}async getPoolById(t){const n=`\n      query Pool($poolId: String!) {\n        pool {\n          pool_by_id(pool_id: $poolId) {\n            pool_id\n            token_1\n            token_2\n            total_liquidity\n            volume_24h\n            volume_7d\n            fees_24h\n            apr\n            apy\n            tvl_change_24h\n            volume_change_24h\n            pool_address\n            dex\n            chain_uid\n            created_at\n            fee_rate\n            tags\n          }\n        }\n      }\n    `;const e=await this.query(n,{poolId:t});if(!e.success||!e.data?.pool?.pool_by_id){return null}return e.data.pool.pool_by_id}async getPoolStatistics(t,n="24h"){const e=`\n      query Pool($poolId: String!, $timeframe: String!) {\n        pool {\n          statistics(pool_id: $poolId, timeframe: $timeframe) {\n            liquidity_metrics {\n              current_liquidity\n              liquidity_change\n              liquidity_change_percentage\n              token_1_reserve\n              token_2_reserve\n            }\n            volume_metrics {\n              volume\n              volume_change\n              volume_change_percentage\n              trade_count\n            }\n            fee_metrics {\n              fees_collected\n              fee_rate\n              protocol_fees\n              lp_fees\n            }\n            price_metrics {\n              current_price\n              price_change\n              price_change_percentage\n              high\n              low\n            }\n          }\n        }\n      }\n    `;const a=await this.query(e,{poolId:t,timeframe:n});if(!a.success||!a.data?.pool?.statistics){throw new Error(a.error||"Failed to fetch pool statistics")}return a.data.pool.statistics}async getPoolLiquidityProviders(t,n=50,e=0){const a=`\n      query Pool($poolId: String!, $limit: Int, $offset: Int) {\n        pool {\n          liquidity_providers(pool_id: $poolId, limit: $limit, offset: $offset) {\n            providers {\n              address\n              liquidity_provided\n              percentage_share\n              token_1_amount\n              token_2_amount\n              rewards_earned\n              joined_at\n              chain_uid\n            }\n            total_providers\n          }\n        }\n      }\n    `;const o=await this.query(a,{poolId:t,limit:n,offset:e});if(!o.success||!o.data?.pool?.liquidity_providers){throw new Error(o.error||"Failed to fetch pool liquidity providers")}return o.data.pool.liquidity_providers}async getPoolTransactions(t,n=50,e=0,a){const o=`\n      query Pool($poolId: String!, $limit: Int, $offset: Int, $type: String) {\n        pool {\n          transactions(pool_id: $poolId, limit: $limit, offset: $offset, type: $type) {\n            transactions {\n              tx_hash\n              type\n              user\n              token_in\n              token_out\n              amount_in\n              amount_out\n              token_1_amount\n              token_2_amount\n              liquidity_amount\n              fee_paid\n              timestamp\n              block_height\n              chain_uid\n            }\n            total_transactions\n          }\n        }\n      }\n    `;const r=await this.query(o,{poolId:t,limit:n,offset:e,type:a});if(!r.success||!r.data?.pool?.transactions){throw new Error(r.error||"Failed to fetch pool transactions")}return r.data.pool.transactions}async getPoolVolume(t,n="24h"){const e=`\n      query Pool($poolId: String!, $period: String!) {\n        pool {\n          volume(pool_id: $poolId, period: $period) {\n            volume_data {\n              timestamp\n              volume\n              trade_count\n              unique_traders\n            }\n            total_volume\n            average_volume\n          }\n        }\n      }\n    `;const a=await this.query(e,{poolId:t,period:n});if(!a.success||!a.data?.pool?.volume){throw new Error(a.error||"Failed to fetch pool volume")}return a.data.pool.volume}async getPoolFees(t,n="24h"){const e=`\n      query Pool($poolId: String!, $period: String!) {\n        pool {\n          fees(pool_id: $poolId, period: $period) {\n            fees_data {\n              timestamp\n              fees_collected\n              protocol_fees\n              lp_fees\n            }\n            total_fees\n            fee_rate\n          }\n        }\n      }\n    `;const a=await this.query(e,{poolId:t,period:n});if(!a.success||!a.data?.pool?.fees){throw new Error(a.error||"Failed to fetch pool fees")}return a.data.pool.fees}async getPoolAPR(t){const n=`\n      query Pool($poolId: String!) {\n        pool {\n          apr(pool_id: $poolId) {\n            current_apr\n            current_apy\n            apr_7d_avg\n            apr_30d_avg\n            fee_apr\n            reward_apr\n            breakdown {\n              component\n              apr\n              description\n            }\n          }\n        }\n      }\n    `;const e=await this.query(n,{poolId:t});if(!e.success||!e.data?.pool?.apr){throw new Error(e.error||"Failed to fetch pool APR")}return e.data.pool.apr}async getPoolTVL(t,n="24h"){const e=`\n      query Pool($poolId: String!, $period: String!) {\n        pool {\n          tvl(pool_id: $poolId, period: $period) {\n            tvl_data {\n              timestamp\n              tvl\n              token_1_reserve\n              token_2_reserve\n            }\n            current_tvl\n            tvl_change\n            tvl_change_percentage\n          }\n        }\n      }\n    `;const a=await this.query(e,{poolId:t,period:n});if(!a.success||!a.data?.pool?.tvl){throw new Error(a.error||"Failed to fetch pool TVL")}return a.data.pool.tvl}async getPoolComposition(t){const n=`\n      query Pool($poolId: String!) {\n        pool {\n          composition(pool_id: $poolId) {\n            token_1 {\n              symbol\n              amount\n              value_usd\n              percentage\n            }\n            token_2 {\n              symbol\n              amount\n              value_usd\n              percentage\n            }\n            total_value\n            price_ratio\n          }\n        }\n      }\n    `;const e=await this.query(n,{poolId:t});if(!e.success||!e.data?.pool?.composition){throw new Error(e.error||"Failed to fetch pool composition")}return e.data.pool.composition}async searchTokens(t,n){const e={search:t};if(n){e.chainUids=[n]}const a=await this.getTokenMetadata(e);const o=t.toLowerCase();return a.filter((t=>t.displayName?.toLowerCase().includes(o)||t.tokenId?.toLowerCase().includes(o)||t.description?.toLowerCase().includes(o)||t.symbol?.toLowerCase().includes(o)||t.name?.toLowerCase().includes(o)))}async getTokenBySymbol(t,n){const e=await this.getTokenMetadata({chainUids:[n]});return e.find((n=>n.displayName?.toLowerCase()===t.toLowerCase()||n.symbol?.toLowerCase()===t.toLowerCase()))||null}async getTokenById(t){const n=`\n      query Token($tokenId: String!) {\n        token {\n          token_metadata(token_id: $tokenId) {\n            coinDecimal\n            displayName\n            tokenId\n            description\n            image\n            price\n            price_change_24h\n            price_change_7d\n            dex\n            chain_uids\n            total_volume\n            total_volume_24h\n            tags\n            min_swap_value\n            social\n            is_verified\n            market_cap\n            circulating_supply\n            total_supply\n            max_supply\n            holders_count\n          }\n        }\n      }\n    `;const e=await this.query(n,{tokenId:t});if(!e.success||!e.data?.token?.token_metadata){return null}return e.data.token.token_metadata}async getTokenPriceHistory(t,n="24h"){const e=`\n      query Token($tokenId: String!, $period: String!) {\n        token {\n          price_history(token_id: $tokenId, period: $period) {\n            data {\n              timestamp\n              price\n              volume\n            }\n          }\n        }\n      }\n    `;const a=await this.query(e,{tokenId:t,period:n});if(!a.success||!a.data?.token?.price_history?.data){throw new Error(a.error||"Failed to fetch token price history")}return a.data.token.price_history.data}async getTokenHolders(t,n=100,e=0){const a=`\n      query Token($tokenId: String!, $limit: Int, $offset: Int) {\n        token {\n          holders(token_id: $tokenId, limit: $limit, offset: $offset) {\n            holders {\n              address\n              balance\n              percentage\n              chain_uid\n            }\n            total_holders\n          }\n        }\n      }\n    `;const o=await this.query(a,{tokenId:t,limit:n,offset:e});if(!o.success||!o.data?.token?.holders){throw new Error(o.error||"Failed to fetch token holders")}return o.data.token.holders}async getTokenTransfers(t,n=50,e=0){const a=`\n      query Token($tokenId: String!, $limit: Int, $offset: Int) {\n        token {\n          transfers(token_id: $tokenId, limit: $limit, offset: $offset) {\n            transfers {\n              tx_hash\n              from\n              to\n              amount\n              timestamp\n              block_height\n              chain_uid\n            }\n            total_transfers\n          }\n        }\n      }\n    `;const o=await this.query(a,{tokenId:t,limit:n,offset:e});if(!o.success||!o.data?.token?.transfers){throw new Error(o.error||"Failed to fetch token transfers")}return o.data.token.transfers}async getTokenSupply(t){const n=`\n      query Token($tokenId: String!) {\n        token {\n          supply(token_id: $tokenId) {\n            total_supply\n            circulating_supply\n            max_supply\n            burned_supply\n            locked_supply\n          }\n        }\n      }\n    `;const e=await this.query(n,{tokenId:t});if(!e.success||!e.data?.token?.supply){throw new Error(e.error||"Failed to fetch token supply")}return e.data.token.supply}async getTokenMarketData(t){const n=`\n      query Token($tokenId: String!) {\n        token {\n          market_data(token_id: $tokenId) {\n            price\n            price_change_24h\n            price_change_7d\n            market_cap\n            volume_24h\n            liquidity\n            fdv\n            high_24h\n            low_24h\n            ath\n            ath_date\n            atl\n            atl_date\n          }\n        }\n      }\n    `;const e=await this.query(n,{tokenId:t});if(!e.success||!e.data?.token?.market_data){throw new Error(e.error||"Failed to fetch token market data")}return e.data.token.market_data}async getTokenSocial(t){const n=`\n      query Token($tokenId: String!) {\n        token {\n          social(token_id: $tokenId) {\n            website\n            twitter\n            telegram\n            discord\n            github\n            reddit\n            coingecko\n            coinmarketcap\n          }\n        }\n      }\n    `;const e=await this.query(n,{tokenId:t});if(!e.success||!e.data?.token?.social){throw new Error(e.error||"Failed to fetch token social data")}return e.data.token.social}async getTokenPairs(t){const n=`\n      query Token($tokenId: String!) {\n        token {\n          pairs(token_id: $tokenId) {\n            pair_id\n            token_1\n            token_2\n            pool_address\n            liquidity_usd\n            volume_24h\n            apr\n            dex\n            chain_uid\n          }\n        }\n      }\n    `;const e=await this.query(n,{tokenId:t});if(!e.success||!e.data?.token?.pairs){throw new Error(e.error||"Failed to fetch token pairs")}return e.data.token.pairs}async getVerifiedTokens(t){return this.getTokenMetadata({verified:true,chainUids:t,limit:1e3})}async getTokenAnalytics(t,n="24h"){const e=`\n      query Token($tokenId: String!, $timeframe: String!) {\n        token {\n          analytics(token_id: $tokenId, timeframe: $timeframe) {\n            price_metrics {\n              current_price\n              price_change\n              price_change_percentage\n              high\n              low\n            }\n            volume_metrics {\n              volume\n              volume_change\n              volume_change_percentage\n            }\n            liquidity_metrics {\n              total_liquidity\n              liquidity_change\n              liquidity_change_percentage\n            }\n            trading_metrics {\n              trades_count\n              unique_traders\n              avg_trade_size\n            }\n          }\n        }\n      }\n    `;const a=await this.query(e,{tokenId:t,timeframe:n});if(!a.success||!a.data?.token?.analytics){throw new Error(a.error||"Failed to fetch token analytics")}return a.data.token.analytics}}const it=t=>new st(t);class ct{constructor(t){const n={...e,...t};this.endpoint=n.restEndpoint;this.timeout=n.apiTimeout}async request(t,e={}){const a=new AbortController;const o=setTimeout((()=>a.abort()),this.timeout);try{const{method:n="GET",body:r,headers:s={}}=e;const i=await fetch(`${this.endpoint}${t}`,{method:n,headers:{"Content-Type":"application/json",Accept:"application/json",...s},body:r?JSON.stringify(r):undefined,signal:a.signal});clearTimeout(o);if(!i.ok){const t=await i.text();throw new Error(`HTTP ${i.status}: ${t}`)}const c=await i.json();return{success:true,data:c}}catch(e){clearTimeout(o);n.error("Utils",`REST API request failed (${t}):`,e);return{success:false,error:e instanceof Error?e.message:"Unknown error"}}}async getRoutes(t){const n=new URLSearchParams({amount_in:t.amount_in,token_in:t.token_in,token_out:t.token_out});if(t.external!==undefined){n.append("external",t.external.toString())}if(t.chain_uids&&t.chain_uids.length>0){t.chain_uids.forEach((t=>{n.append("chain_uids",t)}))}const e=await this.request(`/routes?${n}`);if(!e.success||!e.data){throw new Error(e.error||"Failed to fetch routes")}return e.data.paths}async getOptimalRoute(t){const n=await this.request("/routes/optimal",{method:"POST",body:t});if(!n.success||!n.data){throw new Error(n.error||"Failed to fetch optimal route")}return n.data.route}async getMultiRoutes(t){const n=await this.request("/routes/multi",{method:"POST",body:t});if(!n.success||!n.data){throw new Error(n.error||"Failed to fetch multi routes")}return n.data.routes}async getRouteStatistics(t){const n=t?`?timeframe=${t}`:"";const e=await this.request(`/routes/statistics${n}`);if(!e.success||!e.data){throw new Error(e.error||"Failed to fetch route statistics")}return e.data}async getRouteFees(t){const n=await this.request("/routes/fees",{method:"POST",body:t});if(!n.success||!n.data){throw new Error(n.error||"Failed to fetch route fees")}return n.data}async simulateRoute(t){const n=await this.request("/routes/simulate",{method:"POST",body:t});if(!n.success||!n.data){throw new Error(n.error||"Failed to simulate route")}return n.data}async buildSwapTransaction(t){const n=await this.request("/swap",{method:"POST",body:t});if(!n.success||!n.data){throw new Error(n.error||"Failed to build swap transaction")}return n.data}async buildAddLiquidityTransaction(t){const n=await this.request("/add_liquidity",{method:"POST",body:t});if(!n.success||!n.data){throw new Error(n.error||"Failed to build add liquidity transaction")}return n.data}async buildRemoveLiquidityTransaction(t){const n=await this.request("/remove_liquidity",{method:"POST",body:t});if(!n.success||!n.data){throw new Error(n.error||"Failed to build remove liquidity transaction")}return n.data}async simulateSwap(t){const n=new URLSearchParams({amount_in:t.amount_in,token_in:t.token_in,token_out:t.token_out});if(t.chain_uid){n.append("chain_uid",t.chain_uid)}const e=await this.request(`/simulate_swap?${n}`);if(!e.success||!e.data){throw new Error(e.error||"Failed to simulate swap")}return e.data}async getBestRoute(t){const n=await this.getRoutes(t);if(n.length===0){return null}return n.sort(((t,n)=>parseFloat(t.total_price_impact)-parseFloat(n.total_price_impact)))[0]}async getTransactionStatus(t,n){const e=await this.request(`/transaction/${t}?chain_uid=${n}`);if(!e.success||!e.data){throw new Error(e.error||"Failed to get transaction status")}return e.data}async getTransactionDetails(t,n){const e=await this.request(`/transactions/${t}?chain_uid=${n}`);if(!e.success||!e.data){throw new Error(e.error||"Failed to get transaction details")}return e.data}async broadcastTransaction(t,n){const e=await this.request("/transactions/broadcast",{method:"POST",body:{tx:t,chain_uid:n}});if(!e.success||!e.data){throw new Error(e.error||"Failed to broadcast transaction")}return e.data}async estimateTransactionFees(t,n){const e=await this.request("/transactions/estimate_fees",{method:"POST",body:{transaction:t,chain_uid:n}});if(!e.success||!e.data){throw new Error(e.error||"Failed to estimate transaction fees")}return e.data}async simulateTransaction(t,n){const e=await this.request("/transactions/simulate",{method:"POST",body:{transaction:t,chain_uid:n}});if(!e.success||!e.data){throw new Error(e.error||"Failed to simulate transaction")}return e.data}async getUserTransactions(t,n,e){const a=new URLSearchParams({address:t,chain_uid:n});if(e?.limit)a.append("limit",e.limit.toString());if(e?.offset)a.append("offset",e.offset.toString());if(e?.type)a.append("type",e.type);if(e?.status)a.append("status",e.status);const o=await this.request(`/transactions/user/${t}?${a}`);if(!o.success||!o.data){throw new Error(o.error||"Failed to get user transactions")}return o.data}async getPendingTransactions(t,n){const e=await this.request(`/transactions/pending?address=${t}&chain_uid=${n}`);if(!e.success||!e.data){throw new Error(e.error||"Failed to get pending transactions")}return e.data}async batchTransactions(t){const n=await this.request("/transactions/batch",{method:"POST",body:{transactions:t}});if(!n.success||!n.data){throw new Error(n.error||"Failed to batch transactions")}return n.data}async estimateGas(t){const n=await this.request("/estimate_gas",{method:"POST",body:t});if(!n.success||!n.data){throw new Error(n.error||"Failed to estimate gas")}return n.data}}const lt=t=>new ct(t);class dt{constructor(t){this.graphql=it(t);this.rest=lt(t)}async getChains(t){return this.graphql.getChains(t)}async getTokenMetadata(t){return this.graphql.getTokenMetadata(t)}async getTokenById(t){return this.graphql.getTokenById(t)}async getTokenPriceHistory(t,n="24h"){return this.graphql.getTokenPriceHistory(t,n)}async getTokenHolders(t,n=100,e=0){return this.graphql.getTokenHolders(t,n,e)}async getTokenTransfers(t,n=50,e=0){return this.graphql.getTokenTransfers(t,n,e)}async getTokenSupply(t){return this.graphql.getTokenSupply(t)}async getTokenMarketData(t){return this.graphql.getTokenMarketData(t)}async getTokenSocial(t){return this.graphql.getTokenSocial(t)}async getTokenPairs(t){return this.graphql.getTokenPairs(t)}async getVerifiedTokens(t){return this.graphql.getVerifiedTokens(t)}async getTokenAnalytics(t,n="24h"){return this.graphql.getTokenAnalytics(t,n)}async searchTokens(t,n){return this.graphql.searchTokens(t,n)}async getTokenBySymbol(t,n){return this.graphql.getTokenBySymbol(t,n)}async getAllPools(t=true){try{const n=await this.graphql.getAllPools(undefined,t);return{success:true,data:n}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to get pools"}}}async getPoolInfo(t,n){return this.graphql.getPoolInfo(t,n)}async getPoolById(t){return this.graphql.getPoolById(t)}async getPoolStatistics(t,n="24h"){return this.graphql.getPoolStatistics(t,n)}async getPoolLiquidityProviders(t,n=50,e=0){return this.graphql.getPoolLiquidityProviders(t,n,e)}async getPoolTransactions(t,n=50,e=0,a){return this.graphql.getPoolTransactions(t,n,e,a)}async getPoolVolume(t,n="24h"){return this.graphql.getPoolVolume(t,n)}async getPoolFees(t,n="24h"){return this.graphql.getPoolFees(t,n)}async getPoolAPR(t){return this.graphql.getPoolAPR(t)}async getPoolTVL(t,n="24h"){return this.graphql.getPoolTVL(t,n)}async getPoolComposition(t){return this.graphql.getPoolComposition(t)}async getAllChains(t){try{const n=await this.getChains({showAllChains:t});return{success:true,data:n}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to get chains"}}}async getAllTokens(){try{const t=await this.getTokenMetadata();return{success:true,data:t}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to get tokens"}}}async getTokenDenoms(t){n.warn("Utils",`getTokenDenoms(${t}) is not implemented in Euclid API`);return{success:true,data:{router:{token_denoms:{denoms:[]}}}}}async getEscrows(t){n.warn("Utils",`getEscrows(${t}) is not implemented in Euclid API`);return{success:true,data:{router:{escrows:[]}}}}async getBalance(t,n){try{const e=await this.getUserBalances({address:t,chain_uid:n});const a={balance:{all:e.map((t=>({denom:t.token,amount:t.balance})))}};return{success:true,data:a}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to get balance"}}}async getUserBalances(t){return this.graphql.getUserBalances(t)}async getRoutes(t){return this.rest.getRoutes(t)}async getOptimalRoute(t){return this.rest.getOptimalRoute(t)}async getMultiRoutes(t){return this.rest.getMultiRoutes(t)}async getRouteStatistics(t){return this.rest.getRouteStatistics(t)}async getRouteFees(t){return this.rest.getRouteFees(t)}async simulateRoute(t){return this.rest.simulateRoute(t)}async getRoutesWrapped(t){try{const n=await this.getRoutes(t);return{success:true,data:{paths:n}}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to get routes"}}}async getRoutesLegacy(t){return this.getRoutesWrapped(t)}async getBestRoute(t){return this.rest.getBestRoute(t)}async simulateSwap(t){return this.rest.simulateSwap(t)}async createSwapTransaction(t){return this.rest.buildSwapTransaction(t)}async createSwapTransactionWrapped(t){try{const n=await this.createSwapTransaction(t);return{success:true,data:n}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to create swap transaction"}}}async buildSwapTransaction(t){return this.createSwapTransaction(t)}async createAddLiquidityTransaction(t){return this.rest.buildAddLiquidityTransaction(t)}async createAddLiquidityTransactionWrapped(t){try{const n=await this.createAddLiquidityTransaction(t);return{success:true,data:n}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to create add liquidity transaction"}}}async createRemoveLiquidityTransaction(t){return this.rest.buildRemoveLiquidityTransaction(t)}async createRemoveLiquidityTransactionWrapped(t){try{const n=await this.createRemoveLiquidityTransaction(t);return{success:true,data:n}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to create remove liquidity transaction"}}}async trackTransaction(t,e){n.warn("Utils",`trackTransaction(${t}, ${e}) not implemented`);return{status:"pending"}}async trackTransactionWrapped(t,n){try{const e=await this.trackTransaction(t,n);return{success:true,data:e}}catch(t){return{success:false,error:t instanceof Error?t.message:"Failed to track transaction"}}}async buildAddLiquidityTransaction(t){return this.rest.buildAddLiquidityTransaction(t)}async buildRemoveLiquidityTransaction(t){return this.rest.buildRemoveLiquidityTransaction(t)}async getTransactionStatus(t,n){return this.rest.getTransactionStatus(t,n)}async getTransactionDetails(t,n){return this.rest.getTransactionDetails(t,n)}async broadcastTransaction(t,n){return this.rest.broadcastTransaction(t,n)}async estimateTransactionFees(t,n){return this.rest.estimateTransactionFees(t,n)}async simulateTransaction(t,n){return this.rest.simulateTransaction(t,n)}async getUserTransactions(t,n,e){return this.rest.getUserTransactions(t,n,e)}async getPendingTransactions(t,n){return this.rest.getPendingTransactions(t,n)}async batchTransactions(t){return this.rest.batchTransactions(t)}async estimateGas(t){return this.rest.estimateGas(t)}async getMarketData(){const[t,n,e]=await Promise.all([this.getChains(),this.getTokenMetadata(),this.getAllPools()]);const a=e.success?e.data||[]:[];return{chains:t,tokens:n,pools:a}}async getUserPortfolio(t){const[n,e,a]=await Promise.all([this.getUserBalances(t),this.getChains(),this.getTokenMetadata()]);return{balances:n,chains:e,tokens:a}}async getSwapQuote(t,n,e,a){const o={amount_in:e,token_in:t,token_out:n,chain_uids:a};const[r,s]=await Promise.all([this.getBestRoute(o),this.simulateSwap({amount_in:e,token_in:t,token_out:n}).catch((()=>({amount_out:"0",price_impact:"0"})))]);return{route:r,expectedOutput:s.amount_out,priceImpact:s.price_impact}}}const ut=new dt;const ht={ETHEREUM:"ethereum",POLYGON:"polygon",ARBITRUM:"arbitrum",OPTIMISM:"optimism",COSMOS_HUB:"cosmoshub-4",OSMOSIS:"osmosis-1",JUNO:"juno-1",STARGAZE:"stargaze-1"};const wt={METAMASK:"metamask",KEPLR:"keplr",WALLET_CONNECT:"walletconnect",COINBASE:"coinbase",OTHER:"other"};const pt={SWAP:"swap",ADD_LIQUIDITY:"add_liquidity",REMOVE_LIQUIDITY:"remove_liquidity",TRANSFER:"transfer"};const yt={PENDING:"pending",SUCCESS:"success",FAILED:"failed"};const mt={CHAINS:"/api/chains",TOKENS:"/api/tokens",POOLS:"/api/pools",ROUTES:"/api/routes",BALANCES:"/api/balances",TRANSACTIONS:"/api/transactions",GRAPHQL:"/graphql"};const ft={WALLET_PREFERENCES:"euclid_wallet_preferences",THEME:"euclid_theme",SLIPPAGE:"euclid_slippage",TRANSACTION_HISTORY:"euclid_transaction_history"};const _t={SLIPPAGE:e.ui.defaultSlippage,ROUTE_REFRESH_INTERVAL:e.refreshIntervals.routes,MARKET_DATA_REFRESH_INTERVAL:e.refreshIntervals.marketData,BALANCE_REFRESH_INTERVAL:e.refreshIntervals.balances,TRANSACTION_TIMEOUT:3e5};const gt={MODAL_Z_INDEX:e.ui.zIndex.modal,TOOLTIP_Z_INDEX:e.ui.zIndex.tooltip,DROPDOWN_Z_INDEX:e.ui.zIndex.dropdown,ANIMATION_DURATION:e.ui.animationDuration};const kt={ETH_ADDRESS:/^0x[a-fA-F0-9]{40}$/,COSMOS_ADDRESS:/^[a-z0-9]{39,59}$/,DECIMAL_NUMBER:/^\d*\.?\d*$/,POSITIVE_NUMBER:/^[+]?([0-9]*[.])?[0-9]+$/};const Tt={WALLET_NOT_CONNECTED:"Wallet not connected",INSUFFICIENT_BALANCE:"Insufficient balance",INVALID_AMOUNT:"Invalid amount",NO_ROUTE_FOUND:"No route found for this swap",TRANSACTION_FAILED:"Transaction failed",NETWORK_ERROR:"Network error occurred",TIMEOUT:"Request timeout"};const Et={WALLET_CONNECTED:"Wallet connected successfully",TRANSACTION_SUBMITTED:"Transaction submitted",TRANSACTION_CONFIRMED:"Transaction confirmed",LIQUIDITY_ADDED:"Liquidity added successfully",LIQUIDITY_REMOVED:"Liquidity removed successfully"};const It={DARK_MODE:e.features.darkMode,ADVANCED_ROUTING:e.features.advancedRouting,TRANSACTION_HISTORY:e.features.transactionHistory};export{mt as A,ht as C,_t as D,Tt as E,It as F,kt as P,ft as S,pt as T,gt as U,wt as W,y as a,V as b,_ as c,A as d,T as e,$ as f,Y as g,b as h,ut as i,l as j,d as k,rt as l,c as m,yt as n,Et as o,k as p,I as s,q as w};
//# sourceMappingURL=p-C1wLnQfG.js.map